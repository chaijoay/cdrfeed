/*
**++
**  FACILITY    : CDR Mapping
**
**  FILE NAME   : frm_cdr_mapp.c
**
**  ABSTRACT    : All CDR Mapping Functions for Base HPE FRM Ver 12.1-0
**
**  AUTHOR  : Palanichamy.M.
**
**  CREATE DATE : 5-Sep-1997
**
**  CURRENT VERSION NO : 12.1
**
**  LAST RELEASE DATE  : Sep-2016
**
*/

#include <stdio.h>
#include <ctype.h>
#include <strings.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>

#include "frm_cdr_mapp.h"

#include "frm_cdr_feed.h"
#include "frm_cdr_glob.h"
#include "frm_cdr_stru.h"

#include "minIni.h"
#include "procsig.h"
#include "strlogutl.h"



/* #define DEBUG_ANO */         /* Use this for debug only */
/* #define DEBUG_BNO */         /* Use this for debug only */
#define CONV_BNO_C11_TO_005     /* Enable Convert C11,#11,001C11,001#11 to 005 - Added by Kawee on 01-Mar-2007 */

extern int  errno;

#ifndef _PRNT_FUNC_CALL_
    #define _PRNT_FUNC_CALL_
#endif

/* external buffers owned by frm_cdr_feed.c */

extern int glb_MtxInd;                  /* MTX Type under processing */
extern long glb_PostpaidMin_Duration;   /* CDR Minimum Duration */
extern long glb_PrepaidMin_Duration;    /* CDR Minimum Duration */
extern unsigned long glb_ReadCtr;       /* No of Records Read from CDR file */
extern unsigned long glb_IgnCtr;        /* No of Records Ignored due to X network call */
extern unsigned long glb_DuraCtr;       /* No of Records Rejected due to less Duration */
extern int glb_PartId;                  /* Partition ID - for CDR under Processing */
extern int glb_UseRatedCdr; /* xxx */

double Txn_value, Cont_value;           /* Global buffer to hold Transaction, Content Value for USC CDR */

int    glb_nCarrierPriceRec;
int    glb_nCountryCodeRec;

char   gszCostcode_Desc[80];
char   gszCostcode_Name[80];
/* global buffers for cdr mapping */

struct stat glb_fstat;          /* global buffer to hold file status from OS */

GSM_RECORD      gsm_buf;        /* global buffer for GSM CDR */
SMS_RECORD      sms_buf;        /* global buffer for SMS CDR */ /* aded by Kawee on 07-Apr-2005 */
SMC_RECORD      smc_buf;        /* global buffer for SMC CDR */ /* aded by Jetsada on 15-Aug-2005 */
SSP_RECORD      ssp_buf;        /* global buffer for SSP CDR */
USC_RECORD      usc_buf;        /* global buffer for USC CDR */
GPRS_RECORD     gprs_buf;       /* global buffer for GPRS CDR */ /* added by kawin on 20-Sep-2002 */
GPRST_RECORD    gprst_buf;      /* global buffer for GPRST CDR */ /* added by Kawee on 20-May-2004 */
MMS_RECORD      mms_buf;        /* global buffer for MMS CDR */ /* added by Kawee on 05-Nov-2004 */
MSCPPS_RECORD   mscpps_buf;     /* global buffer for MSCPPS CDR */ /* added by Kawee on 16-Dec-2002 */

COM_RECORD      com_buf;        /* global buffer for Common Structure Record */
ALM_RECORD      alm_buf;        /* global buffer for Alarm Data Record */

DPCGSM_RECORD   dpcgsm_buf;     /* global buffer for DPCGSM_TYPE, DPCTAC_TYPE or DPCAIS_TYPE CDR */

VOICE_EVENT     voice_event;    // global buffer for VOICE Event - added by Jetsada on 11-Aug-2005
DATA_EVENT      data_event;     // global buffer for Data Event - added by Jetsada on 08-Aug-2005
USC_EVENT       usc_event;      /* global buffer for USC Event */ /* added by Jetsada on 09-Aug-2005 */
SMS_EVENT       sms_event;      // global buffer for SMS Event - added by Jetsada on 15-Aug-2005
MMS_EVENT       mms_event;      // global buffer for MMS Event - added by Jetsada on 09-Aug-2005
CDG_EVENT       cdg_event;      /* global buffer for CDG Event */ /* added by Jetsada on 09-Aug-2005 */
RBT_EVENT       rbt_event;      /* global buffer for RBT Event */ /* added by Jetsada on 09-Aug-2005 */
SESSION_EVENT   session_event;  /* global buffer for SESSION Event */ /* added by Jetsada on 13-Sep-2007 */
IR_EVENT        ir_event;       // global buffer for NRTRDE Event - added by Kawee on 30-Jan-2008
AMF_EVENT       amf_event;      /* global buffer for AMF Event */ /* added by Kawee on Aug-2011 */
VAS_EVENT       vas_event;      // global buffer for vas event (common vas format) - added by Thanakorn on Sep-2012, FMS V11

const int glb_tac = 21;         /* global variable - total number of Area Codes (See Below the AREA_TABLE) */
const int glb_tSSRec = 0;       /* global variable to count total SS Records */

MNET_TABLE *glb_MnetHead = NULL;                    /* global pointer to AIS MOB_NETWORK Table */
MNET_TABLE *glb_DpcMnetHead = NULL;                 /* global pointer to DPC MOB_NETWORK Table */
NPORT_TABLE *glb_NportHead = NULL;                  /* global pointer to NUM_PORT Table */
NPBN_TABLE *glb_NpbnHead = NULL;                    /* global pointer to NPBN Table */
MSRN_TABLE *glb_MsrnHead = NULL;                    /* global pointer to Mobile Station Roaming Number Table */
ZONE_TABLE *glb_ZoneHead = NULL;                    /* global pointer to AIS Zone Table */
ZONE_TABLE *glb_DpcZoneHead = NULL;                 /* global pointer to DPC Zone Table */
ZMAP_TABLE *glb_ZmapHead = NULL;                    /* global pointer to AIS Zone Mapping Table */
ZMAP_TABLE *glb_DpcZmapHead = NULL;                 /* global pointer to DPC Zone Mapping Table */
NRATE_TABLE *glb_NrateHead = NULL;                  /* global pointer to AIS National Rate Table */
NRATE_TABLE *glb_DpcNrateHead = NULL;               /* global pointer to DPC National Rate Table */
IDD_TABLE *glb_IddHead = NULL;                      /* global pointer to International Rate Table */
SERVICE3G_TABLE *glb_3GHead = NULL;                 /* global pointer to 3G/2G Service Table */
CMAP_TABLE *glb_CmapHead = NULL;                    /* global pointer to Cell Map Table */
SRATE_TABLE *glb_SrateHead = NULL;                  /* global pointer to Service Rate Table */
VAS_TABLE *glb_VasHead = NULL;                      /* global pointer to VAS Mapping Table */
FMAP_TABLE *glb_FmapHead = NULL;                    /* global pointer to Feature Mapping Table */
CUST_TARIFF_TABLE *glb_CustTariffHead = NULL;       /* global pointer to AIS CUST_TARIFF Table */
CUST_TARIFF_TABLE *glb_DpcCustTariffHead = NULL;    /* global pointer to DPC CUST_TARIFF Table */
TARIFF_RATE_TABLE *glb_TariffRateHead = NULL;       /* global pointer to Zone Mapping Table */
TEMP_PHONE_TABLE *glb_TempPhoneHead = NULL;         /* global pointer to Temp Phone Table */
BILL_REG_TABLE *glb_BillRegHead = NULL;             /* global pointer to Bill Register Table */
ADJ_GRP_TABLE *glb_AdjGrpHead = NULL;               /* global pointer to Adjcent Group Table */
BILL_AREA_TABLE *glb_BillAreaHead = NULL;           /* global pointer to Bill Area Table */
BEARER_TABLE *glb_BearerHead = NULL;                /* global pointer to Bearer Table */
COSTCODE_TABLE *glb_CostCodeHead = NULL;            /* global pointer to Cost Code Table */
COSTBAND_TABLE *glb_CostBandHead = NULL;            /* global pointer to Cost Band Table */
RATING_TARIFF_TABLE *glb_RatingTariffHead = NULL;   /* global pointer to Rating Tariff Table */
RATING_ELEMENT_TABLE *glb_RatingElementHead = NULL; /* global pointer to Rating Element Table */
COSTGROUP_XREF_TABLE *glb_CostgroupXrefHead = NULL; /* global pointer to Costgroup Xref Table */
SERVICE_KEY_TABLE *glb_ServiceKeyHead = NULL;       /* global pointer to Service Key Table */
PPS_DESC_TABLE *glb_PpsDescHead = NULL;             /* global pointer to Pps Desc Table */
AIN_COSTCODE_TABLE *glb_AinCostCodeHead = NULL;     /* global pointer to AIN Cost Code Table */
AIN_OPER_CARRIER_MASTER_TABLE *glb_AinOperCarrierMasterHead = NULL;         /* global pointer to AIN Operator Carrier Master Table */
AIN_RATING_TARIFF_ELEMENT_TABLE *glb_AinRatingTariffElementHead = NULL;     /* global pointer to AIN Rating Tariff Element Table */
AIN_ROUTE_MASTER_TABLE *glb_AinRouteMasterHead = NULL;      /* global pointer to AIN Route Master Table */
AIN_SUB_TYPE_TABLE *glb_AinSubTypeHead = NULL;              /* global pointer to AIN Subscriber Type Table */
AIN_E1_MAPPING_TABLE *glb_AinE1MappingHead = NULL;          /* global pointer to AIN E1 Mapping Table */
AIN_BASIC_TIME_RATE_TABLE *glb_AinBasicTimeRateHead = NULL; /* global pointer to AIN Basic Time Rate Table */
WLAN_PACKAGE_TABLE *glb_WlanPackageHead = NULL;             /* global pointer to WLAN_PACKAGE Table */
IODC_TABLE *glb_IodcHead = NULL;                            /* global pointer to IODC Table */
IMSI_TABLE *glb_ImsiHead = NULL;                            /* global pointer to IMSI Table */
IMSI_VSO_TABLE *glb_ImsiVsoHead = NULL;                     /* global pointer to IMSI VSO Table */
FIX_RATE_TABLE *glb_FixRateHead = NULL;                     /* global pointer to FIX RATE Table */
REJ_ORIG_ADDR_TABLE *glb_RejOrigAddrHead = NULL;            /* global pointer to REJ_ORIG_ADDR Table */
APN_TABLE *glb_ApnHead = NULL;                              /* global pointer to APN Table */
TOLLFREE_TABLE *glb_TollFreeHead = NULL;                    /* global pointer to Toll Free Table */
ONE_LOVE_TABLE *glb_OneLoveHead = NULL;                     /* global pointer to One Love Table */
BOS_IMEI_TABLE *glb_BosImeiHead = NULL;                     /* global pointer to IMEI Table */
COSTCODE_BNO_TABLE *glb_CostcodeBNoHead = NULL;             /* global pointer to Costcode Bno Table */
USMAP_TABLE *glb_UsMapHead = NULL;                          // global pointer to USMAP Table
GEO_TABLE *glb_GeoHead = NULL;                              // global pointer to Geo Table
CELLAREA_TABLE *glb_CellAreaHead = NULL;                              // global pointer to CellArea  Table
PLMN_CODE_TABLE *glb_PlmnCodeHead = NULL;
PLMN_CODE_TABLE *glb_PlmnPriceHead = NULL;
PLMN_CODE_TABLE *glb_PlmnCountryHead = NULL;
VASGROUP_TABLE *glb_VasGroupHead = NULL;

AREA_TABLE area_tab[] = {
    { 2, "02"  },  /* BKK */
    /* { 2, "09"  },  MALAYSIA old - Removed by Kawee on 29-Oct-2003 */
    { 3, "032" },  /* PKN/PBI/RBR */
    { 3, "034" },  /* KRI/NPT/SKM/SKN */
    { 3, "035" },  /* SPB/AYA/ATG */
    { 3, "036" },  /* LRI/SBR/SRI */
    { 3, "037" },  /* PRI/NYK/SKW */
    { 3, "038" },  /* CBI/CCO/RYG */
    { 3, "039" },  /* CTI/TRT */
    { 3, "042" },  /* UDN/NKI/SNK/NPM/MDH/LEI/NBP */
    { 3, "043" },  /* KKN/MKM/RET/KSN */
    { 3, "044" },  /* NMA/BRM/CPM/SRN */
    { 3, "045" },  /* UBN/SSK/YST/ACR */
    { 3, "053" },  /* CRI/CMI/LPN/MSN */
    { 3, "054" },  /* LPG/PYO/PRE/NAN */
    { 3, "055" },  /* PLK/STI/KPT/TAK/UTT */
    { 3, "056" },  /* NSN/PCT/PBN/UTI/CNT */
    { 3, "073" },  /* YLA/PTN/NWT */
    { 3, "074" },  /* SKA/PLG/STN */
    { 3, "075" },  /* NRT/TRG/KBI */
    { 3, "076" },  /* PKT/PNA */
    { 3, "077" },  /* SNI/CPN/RNG */
    /* { 3, "007" },  LAOS - Removed by Kawee on 29-Oct-2003 */
    /* { 5, "00760" },  MALAYSIA new - Removed by Kawee on 02-May-2007 */
    /* { 5, "00785" },  LAOS/CAMBODIA new - Removed by Kawee on 02-May-2007 */
    /* { 5, "00795" },  MYANMAR new -  Removed by Kawee on 02-May-2007 */
    { 0, "" }
};

/* Fixed IVR Mapping problem - Added below by Kawee on 18-Apr-2007 */
char ivracc_tab[3][4] = {
    "*",
    "900",
    "B"
};

const char gaszFrmSkipDet[NOF_SKIP][40] = {
    " FmsDet_SkipDetection=1",                      // Skip All Detection
    " DetParm_SkipAncestors=1",                     // Skip Ancestor Detection
    " DetParm_SkipAncestorsIfNoSib=1",              // Skip Ancestor Detection If No Siblings
    " DetParm_SkipParent=1",                        // Skip Parent Detection
    " DetParm_SkipParentIfNoSib=1",                 // Skip Parent Detection If No Siblings
    " FmsDet_SkipPipeLine=1",                       // Skip Pipeline
    " DetParm_SkipArchiveToOracle=1",               // Skip Archiving to Oracle
    " DetParm_SkipArchiveToVertica=1",              // Skip Archiving to Vertica
    " EntLoad_SkipHistory=1",                       // Skip Entity History Fields
    " FmsDet_SkipCollision=1",                      // Skip Collision Check
    " FmsDet_SkipVelocity=1",                       // Skip Velocity Check
    " FmsDet_SkipDupEvent=1",                       // Skip Duplicate Event Check
    " FmsDet_SkipUpdOldEvent=1",                    // Skip Update of Older Event in Collision/Velocity
    " FmsDet_SkipBlacklist=1",                      // Skip Blacklist Check
    " FmsDet_SkipUsageAccum=1",                     // Skip Usage Accumulation
    " ErmDet_SkipRecentCharge=1",                   // Skip Recent Charge
    " FmsDet_SkipDestUsage=1",                      // Skip Destination Usage
    " FmsDet_SkipThreshold=1",                      // Skip Threshold Check
    " FmsDet_SkipDest=1",                           // Skip Destination Check
    " FmsDet_SkipSusp=1",                           // Skip Suspension Check
    " FmsDet_SkipAuthorizedFeature=1",              // Skip Authorized Feature Check
    " FmsDet_SkipPattern=1",                        // Skip Pattern Check
    " FmsDet_SkipAccumPattern=1",                   // Skip Accumulation Pattern Check
    " FmsDet_SkipSeqPattern=1",                     // Skip Sequence Pattern Check
    " FmsDet_SkipImmediateRoam=1",                  // Skip Immediate Roam Check
    " FmsDet_SkipUnknown=1",                        // Skip Unknown Entity Check
    " FmsDet_SkipPrematureChange=1",                // Skip Premature Change Check
    " FmsDet_SkipRoamNoHome=1",                     // Skip Roam No Home Check
    " FmsDet_SkipInactiveCheck=1",                  // Skip Inactive Entity Check
    " FmsDet_SkipContact=1",                        // Skip Contact Check
    " ErmParm_SkipRealtimeAnalysis=1",              // Skip Realtime Event Analysis
    " ErmDet_SkipUtilityModule=1",                  // Skip ERM Utility Module
    " ErmDet_SkipEventPartitionOverride=1",         // Skip Event partition override
    " ErmDet_SkipPostPattern=1"                     // Skip Post Pattern Check
};
char raw_temp[MAX_READ_SIZE+1];
char glb_OriginalBno[100+1];        /* global buffer, stores Original Dialed digit of current Cdr file during processing - by Thanakorn on 09-Sep-2012, FMS V11 */
char raw_gsm[SIZE_SMSGPR+1];        /* global buffer for Raw GSM Record */
char raw_sms[SIZE_SMSRAW+1];        /* global buffer for Raw SMS Record */  /* Split from GSM - by Kawee on 07-Apr-2005 */
char raw_smc[SIZE_SMCRAW+1];        /* global buffer for Raw SMC Record */ /* added by Jetsada on 15-Aug-2005 */
char raw_ssp[SIZE_SSPRAW+1];        /* global buffer for Raw SSP Record */
char raw_usc[SIZE_USCRAW+1];        /* global buffer for Raw USC Record (buffer can contain old/new USC raw cdr) */
char raw_gprs[SIZE_GPRSRAW+1];      /* global buffer for Raw GPRS Record */ /* added by kawin on 20-Sep-2002 */
char raw_gprst[SIZE_GPRSTRAW+1];    /* global buffer for Raw GPRST Record */ /* added by Kawee on 20-May-2004 */
char raw_mms[SIZE_MMSRAW+1];        /* global buffer for Raw MMS Record */ /* added by Kawee on 05-May-2004 */
char raw_mscpps[SIZE_MSCPPSRAW+1];  /* global buffer for Raw MSCPPS Record */ /* added by Kawee on 16-Dec-2002 */
char raw_dpcgsm[SIZE_DPCGSMRAW+1];  /* global buffer for Raw DPCGSM_TYPE or DPCTAC_TYPE CDR */

char szGlbInputBuf[SIZE_INPUT+1];   /* global buffer for Contain Splitted Input Data */ /* added by Kawee on 02-Jun-2005 */
char raw_input[SIZE_INPUT+1];       /* global buffer for Contain Splitted Input Data */ /* added by Kawee on 02-Jun-2005 */
char *pbuf_gprst[NUMFLD_GPRST];     /* global pointer to Raw GPRST Record */ /* added by Kawee on 20-May-2004 */
char *pbuf_mms[NUMFLD_MMS];         /* global pointer to Raw MMS Record */ /* added by Kawee on 05-Nov-2004 */
char *pbuf_cdg[NOF_FLD_CDG];        /* global pointer to Raw CDG Record */ /* added by Kawee on 02-Jun-2005 */
char *pbuf_rbt[NOF_FLD_RBT];        /* global pointer to Raw RBT Record */ /* added by Jetsada on 13-Jul-2005 */
char *pbuf_ain[NOF_FLD_AIN];        /* global pointer to Raw AIN Record */ /* added by Kawee on 31-Jan-2007 */
char *pbuf_ccudr[NOF_FLD_CCUDR];    /* global pointer to Raw CCUDR Record */ /* added by Jetsada on 27-August-2007 */
char *pbuf_nrtrde[NOF_FLD_CMNIR]; /* global pointer to Raw NRTRDE Record */ /* added by Kawee on 30-Jan-2008 */
char *pbuf_amf[NOF_FLD_AMF];        /* global pointer to Raw AMF Record - added by Thanakorn on 04-Aug-2011 */
char *pbuf_sdg[NOF_FLD_SDG];        /* global pointer to Raw SDG Record - added by Thanakorn on 01-Mar-2012 */
char *pbuf_nrtscp[NOF_FLD_NRTSCP];  /* global pointer to Raw NRTSCP Record - added by Thanakorn on 24-Sep-2012 */
char *pbuf_gprs[NOF_FLD_GPRS];      /* global pointer to Raw GPRS Record - added by Thanakorn on 01-Mar-2013 */
char *pbuf_ocsvpn[NOF_FLD_OCS];     /* global pointer to Raw Maritime MT Record - added by Thanakorn on 18-Nov-2014 */
char *pbuf_gsmtop[NOF_FLD_TOP];     /* global pointer to Raw GSM Topup Record - added by Thanakorn on 5-Feb-2015 */
char *pbuf_ims[NOF_FLD_IMS];        /* global pointer to Raw IMS Record - added by Thanakorn on 28-Sep-2015 */
char *pbuf_rdc[NOF_FLD_RDC];        /* global pointer to Raw RDC Record - added by Thanakorn on 22-Jan-2016 */
char *pbuf_rdcsms[NOF_FLD_RDCSMS];  /* global pointer to Raw RDC SMS Record - added by Thanakorn on 22-Jan-2016 */
char *pbuf_rbm[NOF_FLD_RBM];

/*------------------------------------------------------------------------------------*/

/*
** Name     : Read_Gsm_Cdr()
**
** Description  : Reads One CDR from GSM Raw CDR file into raw buffer.
**        If Header Record is read, reads One CDR again.
**        If Trailer Record is read, reads One CDR again.
**        Parses and copies data of all fields from raw buffer to GSM global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Gsm_Cdr()
{
    int i = 0, pos = 0;
    // int nSizeShift = 8;     /* Bno size is extened 8 char more (inserted) */

    memset(&gsm_buf, 0x00, sizeof (gsm_buf));
    memset(raw_gsm, 0x00, sizeof (raw_gsm));
    memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
    memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
    memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));

    if ( fgets((char *)raw_temp, MAX_READ_SIZE, glb_Cdrfp) == NULL )
        return FAILURE;
    strncpy(raw_gsm, raw_temp, sizeof(raw_gsm)-1);

    glb_ReadCtr++;

    strncpy(gsm_buf.record_type, raw_gsm, 2);

    /* check if header record read */
    if ( !strcmp(gsm_buf.record_type, "10") ) {
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, gsm_buf.record_type);
        /*fwrite(&raw_gsm, SIZE_GSMRAW, 1, glb_RCdrfp);*/ /* reject the GSM Header */
        fputs(raw_gsm, glb_RCdrfp); /* reject the GSM Header */

        /* Read a Record Again */
        if ( Read_Gsm_Cdr())
            return FAILURE; /* end of file */
    }

    /* check if trailer record read */
    if ( !strcmp(gsm_buf.record_type, "90") ) { /* Trailer Record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, gsm_buf.record_type);
        /*fwrite(&raw_gsm, SIZE_GSMRAW, 1, glb_RCdrfp);*/ /* reject the GSM Trailer */
        fputs(raw_gsm, glb_RCdrfp); /* reject the GSM Trailer */

        /* Read a Record Again */
        if ( Read_Gsm_Cdr())
            return FAILURE; /* end of file */
    }

    /* check if record type = 54 -> reject MT from AWN MSC cdr since they are already from OCSVPN */
    if ( !strcmp(gsm_buf.record_type, "54") ) {
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_MtxType, gsm_buf.record_type);
        /*fwrite(&raw_gsm, SIZE_GSMRAW, 1, glb_RCdrfp);*/ /* reject the AWN Trailer */
        fputs(raw_gsm, glb_RCdrfp); /* reject the AWN Trailer */

        /* Read a Record Again */
        if ( Read_Gsm_Cdr())
            return FAILURE;   /* end of file */
    }

    // if ( strlen(raw_gsm) < SIZE_GSMRAW ) {
        // nSizeShift = 0;
    // }

    /* Changed to New CDR Format - by Kawee on 20-Mar-2003 */
    strncpy(gsm_buf.imsi_no, raw_gsm+2, 15);
    strncpy(gsm_buf.b_no, raw_gsm+17, 32);
    strncpy(gsm_buf.a_no, raw_gsm+49, 18);
    strncpy(gsm_buf.service_type, raw_gsm+67, 2);
    strncpy(gsm_buf.service_id, raw_gsm+69, 4);    /* "12" is Free of Charge */
    strncpy(gsm_buf.msc_id, raw_gsm+73, 15);
    strncpy(gsm_buf.cell_id_a, raw_gsm+88, 15);
    strncpy(gsm_buf.cell_id_b, raw_gsm+103, 15);
    gsm_buf.ms_class_mark = raw_gsm[118];
    strncpy(gsm_buf.start_date, raw_gsm+119, 8);   /* YYYYMMDD format */
    strncpy(gsm_buf.start_time, raw_gsm+127, 6);
    strncpy(gsm_buf.duration, raw_gsm+133, 6);
    strncpy(gsm_buf.data_vol, raw_gsm+139, 6);
    strncpy(gsm_buf.data_vol_ref, raw_gsm+145, 6);
    strncpy(gsm_buf.tariff_class, raw_gsm+151, 4);
    strncpy(gsm_buf.ms_roaming_num, raw_gsm+155, 17);
    gsm_buf.charging_indicator = raw_gsm[172];      /* '2' is Free of Charge */
    strncpy(gsm_buf.charging_origin, raw_gsm+173, 4);
    strncpy(gsm_buf.originate_a_no, raw_gsm+177, 12);
    strncpy(gsm_buf.supplementary_code, raw_gsm+189, 2);
    gsm_buf.imei_a_b_c = raw_gsm[191];
    strncpy(gsm_buf.imei, raw_gsm+192, 15);
    strncpy(gsm_buf.out_tgrp, raw_gsm+207, 10);
    strncpy(gsm_buf.in_tgrp, raw_gsm+217, 10);
    strncpy(gsm_buf.cause_termination, raw_gsm+227, 10);
    gsm_buf.dual_serv_type = raw_gsm[237];
    strncpy(gsm_buf.dual_serv_code, raw_gsm+238, 2);
    gsm_buf.channel_req = raw_gsm[240];
    gsm_buf.channel_used = raw_gsm[241];
    gsm_buf.transperancy_ind = raw_gsm[242];

    for (i = 0; i < 5; i++) {   /* Table occurs 5 times */
        pos = 243+(i * 3);
        gsm_buf.ss_event[i].action_code = raw_gsm[pos];
        strncpy(gsm_buf.ss_event[i].ss_code, raw_gsm+(pos+1), 2);
        Trim_Str(gsm_buf.ss_event[i].ss_code);
    }
    strncpy(gsm_buf.service_key, raw_gsm+258, 6);  /* Added by Kawee on 07-Apr-2005 */
    strncpy(gsm_buf.fci, raw_gsm+264, 8);          /* Added by Kawee on 07-Apr-2005 */
    if ( strlen(raw_gsm) > SIZE_GSMRAWOLD ) {
        strncpy(gsm_buf.cell4G, raw_gsm+272, 19);
    }

    /* Trim Trailing Spaces on String Fields */
    Trim_Str(gsm_buf.imsi_no);
    Trim_Str(gsm_buf.b_no);
    Trim_Str(gsm_buf.a_no);
    Trim_Str(gsm_buf.service_type);
    Trim_Str(gsm_buf.service_id);
    Trim_Str(gsm_buf.msc_id);
    Trim_Str(gsm_buf.cell_id_a);
    Trim_Str(gsm_buf.cell_id_b);
    Trim_Str(gsm_buf.start_date);
    Trim_Str(gsm_buf.start_time);
    Trim_Str(gsm_buf.duration);
    Trim_Str(gsm_buf.data_vol);
    Trim_Str(gsm_buf.data_vol_ref);
    Trim_Str(gsm_buf.tariff_class);
    Trim_Str(gsm_buf.ms_roaming_num);
    Trim_Str(gsm_buf.charging_origin);
    Trim_Str(gsm_buf.originate_a_no);
    Trim_Str(gsm_buf.supplementary_code);
    Trim_Str(gsm_buf.imei);
    Trim_Str(gsm_buf.out_tgrp);
    Trim_Str(gsm_buf.in_tgrp);
    Trim_Str(gsm_buf.cause_termination);
    Trim_Str(gsm_buf.dual_serv_code);
    Trim_Str(gsm_buf.service_key);     /* Added by Kawee on 07-Apr-2005 */
    Trim_Str(gsm_buf.fci);             /* Added by Kawee on 07-Apr-2005 */
    if ( strlen(raw_gsm) > SIZE_GSMRAWOLD ) {
        Trim_Str(gsm_buf.cell4G);      /* Addeb by Thanakorn on 08-Jan-2016 */
    }
    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno)); /* Added by Thanakorn on 09-Sep-2012, FMS V11 */
    strcpy(glb_OriginalBno, gsm_buf.b_no);
    strcpy(glb_CurCDRDate,  gsm_buf.start_date);
    strcpy(glb_CurCDRTime,  gsm_buf.start_time);

    /* Construct Error Index */
    sprintf(glb_Eindex, "%s-%s-%s-%s-%s", gsm_buf.record_type, gsm_buf.a_no, gsm_buf.start_date, gsm_buf.start_time, glb_MtxType);

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

/* Split SMS Type from GSM Type - by Kawee on 07-Apr-2005 */
/*
** Name     : Read_Sms_Cdr()
**
** Description  : Reads One CDR from SMS Raw CDR file into raw buffer.
**        If Header Record is read, reads One CDR again.
**        If Trailer Record is read, reads One CDR again.
**        Parses and copies data of all fields from raw buffer to GSM global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Sms_Cdr()
{
    int i = 0, pos = 0;

    memset(&sms_buf, 0x00, sizeof (sms_buf));
    memset(raw_sms, 0x00, sizeof (raw_sms));
    memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
    memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
    memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));

    if ( fread((char *)raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_Cdrfp) != 1)
        return FAILURE;

    glb_ReadCtr++;

    strncpy(sms_buf.record_type, raw_sms, 2);

    /* check if header record read */
    if ( !strcmp(sms_buf.record_type, "10") ) {
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, sms_buf.record_type);
        fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp); /* reject the SMS Header */

        /* Read a Record Again */
        if ( Read_Sms_Cdr())
            return FAILURE; /* end of file */
    }

    /* check if trailer record read */
    if ( !strcmp(sms_buf.record_type, "90") ) { /* Trailer Record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, sms_buf.record_type);
        fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp); /* reject the SMS Trailer */

        /* Read a Record Again */
        if ( Read_Sms_Cdr())
            return FAILURE; /* end of file */
    }

    /* Changed to New CDR Format - by Kawee on 20-Mar-2003 */
    strncpy(sms_buf.imsi_no, raw_sms+2, 15);
    strncpy(sms_buf.b_no, raw_sms+17, 24);
    strncpy(sms_buf.a_no, raw_sms+41, 18);
    strncpy(sms_buf.service_type, raw_sms+59, 2);
    strncpy(sms_buf.service_id, raw_sms+61, 4);    /* "12" is Free of Charge */
    strncpy(sms_buf.msc_id, raw_sms+65, 15);
    strncpy(sms_buf.cell_id_a, raw_sms+80, 15);
    strncpy(sms_buf.cell_id_b, raw_sms+95, 15);
    sms_buf.ms_class_mark = raw_sms[110];
    strncpy(sms_buf.start_date, raw_sms+111, 8); /* YYYYMMDD format */
    strncpy(sms_buf.start_time, raw_sms+119, 6);
    strncpy(sms_buf.duration, raw_sms+125, 6);
    strncpy(sms_buf.data_vol, raw_sms+131, 6);
    strncpy(sms_buf.data_vol_ref, raw_sms+137, 6);
    strncpy(sms_buf.tariff_class, raw_sms+143, 4);
    strncpy(sms_buf.ms_roaming_num, raw_sms+147, 17);
    sms_buf.charging_indicator = raw_sms[164];  /* '2' is Free of Charge */
    strncpy(sms_buf.charging_origin, raw_sms+165, 4);
    strncpy(sms_buf.originate_a_no, raw_sms+169, 12);
    strncpy(sms_buf.supplementary_code, raw_sms+181, 2);
    sms_buf.imei_a_b_c = raw_sms[183];
    strncpy(sms_buf.imei, raw_sms+184, 15);
    strncpy(sms_buf.out_tgrp, raw_sms+199, 10);
    strncpy(sms_buf.in_tgrp, raw_sms+209, 10);
    strncpy(sms_buf.cause_termination, raw_sms+219, 10);
    sms_buf.dual_serv_type = raw_sms[229];
    strncpy(sms_buf.dual_serv_code, raw_sms+230, 2);
    sms_buf.channel_req = raw_sms[232];
    sms_buf.channel_used = raw_sms[233];
    sms_buf.transperancy_ind = raw_sms[234];

    for (i = 0; i < 5; i++) {   /* Table occurs 5 times */
        pos = 235+(i * 3);
        sms_buf.ss_event[i].action_code = raw_sms[pos];
        strncpy(sms_buf.ss_event[i].ss_code, raw_sms+(pos+1), 2);
        Trim_Str(sms_buf.ss_event[i].ss_code);
    }
    strncpy(sms_buf.call_ref, raw_sms+250, 12);        /* Added by Kawee on 07-Apr-2005 */
    strncpy(sms_buf.pps_desc, raw_sms+262, 2);         /* Added by Kawee on 07-Apr-2005 */
    strncpy(sms_buf.auth_result, raw_sms+264, 9);      /* Added by Kawee on 07-Apr-2005 */
    strncpy(sms_buf.operator_a, raw_sms+273, 15);      /* Added by Thanakorn on Jan-2010 */
    strncpy(sms_buf.operator_b, raw_sms+288, 15);      /* Added by Thanakorn on Jan-2010 */
    strncpy(sms_buf.md_msc_address, raw_sms+303, 20);  /* Added by Thanakorn on Sep-2011 */
    if ( glb_SmsNew ) {
        strncpy(sms_buf.servpackid, raw_sms+323, 3);   /* Added by Thanakorn on Aug-2013 */
    }

    /* Trim Trailing Spaces on String Fields */
    Trim_Str(sms_buf.imsi_no);
    Trim_Str(sms_buf.b_no);
    Trim_Str(sms_buf.a_no);
    Trim_Str(sms_buf.service_type);
    Trim_Str(sms_buf.service_id);
    Trim_Str(sms_buf.msc_id);
    Trim_Str(sms_buf.cell_id_a);
    Trim_Str(sms_buf.cell_id_b);
    Trim_Str(sms_buf.start_date);
    Trim_Str(sms_buf.start_time);
    Trim_Str(sms_buf.duration);
    Trim_Str(sms_buf.data_vol);
    Trim_Str(sms_buf.data_vol_ref);
    Trim_Str(sms_buf.tariff_class);
    Trim_Str(sms_buf.ms_roaming_num);
    Trim_Str(sms_buf.charging_origin);
    Trim_Str(sms_buf.originate_a_no);
    Trim_Str(sms_buf.supplementary_code);
    Trim_Str(sms_buf.imei);
    Trim_Str(sms_buf.out_tgrp);
    Trim_Str(sms_buf.in_tgrp);
    Trim_Str(sms_buf.cause_termination);
    Trim_Str(sms_buf.dual_serv_code);
    Trim_Str(sms_buf.call_ref);        /* Added by Kawee on 07-Apr-2005 */
    Trim_Str(sms_buf.pps_desc);        /* Added by Kawee on 16-Jun-2006 */
    Trim_Str(sms_buf.auth_result);     /* Added by Kawee on 07-Apr-2005 */
    Trim_Str(sms_buf.operator_a);      /* Added by Thanakorn on Jan-2009 */
    Trim_Str(sms_buf.operator_b);      /* Added by Thanakorn on Jan-2009 */
    Trim_Str(sms_buf.md_msc_address);  /* Added by Thanakorn on Sep-2011 */
    if ( glb_SmsNew ) {
        Trim_Str(sms_buf.servpackid);  /* Added by Thanakorn on Aug-2013 */
    }
    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno)); /* Added by Thanakorn on 09-Sep-2012, FMS V11 */
    strcpy(glb_OriginalBno, sms_buf.b_no);
    strcpy(glb_CurCDRDate,  sms_buf.start_date);
    strcpy(glb_CurCDRTime,  sms_buf.start_time);


    /* Construct Error Index */
    sprintf(glb_Eindex, "%s-%s-%s-%s-%s", sms_buf.record_type, sms_buf.a_no, sms_buf.start_date, sms_buf.start_time, glb_MtxType);

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

/*
**
** Name     : Read_Smc_Cdr()
**
** Description  : Reads One CDR from SMC Raw CDR file into raw buffer.
**        If Header Record is read, reads One CDR again.
**        If Trailer Record is read, reads One CDR again.
**        Parses and copies data of all fields from raw buffer to GSM global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Smc_Cdr()
{
    //int i = 0;
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_Smc_Cdr");
    _p_ = 0;
#endif
    memset(&smc_buf, 0x00, sizeof (smc_buf));
    memset(raw_smc, 0x00, sizeof (raw_smc));
    memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
    memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
    memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));

    if ( fread((char *)raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_Cdrfp) != 1)
        return FAILURE;

    glb_ReadCtr++;

    strncpy(smc_buf.record_type, raw_smc, 2);

    /* check if header record read */
    if ( !strcmp(smc_buf.record_type, "10") ) {
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, smc_buf.record_type);
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp); /* reject the SMS Header */

        /* Read a Record Again */
        if ( Read_Smc_Cdr())
            return FAILURE; /* end of file */
    }

    /* check if trailer record read */
    if ( !strcmp(smc_buf.record_type, "90") ) { /* Trailer Record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, smc_buf.record_type);
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp); /* reject the SMS Trailer */

        /* Read a Record Again */
        if ( Read_Smc_Cdr())
            return FAILURE; /* end of file */
    }

    strncpy(smc_buf.imsi_no, raw_smc+2, 15);
    strncpy(smc_buf.b_no, raw_smc+17, 24);
    strncpy(smc_buf.a_no, raw_smc+41, 18);
    strncpy(smc_buf.service_type, raw_smc+59, 2);
    strncpy(smc_buf.service_id, raw_smc+61, 4);    /* "12" is Free of Charge */
    strncpy(smc_buf.msc_id, raw_smc+65, 15);
    strncpy(smc_buf.cell_id_a, raw_smc+80, 15);
    strncpy(smc_buf.cell_id_b, raw_smc+95, 15);
    smc_buf.ms_class_mark = raw_smc[110];
    strncpy(smc_buf.start_date, raw_smc+111, 8); /* YYYYMMDD format */
    strncpy(smc_buf.start_time, raw_smc+119, 6);
    strncpy(smc_buf.duration, raw_smc+125, 6);
    strncpy(smc_buf.data_vol, raw_smc+131, 6);
    strncpy(smc_buf.data_vol_ref, raw_smc+137, 6);
    strncpy(smc_buf.tariff_class, raw_smc+143, 4);
    strncpy(smc_buf.ms_roaming_num, raw_smc+147, 17);
    smc_buf.charging_indicator = raw_smc[164];  /* '2' is Free of Charge */
    strncpy(smc_buf.charging_origin, raw_smc+165, 4);
    strncpy(smc_buf.originate_a_no, raw_smc+169, 12);
    strncpy(smc_buf.supplementary_code, raw_smc+181, 2);
    smc_buf.imei_a_b_c = raw_smc[183];
    strncpy(smc_buf.imei, raw_smc+184, 15);
    strncpy(smc_buf.out_tgrp, raw_smc+199, 10);
    strncpy(smc_buf.in_tgrp, raw_smc+209, 10);
    strncpy(smc_buf.cause_termination, raw_smc+219, 10);
    smc_buf.dual_serv_type = raw_smc[229];
    strncpy(smc_buf.dual_serv_code, raw_smc+230, 2);
    smc_buf.channel_req = raw_smc[232];
    smc_buf.channel_used = raw_smc[233];
    smc_buf.transperancy_ind = raw_smc[234];
    strncpy(smc_buf.orig_addr, raw_smc+235, 15);       /* Changed ss_event to orig_addr -  by Wiraphot on 07-Jan-2009 */
    strncpy(smc_buf.call_ref, raw_smc+250, 12);
    strncpy(smc_buf.pps_desc, raw_smc+262, 2);
    strncpy(smc_buf.auth_result, raw_smc+264, 9);
    strncpy(smc_buf.operator_a, raw_sms+273, 15);  /* Added by Thanakorn on Jan-2010 */
    strncpy(smc_buf.operator_b, raw_sms+288, 15);  /* Added by Thanakorn on Jan-2010 */
    if ( glb_SmcNew ) {
        strncpy(smc_buf.md_msc_address, raw_sms+303, 20);  /* Added by Thanakorn on Oct-2011 */
    }

    /* Trim Trailing Spaces on String Fields */
    Trim_Str(smc_buf.imsi_no);
    Trim_Str(smc_buf.b_no);
    Trim_Str(smc_buf.a_no);
    Trim_Str(smc_buf.service_type);
    Trim_Str(smc_buf.service_id);
    Trim_Str(smc_buf.msc_id);
    Trim_Str(smc_buf.cell_id_a);
    Trim_Str(smc_buf.cell_id_b);
    Trim_Str(smc_buf.start_date);
    Trim_Str(smc_buf.start_time);
    Trim_Str(smc_buf.duration);
    Trim_Str(smc_buf.data_vol);
    Trim_Str(smc_buf.data_vol_ref);
    Trim_Str(smc_buf.tariff_class);
    Trim_Str(smc_buf.ms_roaming_num);
    Trim_Str(smc_buf.charging_origin);
    Trim_Str(smc_buf.originate_a_no);
    Trim_Str(smc_buf.supplementary_code);
    Trim_Str(smc_buf.imei);
    Trim_Str(smc_buf.out_tgrp);
    Trim_Str(smc_buf.in_tgrp);
    Trim_Str(smc_buf.cause_termination);
    Trim_Str(smc_buf.dual_serv_code);
    Trim_Str(smc_buf.orig_addr);
    Trim_Str(smc_buf.call_ref);
    Trim_Str(smc_buf.pps_desc);
    Trim_Str(smc_buf.auth_result);
    Trim_Str(smc_buf.operator_a);      /* Added by Thanakorn on Jan-2010 */
    Trim_Str(smc_buf.operator_b);      /* Added by Thanakorn on Jan-2010 */
    if ( glb_SmcNew ) {
        Trim_Str(smc_buf.md_msc_address);  /* Added by Thanakorn on Oct-2011 */
    }
    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno)); /* Added by Thanakorn on 09-Sep-2012, FMS V11 */
    strcpy(glb_OriginalBno, smc_buf.b_no);
    strcpy(glb_CurCDRDate,  smc_buf.start_date);
    strcpy(glb_CurCDRTime,  smc_buf.start_time);

    /* Construct Error Index */
    sprintf(glb_Eindex, "%s-%s-%s-%s-%s", smc_buf.record_type, smc_buf.a_no, smc_buf.start_date, smc_buf.start_time, glb_MtxType);

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

int Read_Ssp_Cdr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_Ssp_Cdr");
    _p_ = 0;
#endif
    int i = 0, pos = 0;
    // int nSizeShift = 8;     /* Bno size is extened 8 char more (inserted) */

    memset(&ssp_buf, 0x00, sizeof (ssp_buf));
    memset(raw_ssp, 0x00, sizeof (raw_ssp));
    memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
    memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
    memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));

    if ( fgets((char *)raw_temp, MAX_READ_SIZE, glb_Cdrfp) == NULL )
        return FAILURE;
    strncpy(raw_ssp, raw_temp, sizeof(raw_ssp)-1);

    glb_ReadCtr++;

    strncpy(ssp_buf.record_type, raw_ssp, 2);

    /* check if header record read */
    if ( !strcmp(ssp_buf.record_type, "10") ) {
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, ssp_buf.record_type);
        fputs(raw_ssp, glb_RCdrfp);     /* reject the SSP Header */

        if ( Read_Ssp_Cdr())    /* Read a Record Again */
            return FAILURE;     /* end of file */
    }

    /* check if trailer record read */
    if ( !strcmp(ssp_buf.record_type, "90") ) { /* Trailer Record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, ssp_buf.record_type);
        fputs(raw_ssp, glb_RCdrfp);     /* reject the SSP Trailer */

        if ( Read_Ssp_Cdr())    /* Read a Record Again */
            return FAILURE;   /* end of file */
    }

    // if ( strlen(raw_ssp) < SIZE_SSPRAW ) {
        // nSizeShift = 0;
    // }

    /* Changed to New CDR Format - by Kawee on 20-Mar-2003 */
    strncpy(ssp_buf.imsi_no, raw_ssp+2, 15);
    strncpy(ssp_buf.b_no, raw_ssp+17, 32);
    strncpy(ssp_buf.a_no, raw_ssp+49, 18);
    strncpy(ssp_buf.service_type, raw_ssp+67, 2);
    strncpy(ssp_buf.service_id, raw_ssp+69, 4);    /* "12" is Free of Charge */
    strncpy(ssp_buf.msc_id, raw_ssp+73, 15);
    strncpy(ssp_buf.cell_id_a, raw_ssp+88, 15);
    strncpy(ssp_buf.cell_id_b, raw_ssp+103, 15);
    ssp_buf.ms_class_mark = raw_ssp[118];
    strncpy(ssp_buf.start_date, raw_ssp+119, 8);   /* YYYYMMDD format */
    strncpy(ssp_buf.start_time, raw_ssp+127, 6);
    strncpy(ssp_buf.duration, raw_ssp+133, 6);
    strncpy(ssp_buf.data_vol, raw_ssp+139, 6);
    strncpy(ssp_buf.data_vol_ref, raw_ssp+145, 6);
    strncpy(ssp_buf.tariff_class, raw_ssp+151, 4);
    strncpy(ssp_buf.ms_roaming_num, raw_ssp+155, 17);
    ssp_buf.charging_indicator = raw_ssp[172];      /* '2' is Free of Charge */
    strncpy(ssp_buf.charging_origin, raw_ssp+173, 4);
    strncpy(ssp_buf.originate_a_no, raw_ssp+177, 12);
    strncpy(ssp_buf.supplementary_code, raw_ssp+189, 2);
    ssp_buf.imei_a_b_c = raw_ssp[191];
    strncpy(ssp_buf.imei, raw_ssp+192, 15);
    strncpy(ssp_buf.out_tgrp, raw_ssp+207, 10);
    strncpy(ssp_buf.in_tgrp, raw_ssp+217, 10);
    strncpy(ssp_buf.cause_termination, raw_ssp+227, 10);
    ssp_buf.dual_serv_type = raw_ssp[237];
    strncpy(ssp_buf.dual_serv_code, raw_ssp+238, 2);
    ssp_buf.channel_req = raw_ssp[240];
    ssp_buf.channel_used = raw_ssp[241];
    ssp_buf.transperancy_ind = raw_ssp[242];

    for (i = 0; i < 5; i++) {   /* Table occurs 5 times */
        pos = 243+(i * 3);
        ssp_buf.ss_event[i].action_code = raw_ssp[pos];
        strncpy(ssp_buf.ss_event[i].ss_code, raw_ssp+(pos+1), 2);
        Trim_Str(ssp_buf.ss_event[i].ss_code);
    }
    strncpy(ssp_buf.service_key, raw_ssp+258, 6);   /* Added by Kawee on 07-Apr-2005 */
    strncpy(ssp_buf.fci, raw_ssp+264, 8);           /* Added by Kawee on 07-Apr-2005 */
    if ( strlen(raw_ssp) < SIZE_SSPRAWOLD ) {
        strncpy(ssp_buf.cell4G, raw_ssp+272, 19);              /* Added by Thanakorn on 08-Jan-2016 */
    }

    /* Trim Trailing Spaces on String Fields */
    Trim_Str(ssp_buf.imsi_no);
    Trim_Str(ssp_buf.b_no);
    Trim_Str(ssp_buf.a_no);
    Trim_Str(ssp_buf.service_type);
    Trim_Str(ssp_buf.service_id);
    Trim_Str(ssp_buf.msc_id);
    Trim_Str(ssp_buf.cell_id_a);
    Trim_Str(ssp_buf.cell_id_b);
    Trim_Str(ssp_buf.start_date);
    Trim_Str(ssp_buf.start_time);
    Trim_Str(ssp_buf.duration);
    Trim_Str(ssp_buf.data_vol);
    Trim_Str(ssp_buf.data_vol_ref);
    Trim_Str(ssp_buf.tariff_class);
    Trim_Str(ssp_buf.ms_roaming_num);
    Trim_Str(ssp_buf.charging_origin);
    Trim_Str(ssp_buf.originate_a_no);
    Trim_Str(ssp_buf.supplementary_code);
    Trim_Str(ssp_buf.imei);
    Trim_Str(ssp_buf.out_tgrp);
    Trim_Str(ssp_buf.in_tgrp);
    Trim_Str(ssp_buf.cause_termination);
    Trim_Str(ssp_buf.dual_serv_code);
    Trim_Str(ssp_buf.service_key); /* Added by Kawee on 07-Apr-2005 */
    Trim_Str(ssp_buf.fci);         /* Added by Kawee on 07-Apr-2005 */
    if ( strlen(raw_ssp) < SIZE_SSPRAWOLD ) {
        Trim_Str(ssp_buf.cell4G);
    }
    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno)); /* Added by Thanakorn on 09-Sep-2012, FMS V11 */
    strcpy(glb_OriginalBno, ssp_buf.b_no);
    strcpy(glb_CurCDRDate,  ssp_buf.start_date);
    strcpy(glb_CurCDRTime,  ssp_buf.start_time);

    /* Construct Error Index */
    sprintf(glb_Eindex, "%s-%s-%s-%s-%s", ssp_buf.record_type, ssp_buf.a_no, ssp_buf.start_date, ssp_buf.start_time, glb_MtxType);

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

int Determine_Usc_Size()
{
    memset(raw_usc, 0x00, sizeof (raw_usc));
    glb_UscNew = 0;

    /* First determine the size of the Input USC Record */
    if ( fgets ((char *)raw_usc, SIZE_USCRAW, glb_Cdrfp) != NULL) {

        if ( strlen(raw_usc) == SIZE_USCRAWOLD) {
            glb_UscNew = OLD_FORMAT;
        }
        else {
            glb_UscNew = NEW_FORMAT;
        }
    }

    sprintf(glb_MsgText, "Size of USC = %d", glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD);
    Deb_Msg(glb_MsgText);

    fseek (glb_Cdrfp, 0, SEEK_SET);     /* re-wind the file pointer */
    return SUCCESS;
}

void determine_size(char *buff, int buf_size, const char *type, int *glbCurSize, int nNewSize, int nOldSize)
{
    int buff_read_size = 0;
    memset(buff, 0x00, buf_size);
    *glbCurSize = OLD_FORMAT;

    while ( fgets ((char*)buff, buf_size, glb_Cdrfp) != NULL) {
        buff_read_size = strlen(buff);
        if ( buff_read_size <= 3 ) {
            continue;
        }
        if ( buff_read_size < nNewSize ) {
            *glbCurSize = OLD_FORMAT;
        }
        else {
            *glbCurSize = NEW_FORMAT;
        }
        break;
    }

    sprintf(glb_MsgText, "Size of %s = %d[read %d]", type, (*glbCurSize ? nNewSize : nOldSize), buff_read_size);
    Deb_Msg(glb_MsgText);
    fseek (glb_Cdrfp, 0, SEEK_SET);     /* re-wind the file pointer */
}

void determine_num_field(char *buff, int buf_size, const char *type, int *glbCurSize, int nNewField, int nOldField)
{
    int pipe_cnt = 0;
    memset(buff, 0x00, buf_size);
    *glbCurSize = 0;

    while ( fgets ((char*)buff, buf_size, glb_Cdrfp) != NULL) {
        if ( strlen(buff) < 3 ) {
            continue;
        }
        while ( *buff != '\0' ) {
            if ( *buff == '|') {
                pipe_cnt++;
            }
            buff++;
        }
        pipe_cnt++;     /* last field */
        if ( pipe_cnt < nNewField ) {
            *glbCurSize = nOldField;
        }
        else {
            *glbCurSize = nNewField;
        }
        break;
    }

    sprintf(glb_MsgText, "NumField of %s = %d[read = %d]", type, *glbCurSize, pipe_cnt);
    Deb_Msg(glb_MsgText);
    fseek (glb_Cdrfp, 0, SEEK_SET);     /* re-wind the file pointer */
}

void Determine_Cdr_Size(int nMtxInd)
{
    /* This function read only the first line of input cdr file */
    /* if those input cdr files have header record, which does not reflect */
    /* its real record size or field number, this function is not suited for such case */
    switch ( nMtxInd )
    {
        case SMS_TYPE:
        case SMSFDA_TYPE:
            determine_size(raw_sms, sizeof(raw_sms), "SMS", &glb_SmsNew, SIZE_SMSRAW, SIZE_SMSRAWOLD);
            break;

        case SMC_TYPE:
            determine_size(raw_smc, sizeof(raw_smc), "SMC", &glb_SmcNew, SIZE_SMCRAW, SIZE_SMCRAWOLD);
            break;

        case GPRS_TYPE:
            determine_size(raw_gprs, sizeof(raw_gprs), "GPRS", &glb_GprsNew, SIZE_GPRSRAW, SIZE_GPRSRAWOLD);
            break;

        case USC_TYPE:
            Determine_Usc_Size();
            break;

        case GSMBC_TYPE:
        case PPSBC_TYPE:
            determine_num_field(raw_gprst, sizeof(raw_gprst), "BCUDR", &glb_BcNewField, NUMFLD_GPRST, NUMFLD_GPRSTOLD);
            break;

        case GSMTC_TYPE:
        case PPSTC_TYPE:
            determine_num_field(raw_mms, sizeof(raw_mms), "MMS", &glb_TcNewField, NUMFLD_MMS, NUMFLD_MMSOLD);
            break;

        case CCUDR_TYPE:
            determine_num_field(raw_input, sizeof(raw_input), "CCUDR", &glb_CcNewField, NOF_FLD_CCUDR, CCUDR_PKGID-3);
            break;

        case GSMCT_TYPE:
        case PPSCT_TYPE:
        case DCBCT_TYPE:
        case DCB_TYPE:
            determine_num_field(raw_input, sizeof(raw_input), "CDG", &glb_CtNewField, NOF_FLD_CDG, CDG_PKGID+1);
            break;
    }
}

/*
** Name     : Read_Usc_Cdr()
**
** Description  : Reads One CDR from USC Raw CDR file into raw buffer.
**        Parses and copies data of all fields from raw buffer to USC global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Usc_Cdr()
{
    memset(&usc_buf, 0x00, sizeof (usc_buf));
    memset(raw_usc, 0x00, sizeof (raw_usc));
    memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
    memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
    memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));


    if ( fread((char *)raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_Cdrfp) != 1)
        return FAILURE;

    glb_ReadCtr++;

    strncpy(usc_buf.record_type, raw_usc, 2);

    /* check if known record read */
    if ( strcmp(usc_buf.record_type, "20") && strcmp(usc_buf.record_type, "30") ) { /* not 20 and not 30 */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_MtxType, usc_buf.record_type);
        fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* reject the USC Header */
        glb_IgnCtr++;

        /* Read a Record Again */
        if ( Read_Usc_Cdr())
            return FAILURE; /* end of file */
    }

    /* Changed to New CDR Format - by Kawee on 20-Mar-2003 */
    strncpy(usc_buf.a_no, raw_usc+2, 18);
    strncpy(usc_buf.start_date, raw_usc+20, 8);
    strncpy(usc_buf.start_time, raw_usc+28, 6);
    strncpy(usc_buf.end_date, raw_usc+34, 8);
    strncpy(usc_buf.end_time, raw_usc+42, 6);
    strncpy(usc_buf.category_id, raw_usc+48, 3);
    strncpy(usc_buf.content_id, raw_usc+51, 3);
    usc_buf.bearer = raw_usc[54];
    strncpy(usc_buf.service_id, raw_usc+55, 6);
    strncpy(usc_buf.service_type, raw_usc+61, 2);
    strncpy(usc_buf.txn_id, raw_usc+63, 2);
    strncpy(usc_buf.completion, raw_usc+65, 2);
    usc_buf.charge_flag = raw_usc[67];
    strncpy(usc_buf.payment_type, raw_usc+68, 2);      /* payment_type = cos_a */
    strncpy(usc_buf.product_value, raw_usc+70, 8);
    strncpy(usc_buf.version, raw_usc+78, 4);
    strncpy(usc_buf.unit_charge, raw_usc+82, 2);
    /* strncpy(usc_buf.mtx_id, raw_usc+84, 10);            Removed on 31-Mar-2003 */
    strncpy(usc_buf.content_code, raw_usc+84, 20);
    strncpy(usc_buf.Info, raw_usc+104, 100);           /* added Info field - by Kawee on 20-Mar-2003 */
    strncpy(usc_buf.change_event_id, raw_usc+204, 10);
    strncpy(usc_buf.message_size, raw_usc+214, 8);     /* added message_size field - by Kawee on 24-Dec-2002 */
    if ( glb_UscNew) {
        strncpy(usc_buf.cos_b, raw_usc+222, 3);        /* Added by Thanakorn on 28-Dec-2009 */
    }

    /* Trim Trailing Spaces on String Fields */
    Trim_Str(usc_buf.a_no);
    Trim_Str(usc_buf.start_date);
    Trim_Str(usc_buf.start_time);
    Trim_Str(usc_buf.end_date);
    Trim_Str(usc_buf.end_time);
    Trim_Str(usc_buf.category_id);
    Trim_Str(usc_buf.content_id);
    Trim_Str(usc_buf.service_id);
    Trim_Str(usc_buf.service_type);
    Trim_Str(usc_buf.txn_id);
    Trim_Str(usc_buf.completion);
    Trim_Str(usc_buf.payment_type);
    Trim_Str(usc_buf.product_value);
    Trim_Str(usc_buf.version);
    Trim_Str(usc_buf.unit_charge);
    Trim_Str(usc_buf.content_code);
    Trim_Str(usc_buf.Info);
    Trim_Str(usc_buf.change_event_id);
    Trim_Str(usc_buf.message_size);    /* added message_size field - by Kawee on 24-Dec-2002 */
    if ( glb_UscNew) {
        Trim_Str(usc_buf.cos_b);       /* Added by Thanakorn on 28-Dec-2009 */
    }

    /* Construct Error Index */
    sprintf(glb_Eindex, "%s-%s-%s-%s-%s", usc_buf.record_type, usc_buf.a_no, usc_buf.start_date, usc_buf.start_time, glb_MtxType);
    strcpy(glb_CurCDRDate, usc_buf.start_date);
    strcpy(glb_CurCDRTime, usc_buf.start_time);

    return SUCCESS;
}

/*--------The Read_Gprs_Cdr() function is added by kawin on 20-Sep-2002 -------*/

/*
** Name     : Read_Gprs_Cdr()
**
** Description  : Reads One CDR from GPRS Raw CDR file into raw buffer.
**        If Header Record is read, reads One CDR again.
**        If Trailer Record is read, reads One CDR again.
**        Parses and copies data of all fields from raw buffer to GPRS global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/
int Read_Gprs_Cdr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_Gprs_Cdr");
    _p_ = 0;
#endif
    memset(pbuf_gprs, 0x00, sizeof (pbuf_gprs));
    return (Read_Delimiter_Cdr ('|', NOF_FLD_GPRS, pbuf_gprs));
}

/*--------The Read_Gprst_Cdr() function is added by Kawee on 20-May-2004 -------*/

/*
** Name     : Read_Gprst_Cdr()
**
** Description  : Reads One CDR from GPRST Raw CDR file into raw buffer.
**        If Header Record is read, reads One CDR again.
**        If Trailer Record is read, reads One CDR again.
**        Parses and copies data of all fields from raw buffer to GPRST global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Gprst_Cdr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_Gprst_Cdr");
    _p_ = 0;
#endif
    int idx;
    char temp_gprst[SIZE_GPRSTRAW+1];

    memset(temp_gprst, 0x00, sizeof (temp_gprst));
    memset(pbuf_gprst, 0x00, sizeof (pbuf_gprst));

    memset(&gprst_buf, 0x00, sizeof (gprst_buf));
    memset(raw_gprst, 0x00, sizeof (raw_gprst));
    memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
    memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
    memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));

    if ( fgets((char *)raw_gprst, sizeof (raw_gprst), glb_Cdrfp) == NULL )   /* we use fgets because record has some nulls */
        return FAILURE;

    glb_ReadCtr++;

    strcpy(temp_gprst, raw_gprst);
    if ( (pbuf_gprst[0] = Get_StrTok(temp_gprst, '|')) == NULL ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Mobile_NO| read record error nof field(0)\n", glb_MtxType);
        glb_ErrCtr++;

        /* Read a Record Again */
        if ( Read_Gprst_Cdr())
            return FAILURE; /* end of file */
        else
            return SUCCESS;
    }

    for (idx = 1; idx < glb_BcNewField; idx++) {
        if ( (pbuf_gprst[idx] = Get_StrTok((char *)NULL, '|')) == NULL ) {
            fprintf(glb_Errfp, "[DET] %s|Field|Mobile_NO| read record error nof_field(%d)\n", glb_MtxType, idx);
            glb_ErrCtr++;

            /* Read a Record Again */
            if ( Read_Gprst_Cdr() )
                return FAILURE; /* end of file */
            else
                return SUCCESS;
        }
    }

    strncpy(gprst_buf.record_type, pbuf_gprst[0], 10);
    strncpy(gprst_buf.cid, pbuf_gprst[1], 18);     /* Resize from 9 to 18 - by Kawee on 31-Aug-2007 */
    strncpy(gprst_buf.pkgref, pbuf_gprst[2], 9);
    strncpy(gprst_buf.msisdn, pbuf_gprst[3], 20);
    strncpy(gprst_buf.customer_id, pbuf_gprst[4], 15);
    strcpy(gprst_buf.cos, pbuf_gprst[5]);
    strncpy(gprst_buf.bearer_id, pbuf_gprst[6], 5);
    strncpy(gprst_buf.vol, pbuf_gprst[7], 10);
    strncpy(gprst_buf.vol_cost, pbuf_gprst[8], 10);
    strncpy(gprst_buf.sid, pbuf_gprst[9], 6);
    strncpy(gprst_buf.cat_id, pbuf_gprst[10], 4);
    strncpy(gprst_buf.cp_id, pbuf_gprst[11], 3);
    strncpy(gprst_buf.start_datetime, pbuf_gprst[12], 14);
    strncpy(gprst_buf.stop_datetime, pbuf_gprst[13], 14);
    strncpy(gprst_buf.cause, pbuf_gprst[14], 3);
    gprst_buf.ppf = *(pbuf_gprst[15]);
    strncpy(gprst_buf.sgw_id, pbuf_gprst[16], 3);
    strncpy(gprst_buf.rqr, pbuf_gprst[17], 30 + 128);
    strncpy(gprst_buf.imsi, pbuf_gprst[18], 20);
    strncpy(gprst_buf.cgrn_id, pbuf_gprst[19], 20);
    strncpy(gprst_buf.oper_id, pbuf_gprst[20], 20);
    gprst_buf.tbcf = *(pbuf_gprst[21]);
    gprst_buf.ti = *(pbuf_gprst[22]);       /* Added by Kawee on 01-Feb-2005 */
    strncpy(gprst_buf.calledparty_id, pbuf_gprst[23], 21);     /* Added by Kawee on 31-Aug-2007 */
    strncpy(gprst_buf.netprice, pbuf_gprst[24], 10);           /* Added by Kawee on 31-Aug-2007 */
    strncpy(gprst_buf.servpackid, pbuf_gprst[25], 3 );         /* Added by Wiraphot on 14-Jan-2009 */
    strncpy(gprst_buf.productno, pbuf_gprst[26], 10);          /* Added by Wiraphot on 14-Jan-2009 */
    strncpy(gprst_buf.pkgid, pbuf_gprst[27], 10);              /* Added by Wiraphot on 14-Jan-2009 */
    strncpy(gprst_buf.nid, pbuf_gprst[28], 14);                /* Added by Thanakorn on Jan-2010*/
    strncpy(gprst_buf.erf, pbuf_gprst[29], 50);
    strncpy(gprst_buf.cfaddress, pbuf_gprst[30], 15);
    strncpy(gprst_buf.spnamemo, pbuf_gprst[31], 15);
    strncpy(gprst_buf.brandidmo, pbuf_gprst[32], 15);
    strncpy(gprst_buf.spnamemt, pbuf_gprst[33], 15);
    strncpy(gprst_buf.rat, pbuf_gprst[34], 5);
    strncpy(gprst_buf.userlocinfo, pbuf_gprst[35], 20);
    strncpy(gprst_buf.initrat, pbuf_gprst[36], 3);
    if ( glb_BcNewField > NUMFLD_GPRSTOLD ) {                   /* Added by Thanakorn on 08-Sep-2011 */
        strncpy(gprst_buf.lCun, pbuf_gprst[37], 15);
        strncpy(gprst_buf.volChg, pbuf_gprst[38], 15);
        strncpy(gprst_buf.initSpeed, pbuf_gprst[39], 10);
        strncpy(gprst_buf.speed, pbuf_gprst[40], 10);
        strncpy(gprst_buf.speedType, pbuf_gprst[41], 5);
    }

    /* Trim Trailing Spaces on String Fields */
    Trim_Str(gprst_buf.record_type);
    Trim_Str(gprst_buf.cid);
    Trim_Str(gprst_buf.pkgref);
    Trim_Str(gprst_buf.msisdn);
    Trim_Str(gprst_buf.customer_id);
    Trim_Str(gprst_buf.cos);
    Trim_Str(gprst_buf.bearer_id);
    Trim_Str(gprst_buf.vol);
    Trim_Str(gprst_buf.vol_cost);
    Trim_Str(gprst_buf.sid);
    Trim_Str(gprst_buf.cat_id);
    Trim_Str(gprst_buf.cp_id);
    Trim_Str(gprst_buf.start_datetime);
    Trim_Str(gprst_buf.stop_datetime);
    Trim_Str(gprst_buf.cause);
    Trim_Str(gprst_buf.sgw_id);
    Trim_Str(gprst_buf.rqr);
    Trim_Str(gprst_buf.imsi);
    Trim_Str(gprst_buf.cgrn_id);
    Trim_Str(gprst_buf.oper_id);
    Trim_Str(gprst_buf.calledparty_id);            /* Added by Kawee on 31-Aug-2007 */
    Trim_Str(gprst_buf.netprice);                  /* Added by Kawee on 31-Aug-2007 */
    Trim_Str(gprst_buf.servpackid);                /* Added by Wiraphot on 14-Jan-2009 */
    Trim_Str(gprst_buf.productno);                 /* Added by Wiraphot on 14-Jan-2009 */
    Trim_Str(gprst_buf.pkgid);                     /* Added by Wiraphot on 14-Jan-2009 */
    Trim_Str(gprst_buf.nid);                       /* Added by Thanakorn on 06-Jan-2010 */
    Trim_Str(gprst_buf.erf);
    Trim_Str(gprst_buf.cfaddress);
    Trim_Str(gprst_buf.spnamemo);
    Trim_Str(gprst_buf.brandidmo);
    Trim_Str(gprst_buf.spnamemt);
    Trim_Str(gprst_buf.rat);
    Trim_Str(gprst_buf.userlocinfo);
    Trim_Str(gprst_buf.initrat);
    if ( glb_BcNewField > NUMFLD_GPRSTOLD ) {       /* Added by Thanakorn on 08-Sep-2011 */
        Trim_Str(gprst_buf.lCun);
        Trim_Str(gprst_buf.volChg);
        Trim_Str(gprst_buf.initSpeed);
        Trim_Str(gprst_buf.speed);
        Trim_Str(gprst_buf.speedType);
    }

    /* Construct Error Index */
    sprintf(glb_Eindex, "%s-%s-%s-%s", gprst_buf.record_type, gprst_buf.msisdn, gprst_buf.start_datetime, glb_MtxType);
    strncpy(glb_CurCDRDate, gprst_buf.start_datetime, SIZE_YYYYMMDD);
    strcpy(glb_CurCDRTime,  gprst_buf.start_datetime+SIZE_YYYYMMDD);

    return SUCCESS;
}

/*--------The Read_Mms() function is added by Kawee on 05-Nov-2004 -------*/

/*
** Name     : Read_Mms_Cdr()
**
** Description  : Reads One CDR from MMS Raw CDR file into raw buffer.
**        If Header Record is read, reads One CDR again.
**        If Trailer Record is read, reads One CDR again.
**        Parses and copies data of all fields from raw buffer to MMS global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Mms_Cdr()
{
    int idx;
    char temp_mms[SIZE_MMSRAW+1];

    memset(temp_mms, 0x00, sizeof (temp_mms));
    memset(pbuf_mms, 0x00, sizeof (pbuf_mms));

    memset(&mms_buf, 0x00, sizeof (mms_buf));
    memset(raw_mms, 0x00, sizeof (raw_mms));
    memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
    memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
    memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));

    if ( fgets((char *)raw_mms, sizeof (raw_mms), glb_Cdrfp) == NULL )   /* we use fgets because record has some nulls */
        return FAILURE;

    glb_ReadCtr++;

    strcpy(temp_mms, raw_mms);
    for (idx = 0; idx < glb_TcNewField; idx++) {
        if ( idx == 0)
            pbuf_mms[idx] = Get_StrTok(temp_mms, '|');
        else
            pbuf_mms[idx] = Get_StrTok((char *)NULL, '|');

        if ( pbuf_mms[idx] == NULL ) {
            fprintf(glb_Errfp, "[DET] %s|Field|Mobile_NO| read record error nof_field(%d)\n", glb_MtxType, idx);
            glb_ErrCtr++;

            /* Read a Record Again */
            if ( Read_Mms_Cdr())
                return FAILURE; /* end of file */
            else
                return SUCCESS;
        }
    }

    strncpy(mms_buf.record_type, pbuf_mms[0], 10);
    strncpy(mms_buf.tsid, pbuf_mms[1], 18);                /* Resize form 9 to 18 - by Kawee on 31-Aug-2007 */
    strncpy(mms_buf.nid, pbuf_mms[2], 3);
    strncpy(mms_buf.nrf, pbuf_mms[3], 30);
    strncpy(mms_buf.subject, pbuf_mms[4], 21);
    strncpy(mms_buf.customer_id, pbuf_mms[5], 10);
    strncpy(mms_buf.object, pbuf_mms[6], 21);
    mms_buf.leg = *(pbuf_mms[7]);
    strcpy  (mms_buf.scos, pbuf_mms[8]);
    strncpy(mms_buf.oton, pbuf_mms[9], 20);
    strncpy(mms_buf.fee, pbuf_mms[10], 5);
    strncpy(mms_buf.sid, pbuf_mms[11], 6);
    strncpy(mms_buf.cat_id, pbuf_mms[12], 5);
    strncpy(mms_buf.cp_id, pbuf_mms[13], 3);
    strncpy(mms_buf.chg_id, pbuf_mms[14], 10);
    mms_buf.ppf = *(pbuf_mms[15]);
    strncpy(mms_buf.start_datetime, pbuf_mms[16], 14);
    strncpy(mms_buf.stop_datetime, pbuf_mms[17], 14);
    strncpy(mms_buf.cause, pbuf_mms[18], 3);
    strncpy(mms_buf.dr_fee, pbuf_mms[19], 5);
    strncpy(mms_buf.rr_fee, pbuf_mms[20], 5);
    strncpy(mms_buf.size, pbuf_mms[21], 10);
    strncpy(mms_buf.mus, pbuf_mms[22], 10);
    strncpy(mms_buf.dr_cause, pbuf_mms[23], 3);
    strncpy(mms_buf.dr_stop, pbuf_mms[24], 14);
    strncpy(mms_buf.rr_cause, pbuf_mms[25], 3);
    strncpy(mms_buf.rr_stop, pbuf_mms[26], 14);
    strncpy(mms_buf.tele_id, pbuf_mms[27], 5);
    strncpy(mms_buf.imsi, pbuf_mms[28], 20);
    strncpy(mms_buf.cgrn_id, pbuf_mms[29], 20);
    strncpy(mms_buf.cdrn_id, pbuf_mms[30], 20);
    strncpy(mms_buf.oper_id, pbuf_mms[31], 20);
    if ( glb_TcNewField > NUMFLD_MMSOLD ) {         /* for new field; the field 32nd, 33rd is switched each other */
        strncpy(mms_buf.pkgref, pbuf_mms[32], 15); /* Added by Kawee on 01-Feb-2005 */
        mms_buf.ob = *(pbuf_mms[33]);
    }
    else {
        mms_buf.ob = *(pbuf_mms[32]);
        strncpy(mms_buf.pkgref, pbuf_mms[33], 15); /* Added by Kawee on 01-Feb-2005 */
    }
    mms_buf.ti = *(pbuf_mms[34]);           /* Added by Kawee on 01-Feb-2005 */
#ifdef ADDMORE_VSCPFIELD    /* Move Back for Investigate Data. This will release on V.10 - by Kawee on 31-Aug-2007 */
    strncpy(mms_buf.netprice, pbuf_mms[35], 10);   /* Added by Kawee on 31-Aug-2007 */
#endif
    if ( glb_TcNewField > NUMFLD_MMSOLD ) {        /* Added by Thanakorn on Jan-2010 */
        strncpy(mms_buf.servpackid, pbuf_mms[36], 3);
        strncpy(mms_buf.productno, pbuf_mms[37], 4);
        strncpy(mms_buf.pkgid, pbuf_mms[38], 5);
        strncpy(mms_buf.erf, pbuf_mms[39], 50);
        strncpy(mms_buf.cfaddress, pbuf_mms[40], 15);
        strncpy(mms_buf.spnamemo, pbuf_mms[41], 15);
        strncpy(mms_buf.brandidmo, pbuf_mms[42], 15);
        strncpy(mms_buf.spnamemt, pbuf_mms[43], 50);
    }
    /* Trim Trailing Spaces on String Fields */
    Trim_Str(mms_buf.record_type);
    Trim_Str(mms_buf.tsid);
    Trim_Str(mms_buf.nid);
    Trim_Str(mms_buf.nrf);
    Trim_Str(mms_buf.subject);
    Trim_Str(mms_buf.customer_id);
    Trim_Str(mms_buf.object);
    Trim_Str(mms_buf.scos);
    Trim_Str(mms_buf.oton);
    Trim_Str(mms_buf.fee);
    Trim_Str(mms_buf.sid);
    Trim_Str(mms_buf.cat_id);
    Trim_Str(mms_buf.cp_id);
    Trim_Str(mms_buf.chg_id);
    Trim_Str(mms_buf.start_datetime);
    Trim_Str(mms_buf.stop_datetime);
    Trim_Str(mms_buf.cause);
    Trim_Str(mms_buf.dr_fee);
    Trim_Str(mms_buf.rr_fee);
    Trim_Str(mms_buf.size);
    Trim_Str(mms_buf.mus);
    Trim_Str(mms_buf.dr_cause);
    Trim_Str(mms_buf.dr_stop);
    Trim_Str(mms_buf.rr_cause);
    Trim_Str(mms_buf.rr_stop);
    Trim_Str(mms_buf.tele_id);
    Trim_Str(mms_buf.imsi);
    Trim_Str(mms_buf.cgrn_id);
    Trim_Str(mms_buf.cdrn_id);
    Trim_Str(mms_buf.oper_id);
    Trim_Str(mms_buf.pkgref);          /* Added by Kawee on 01-Feb-2005 */
#ifdef ADDMORE_VSCPFIELD    /* Move Back for Investigate Data. This will release on V.10 - by Kawee on 31-Aug-2007 */
    Trim_Str(mms_buf.netprice);            /* Added by Kawee on 31-Aug-2007 */
#endif
    if ( glb_TcNewField > NUMFLD_MMSOLD ) {        /* Added by Thanakorn on Jan-2010 */
        Trim_Str(mms_buf.servpackid);
        Trim_Str(mms_buf.productno);
        Trim_Str(mms_buf.pkgid);
        Trim_Str(mms_buf.erf);
        Trim_Str(mms_buf.cfaddress);
        Trim_Str(mms_buf.spnamemo);
        Trim_Str(mms_buf.brandidmo);
        Trim_Str(mms_buf.spnamemt);
    }

    /* Construct Error Index */
    sprintf(glb_Eindex, "%s-%s-%s-%s", mms_buf.record_type, mms_buf.subject, mms_buf.start_datetime, glb_MtxType);
    strncpy(glb_CurCDRDate, mms_buf.start_datetime, SIZE_YYYYMMDD);
    strcpy(glb_CurCDRTime,  mms_buf.start_datetime+SIZE_YYYYMMDD);


    return SUCCESS;
}

/*-------- The Read_Delimiter_Cdr() function is added by Kawee on 02-Jun-2005 -------*/

/*
** Name     : Read_Delimiter_Cdr()
**
** Description  : Reads One CDR from Raw CDR file that each field separated by delimiter into raw buffer.
**        If Number of input record less than value specficed by 'iNofField' parameter, then reads One CDR again.
**        Parses for separate each field with null character and set location of fields to array.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : char cDelimiter - INPUT - Delimiter Character.
**        int iNofField - INPUT - Number of Input Field.
**        char **ppchField - OUTPUT - Pointer to separated fields.
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/
int Read_Delimiter_Cdr (char cDelimiter, int iNofField, char **ppchField)
{
/* writeLog(LOG_SYS, "xxx# (GSMTOP_TYPE) begin Read_Delimiter_Cdr, glb_UseRatedCdr %d", glb_UseRatedCdr); */
    int idx;
    char cCanContinue;

    cCanContinue = TRUE;
    while ( cCanContinue ) {

        memset(raw_input, 0x00, sizeof (raw_input));
        memset(szGlbInputBuf, 0x00, sizeof (szGlbInputBuf));
        memset(ppchField, 0x00, sizeof (char *) * iNofField);
        memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
        memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
        memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));

        if ( fgets((char *)raw_input, sizeof(raw_input), glb_Cdrfp) == NULL ) {    /* we use fgets because record has some nulls */
            return FAILURE;
        }
/* writeLog(LOG_SYS, "xxx# (GSMTOP_TYPE) after fgets in Read_Delimiter_Cdr, glb_UseRatedCdr %d", glb_UseRatedCdr); */

        glb_ReadCtr++;
        strcpy(szGlbInputBuf, raw_input);
/* writeLog(LOG_SYS, "xxx# (GSMTOP_TYPE) before loop in Get_StrTok, glb_UseRatedCdr %d", glb_UseRatedCdr); */
        for ( idx = 0; idx < iNofField; idx++ ) {
            if ( idx == 0 ) {
                ppchField[idx] = Get_StrTok(szGlbInputBuf, cDelimiter);
            }
            else {
                ppchField[idx] = Get_StrTok((char *)NULL, cDelimiter);
            }

            if ( ppchField[idx] == NULL ) {
                /* Only AIN Type Header and Tailer have only 2 Fields */
                if ( glb_MtxInd == AIN_TYPE && idx > AIN_TAG ) {    /* AIN CDR */
                    if ( !strcmp(ppchField[AIN_TAG], "01") ) {      /* Header Record */
                        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n",
                                glb_MtxType, ppchField[AIN_TAG]);
                        fputs(raw_input, glb_RCdrfp);       /* reject the record */
                        //glb_IgnCtr++;
                        break;                              /* Stop Token String */
                    }
                    else if ( !strcmp(ppchField[AIN_TAG], "09") ) { /* Trailer Record */
                        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n",
                                glb_MtxType, ppchField[AIN_TAG]);
                        fputs(raw_input, glb_RCdrfp);      /* reject the record */
                        //glb_IgnCtr++;
                        break;                              /* Stop Token String */
                    }
                }
                /* Only NRTRDE Type Header and Tailer have only 2-3 Fields */ /* Added by Kawee on 30-Jan-2008 */
                else if ( (glb_MtxInd == NRTRDE_TYPE || glb_MtxInd == NRGGSN_TYPE) && idx > CMNIR_REC_TYPE ) {
                    /* NRTRDE/NRGGSN CDR */
                    if ( !strcmp(ppchField[CMNIR_REC_TYPE], "01") ) {  /* Header Record */
                        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n",
                                glb_MtxType, ppchField[CMNIR_REC_TYPE]);
                        fputs(raw_input, glb_RCdrfp);       /* reject the record */
                        //glb_IgnCtr++;
                        break;                              /* Stop Token String */
                    }
                    else if ( !strcmp(ppchField[CMNIR_REC_TYPE], "09") ) {     /* Trailer Record */
                        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n",
                                glb_MtxType, ppchField[CMNIR_REC_TYPE]);
                        fputs(raw_input, glb_RCdrfp);       /* reject the record */
                        //glb_IgnCtr++;
                        break;                              /* Stop Token String */
                    }
                    if ( idx == 30 || idx == NOF_FLD_CMNIR || idx == NOF_FLD_NRTSCP ) {
                        break;
                    }
                }
                /* Only AMF Type Header and Trailer have only 1 Fields */
                else if ( glb_MtxInd == AMF_TYPE && idx > AMF_APP_ID ) {
                    if ( strcasecmp(ppchField[AMF_APP_ID], "AMF") != 0 ) {
                        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n",
                                glb_MtxType, ppchField[AMF_APP_ID]);
                        fputs(raw_input, glb_RCdrfp);       /* reject the record */
                        //glb_IgnCtr++;
                        break;                              /* Stop Token String */
                    }
                }
                else if ( glb_MtxInd == GPRS_TYPE && idx > GPR_REC_TYPE ) {
                    if ( !strcmp(ppchField[GPR_REC_TYPE], "10") ) {     /* Header Record */
                        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, ppchField[GPR_REC_TYPE]);
                        fputs(raw_input, glb_RCdrfp);       /* reject the record */
                        break;                              /* Stop Token String */
                    }
                    else if ( !strcmp(ppchField[GPR_REC_TYPE], "90") ) {    /* Trailer Record */
                        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, ppchField[GPR_REC_TYPE]);
                        fputs(raw_input, glb_RCdrfp);       /* reject the record */
                        break;
                    }
                }
                else if ( glb_MtxInd == SDG_TYPE && idx == NOF_FLD_SDG ) {  /* SGD's new field (service_package_id) will be added later, so it has to check if it exist or not */
                    /* this indicates that the new field has not been adding and to prevent error printing Nof Field mismatch */
                    break;
                }   /* this block of if can be REMOVED later if the new field has already added */
                else if ( glb_MtxInd == NOF_FLD_RBM && idx >= RBM_CHG_NO  ) {
                    break;
                }

                fprintf(glb_Errfp, "[DET] %s|Field|Mobile_NO| read record error nof_field(%d)\n", glb_MtxType, idx);
                glb_ErrCtr++;
                break;  /* Stop Token String */
            }
            Trim_Str(ppchField[idx]);
        }
/* writeLog(LOG_SYS, "xxx# (GSMTOP_TYPE) after loop in Get_StrTok, glb_UseRatedCdr %d", glb_UseRatedCdr); */
        if ( idx < iNofField ) {
            if ( glb_MtxInd == NRTRDE_TYPE && idx >= 30 ) {
                cCanContinue = FALSE;
                break;
            }
            continue;   /* Read Record Again */
        }
        cCanContinue = FALSE;
        break;
    }

/* writeLog(LOG_SYS, "xxx# (GSMTOP_TYPE) before construct error index, glb_UseRatedCdr %d", glb_UseRatedCdr); */
    /* Construct Error Index */
    if ( glb_MtxInd == GSMCT_TYPE || glb_MtxInd == PPSCT_TYPE || glb_MtxInd == DCB_TYPE || glb_MtxInd == DCBCT_TYPE ) { /* CDG CDR */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[CDG_REC_TYPE], ppchField[CDG_MSISDN], ppchField[CDG_START], glb_MtxType);
    }
    else if ( glb_MtxInd == RBT_TYPE ) {    /* RBT CDR */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[RBT_EVT], ppchField[RBT_MSISDN], ppchField[RBT_TRT], glb_MtxType);
    }
    else if ( glb_MtxInd == AIN_TYPE ) {    /* AIN CDR */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[AIN_TAG], ppchField[AIN_ESRC], ppchField[AIN_EDTM], glb_MtxType);
    }
    else if ( glb_MtxInd == CCUDR_TYPE ) {  /* CCUDR CDR - Added by Jetsada on 27-August-2007 */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[CCUDR_REC_TYPE], ppchField[CCUDR_MSISDN], ppchField[CCUDR_START], glb_MtxType);
    }
    else if ( glb_MtxInd == NRTRDE_TYPE ) { /* NRTRDE CDR - Added by Kawee on 30-Jan-2008 */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[CMNIR_REC_TYPE], ppchField[CMNIR_MOBILE_NUM], ppchField[CMNIR_START_DT], glb_MtxType);
    }
    else if ( glb_MtxInd == AMF_TYPE ) {    /* AMF CDR - Added by Thanakorn on 04-Aug-2011 */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[AMF_REF_NO], ppchField[AMF_MSISDN], ppchField[AMF_TIMESTAMP], glb_MtxType);
    }
    else if ( glb_MtxInd == SDG_TYPE) {      /* SDG CDR - Added by Thanakorn on 01-Mar-2012 */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[SDG_REC_TYPE], ppchField[SDG_ANO], ppchField[SDG_TIMESTAMP], glb_MtxType);
    }
    else if ( glb_MtxInd == NRTSCP_TYPE ) { /* NRTRDE SCP CDR - Added by Thanakorn on 24-Sep-2012 */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[NRTSCP_CALL_TYPE], ppchField[NRTSCP_CALLING_PARTY_NO], ppchField[NRTSCP_CALL_BEGIN_TIME], glb_MtxType);
    }
    else if ( glb_MtxInd == GPRS_TYPE || glb_MtxInd == DPCGPR_TYPE || glb_MtxInd == AWNGPR_TYPE ) { /* GPRS CDR - Added by Thanakorn on 01-Mar-2013 */
        sprintf(glb_Eindex, "%s-%s-%s-%s-%s", ppchField[GPR_REC_TYPE], ppchField[GPR_SRV_MSISDN], ppchField[GPR_REC_OPEN_DATE], ppchField[GPR_REC_OPEN_TIME], glb_MtxType);
    }
    else if ( glb_MtxInd == OCSVPN_TYPE ) { /* GSM Maritime MT CDR - Added by N.Thanakorn on 18-Nov-2014 */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[OCS_CALL_REF], ppchField[OCS_CALLED_NO], ppchField[OCS_START_DT], glb_MtxType);
        strcpy(raw_gsm, raw_input);
    }
    else if ( glb_MtxInd == GSMTOP_TYPE ) { /* GSM Topup, added by N.Thanakorn on 5-Feb-2015 */
/* writeLog(LOG_SYS, "xxx# (GSMTOP_TYPE) before sprintf, strcpy in Read_Delimiter_Cdr, glb_UseRatedCdr %d", glb_UseRatedCdr); */
/* writeLog(LOG_SYS, "xxx# (GSMTOP_TYPE) sprintf result (%s-%s-%s-%s)", ppchField[GTU_EVT_SRC], ppchField[GTU_EVT_ATTR18], ppchField[GTU_EVT_DTM], glb_MtxType); */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[GTU_EVT_SRC], ppchField[GTU_EVT_ATTR18], ppchField[GTU_EVT_DTM], glb_MtxType);
/* writeLog(LOG_SYS, "xxx# (GSMTOP_TYPE) before strcpy in Read_Delimiter_Cdr, glb_UseRatedCdr %d", glb_UseRatedCdr); */
        strcpy(raw_gsm, raw_input);
/* writeLog(LOG_SYS, "xxx# (GSMTOP_TYPE) after strcpy in Read_Delimiter_Cdr, glb_UseRatedCdr %d", glb_UseRatedCdr); */
    }
    else if ( glb_MtxInd == IMS_TYPE ) {    /* IMS, added by N.Thanakorn on 28-Sep-2015 */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[IMS_REC_TYPE], ppchField[IMS_ANO], ppchField[IMS_START_DT], glb_MtxType);
        strcpy(raw_gsm, raw_input);
    }
    else if ( glb_MtxInd == RDC_TYPE ) {        /* RDC, added by N.Thanakorn on 22-Jan-2016 */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[RDC_VISITED_NW], ppchField[RDC_MOBILE_NO], ppchField[RDC_CALL_ST_TIME], glb_MtxType);
        strcpy(raw_gsm, raw_input);
    }
    else if ( glb_MtxInd == RDCSMS_TYPE ) {    /* RDC, added by N.Thanakorn on 22-Jan-2016 */
        sprintf(glb_Eindex, "%s-%s-%s-%s", ppchField[RDSMS_VISITED_NW], ppchField[RDSMS_MOBILE_NO], ppchField[RDSMS_CALL_ST_TIME], glb_MtxType);
        strcpy(raw_gsm, raw_input);
    }
    else if ( glb_MtxInd == RBM_TYPE ) {
        sprintf(glb_Eindex, "%s-%s-%s", ppchField[RBM_EVT_SRC], ppchField[RBM_EVT_DTM], glb_MtxType);
        strcpy(raw_gsm, raw_input);
    }


#ifdef PRINT_DELIMITER_CDR
    for ( idx = 0; idx < iNofField; idx++ ) {
        printf("%s|", ppchField[idx]);
    }
    printf ("\n");
#endif
    return SUCCESS;
}

/*--------The Read_Cdg_Cdr() function is added by Kawee on 02-Jun-2005 -------*/

/*
** Name     : Read_Cdg_Cdr()
**
** Description  : Reads One CDR from CDG Raw CDR file into raw buffer.
**        Parses and copies data of all fields from raw buffer to CDG global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Cdg_Cdr()
{
    memset(pbuf_cdg, 0x00, sizeof (pbuf_cdg));
    return (Read_Delimiter_Cdr ('|', glb_CtNewField, pbuf_cdg));
}

/*--------The Read_Rbt_Cdr() function is added by Jetsada on 13-Jul-2005 -------*/

/*
** Name     : Read_Rbt_Cdr()
**
** Description  : Reads One CDR from RBT Raw CDR file into raw buffer.
**        Parses and copies data of all fields from raw buffer to RBT global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Rbt_Cdr()
{
    memset(pbuf_rbt, 0x00, sizeof (pbuf_rbt));
    return (Read_Delimiter_Cdr ('|', NOF_FLD_RBT, pbuf_rbt));
}

/*--------The Read_Ain_Cdr() function is added by Kawee on 29-Jan-2007 -------*/

/*
** Name     : Read_Ain_Cdr()
**
** Description  : Reads One CDR from AIN Raw CDR file into raw buffer.
**        Parses and copies data of all fields from raw buffer to AIN global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Ain_Cdr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_Ain_Cdr");
    _p_ = 0;
#endif
    memset(pbuf_ain, 0x00, sizeof (pbuf_ain));
    return (Read_Delimiter_Cdr ('|', NOF_FLD_AIN, pbuf_ain));
}

/*
** Name     : Read_Ccudr_Cdr()
**
** Description  : Reads One CDR from CCUDR Raw CDR file into raw buffer.
**        Parses and copies data of all fields from raw buffer to CCUDR global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Ccudr_Cdr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_Ccudr_Cdr");
    _p_ = 0;
#endif
    memset(pbuf_ccudr, 0x00, sizeof (pbuf_ccudr));
    return (Read_Delimiter_Cdr ('|', glb_CcNewField, pbuf_ccudr));
}

/*--------The Read_Nrtrde_Cdr() function is added by Kawee on 02-May-2007 -------*/

/*
** Name     : Read_Nrtrde_Cdr()
**
** Description  : Reads One CDR from NRTRDE Raw CDR file into raw buffer.
**        Parses and copies data of all fields from raw buffer to NRTRDE global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Nrtrde_Cdr()
{
    memset(pbuf_nrtrde, 0x00, sizeof (pbuf_nrtrde));
    return (Read_Delimiter_Cdr ('|', NOF_FLD_CMNIR, pbuf_nrtrde));
}

/*
*   Added by Thanakorn on 24-Sep-2012 to Support FMS V11
*/
int Read_IrScp_Cdr()
{
    memset(pbuf_nrtscp, 0x00, sizeof (pbuf_nrtscp));
    return (Read_Delimiter_Cdr ('|', NOF_FLD_NRTSCP, pbuf_nrtscp));
}

/*------------------------------------------------------------------------------------*/
/*--------The Read_MscPps_Cdr() function is added by Kawee on 16-Dec-2002 -------*/

/*
** Name     : Read_MscPps_Cdr()
**
** Description  : Reads One CDR from MSCPPS Raw CDR file into raw buffer.
**        If Header Record is read, reads One CDR again.
**        If Trailer Record is read, reads One CDR again.
**        Parses and copies data of all fields from raw buffer to MSCPPS global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_MscPps_Cdr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_MscPps_Cdr");
    _p_ = 0;
#endif
    int i = 0, pos = 0;
    int nSizeShift = 8;     /* Bno size is extened 8 char more (inserted) */

    memset(&mscpps_buf, 0x00, sizeof (mscpps_buf));
    memset(raw_mscpps, 0x00, sizeof (raw_mscpps));
    memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
    memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
    memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));

    if ( fgets((char *)raw_temp, MAX_READ_SIZE, glb_Cdrfp) == NULL )
        return FAILURE;
    strncpy(raw_mscpps, raw_temp, sizeof(raw_mscpps)-1);

    glb_ReadCtr++;

    strncpy(mscpps_buf.record_type, raw_mscpps, 2);

    /* check if header record read */
    if ( !strcmp(mscpps_buf.record_type, "10") ) {
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, mscpps_buf.record_type);
        fputs(raw_mscpps, glb_RCdrfp);  /* reject the MSC PPS Header */

        if ( Read_MscPps_Cdr()) /* Read a Record Again */
            return FAILURE;   /* end of file */
    }

    /* check if trailer record read */
    if ( !strcmp(mscpps_buf.record_type, "90") ) { /* Trailer Record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, mscpps_buf.record_type);
        fputs(raw_mscpps, glb_RCdrfp);  /* reject the MSC PPS Trailer */

        if ( Read_MscPps_Cdr()) /* Read a Record Again */
            return FAILURE;   /* end of file */
    }

    if ( strlen(raw_mscpps) < SIZE_MSCPPSRAW ) {
        nSizeShift = 0;
    }

    /* Changed to New CDR Format - by Kawee on 20-Mar-2003 */
    strncpy(mscpps_buf.imsi_no, raw_mscpps+2, 15);
    strncpy(mscpps_buf.b_no, raw_mscpps+17, 24+nSizeShift);
    strncpy(mscpps_buf.a_no, raw_mscpps+41+nSizeShift, 18);
    strncpy(mscpps_buf.service_type, raw_mscpps+59+nSizeShift, 2);
    strncpy(mscpps_buf.service_id, raw_mscpps+61+nSizeShift, 4);  /* "12" is Free of Charge */
    strncpy(mscpps_buf.msc_id, raw_mscpps+65+nSizeShift, 15);
    strncpy(mscpps_buf.cell_id_a, raw_mscpps+80+nSizeShift, 15);
    strncpy(mscpps_buf.cell_id_b, raw_mscpps+95+nSizeShift, 15);
    mscpps_buf.ms_class_mark = raw_mscpps[110+nSizeShift];
    strncpy(mscpps_buf.start_date, raw_mscpps+111+nSizeShift, 8); /* YYYYMMDD format */
    strncpy(mscpps_buf.start_time, raw_mscpps+119+nSizeShift, 6);
    strncpy(mscpps_buf.duration, raw_mscpps+125+nSizeShift, 6);
    strncpy(mscpps_buf.data_vol, raw_mscpps+131+nSizeShift, 6);
    strncpy(mscpps_buf.data_vol_ref, raw_mscpps+137+nSizeShift, 6);
    strncpy(mscpps_buf.tariff_class, raw_mscpps+143+nSizeShift, 4);
    strncpy(mscpps_buf.ms_roaming_num, raw_mscpps+147+nSizeShift, 17);
    mscpps_buf.charging_indicator = raw_mscpps[164+nSizeShift];    /* '2' is Free of Charge */
    strncpy(mscpps_buf.charging_origin, raw_mscpps+165+nSizeShift, 4);
    strncpy(mscpps_buf.originate_a_no, raw_mscpps+169+nSizeShift, 12);
    strncpy(mscpps_buf.supplementary_code, raw_mscpps+181+nSizeShift, 2);
    mscpps_buf.imei_a_b_c = raw_mscpps[183+nSizeShift];
    strncpy(mscpps_buf.imei, raw_mscpps+184+nSizeShift, 15);
    strncpy(mscpps_buf.out_tgrp, raw_mscpps+199+nSizeShift, 10);
    strncpy(mscpps_buf.in_tgrp, raw_mscpps+209+nSizeShift, 10);
    strncpy(mscpps_buf.cause_termination, raw_mscpps+219+nSizeShift, 10);
    mscpps_buf.dual_serv_type = raw_mscpps[229+nSizeShift];
    strncpy(mscpps_buf.dual_serv_code, raw_mscpps+230+nSizeShift, 2);
    mscpps_buf.channel_req = raw_mscpps[232+nSizeShift];
    mscpps_buf.channel_used = raw_mscpps[233+nSizeShift];
    mscpps_buf.transperancy_ind = raw_mscpps[234+nSizeShift];

    for (i = 0; i < 5; i++) {   /* Table occurs 5 times */
        pos = 235+nSizeShift+(i * 3);
        mscpps_buf.ss_event[i].action_code = raw_mscpps[pos];
        strncpy(mscpps_buf.ss_event[i].ss_code, raw_mscpps+(pos+1), 2);
        Trim_Str(mscpps_buf.ss_event[i].ss_code);
    }
    strncpy(mscpps_buf.service_key, raw_mscpps+250+nSizeShift, 6);    /* Added by Kawee on 07-Apr-2005 */
    strncpy(mscpps_buf.fci, raw_mscpps+256+nSizeShift, 8);        /* Added by Kawee on 07-Apr-2005 */

    /* Trim Trailing Spaces on String Fields */
    Trim_Str(mscpps_buf.imsi_no);
    Trim_Str(mscpps_buf.b_no);
    Trim_Str(mscpps_buf.a_no);
    Trim_Str(mscpps_buf.service_type);
    Trim_Str(mscpps_buf.service_id);
    Trim_Str(mscpps_buf.msc_id);
    Trim_Str(mscpps_buf.cell_id_a);
    Trim_Str(mscpps_buf.cell_id_b);
    Trim_Str(mscpps_buf.start_date);
    Trim_Str(mscpps_buf.start_time);
    Trim_Str(mscpps_buf.duration);
    Trim_Str(mscpps_buf.data_vol);
    Trim_Str(mscpps_buf.data_vol_ref);
    Trim_Str(mscpps_buf.tariff_class);
    Trim_Str(mscpps_buf.ms_roaming_num);
    Trim_Str(mscpps_buf.charging_origin);
    Trim_Str(mscpps_buf.originate_a_no);
    Trim_Str(mscpps_buf.supplementary_code);
    Trim_Str(mscpps_buf.imei);
    Trim_Str(mscpps_buf.out_tgrp);
    Trim_Str(mscpps_buf.in_tgrp);
    Trim_Str(mscpps_buf.cause_termination);
    Trim_Str(mscpps_buf.dual_serv_code);
    Trim_Str(mscpps_buf.service_key);  /* Added by Kawee on 07-Apr-2005 */
    Trim_Str(mscpps_buf.fci);      /* Added by Kawee on 07-Apr-2005 */

    /* Construct Error Index */
    sprintf(glb_Eindex, "%s-%s-%s-%s-%s", mscpps_buf.record_type, mscpps_buf.a_no, mscpps_buf.start_date, mscpps_buf.start_time, glb_MtxType);
    strcpy(glb_CurCDRDate, mscpps_buf.start_date);
    strcpy(glb_CurCDRTime, mscpps_buf.start_time);

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Read_DpcGsm_Cdr()
**
** Description  : Reads One DPCGSM_TYPE CDR from Raw file into raw buffer. This can be a DPCTAC_TYPE CDR also.
**        Parses and copies data of all fields from raw buffer to DPCGSM global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_DpcGsm_Cdr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_DpcGsm_Cdr");
    _p_ = 0;
#endif
    int i = 0, pos = 0;
    int nSizeShift = 8;     /* Bno size is extened 8 char more (inserted) */

    memset(&dpcgsm_buf, 0x00, sizeof (dpcgsm_buf));
    memset(raw_dpcgsm, 0x00, sizeof (raw_dpcgsm));
    memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
    memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
    memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));

    if ( fgets((char *)raw_temp, MAX_READ_SIZE, glb_Cdrfp) == NULL )
        return FAILURE;
    strncpy(raw_dpcgsm, raw_temp, sizeof(raw_dpcgsm)-1);

    glb_ReadCtr++;

    if ( strlen(raw_dpcgsm) < SIZE_DPCGSMRAW ) {
        nSizeShift = 0;
    }

    /* Changed to New CDR Format - by Kawee on 20-Mar-2003 */
    strncpy(dpcgsm_buf.plmn_code, raw_dpcgsm, 5);
    strncpy(dpcgsm_buf.record_type, raw_dpcgsm+5, 2);
    strncpy(dpcgsm_buf.imsi_no, raw_dpcgsm+7, 15);
    strncpy(dpcgsm_buf.b_no, raw_dpcgsm+22, 24+nSizeShift);
    strncpy(dpcgsm_buf.a_no, raw_dpcgsm+46+nSizeShift, 18);
    strncpy(dpcgsm_buf.service_type, raw_dpcgsm+64+nSizeShift, 2);
    strncpy(dpcgsm_buf.service_id, raw_dpcgsm+66+nSizeShift, 4);
    strncpy(dpcgsm_buf.msc_id, raw_dpcgsm+70+nSizeShift, 15);
    strncpy(dpcgsm_buf.cell_id_a, raw_dpcgsm+85+nSizeShift, 15);
    strncpy(dpcgsm_buf.cell_id_b, raw_dpcgsm+100+nSizeShift, 15);
    dpcgsm_buf.ms_class_mark = raw_dpcgsm[115+nSizeShift];
    strncpy(dpcgsm_buf.start_date, raw_dpcgsm+116+nSizeShift, 8);  /* YYYYMMDD format */
    strncpy(dpcgsm_buf.start_time, raw_dpcgsm+124+nSizeShift, 6);  /* HHMMSS format */
    strncpy(dpcgsm_buf.duration, raw_dpcgsm+130+nSizeShift, 6);    /* HHMMSS format */
    strncpy(dpcgsm_buf.data_vol, raw_dpcgsm+136+nSizeShift, 6);
    strncpy(dpcgsm_buf.data_vol_ref, raw_dpcgsm+142+nSizeShift, 6);
    strncpy(dpcgsm_buf.tariff_class, raw_dpcgsm+146+nSizeShift, 4);
    strncpy(dpcgsm_buf.ms_roaming_num, raw_dpcgsm+152+nSizeShift, 17);
    dpcgsm_buf.charging_indicator = raw_dpcgsm[169+nSizeShift];
    strncpy(dpcgsm_buf.charging_origin, raw_dpcgsm+170+nSizeShift, 4);
    strncpy(dpcgsm_buf.originate_a_no, raw_dpcgsm+174+nSizeShift, 12);
    strncpy(dpcgsm_buf.supplementary_code, raw_dpcgsm+186+nSizeShift, 2);
    dpcgsm_buf.imei_a_b_c = raw_dpcgsm[188+nSizeShift];
    strncpy(dpcgsm_buf.imei, raw_dpcgsm+189+nSizeShift, 15);
    strncpy(dpcgsm_buf.out_tgrp, raw_dpcgsm+204+nSizeShift, 10);
    strncpy(dpcgsm_buf.in_tgrp, raw_dpcgsm+214+nSizeShift, 10);
    strncpy(dpcgsm_buf.cause_termination, raw_dpcgsm+224+nSizeShift, 10);
    dpcgsm_buf.dual_serv_type = raw_dpcgsm[234+nSizeShift];
    strncpy(dpcgsm_buf.dual_serv_code, raw_dpcgsm+235+nSizeShift, 2);
    dpcgsm_buf.channel_req = raw_dpcgsm[237+nSizeShift];
    dpcgsm_buf.channel_used = raw_dpcgsm[238+nSizeShift];
    dpcgsm_buf.transperancy_ind = raw_dpcgsm[239+nSizeShift];

    for (i = 0; i < 5; i++) {   /* Table occurs 5 times */
        pos = 240+nSizeShift+(i * 3);
        dpcgsm_buf.ss_event[i].action_code = raw_dpcgsm[pos];
        strncpy(dpcgsm_buf.ss_event[i].ss_code, raw_dpcgsm+(pos+1), 2);
        Trim_Str(dpcgsm_buf.ss_event[i].ss_code);
    }

    dpcgsm_buf.call_flag = raw_dpcgsm[255+nSizeShift];
    strncpy(dpcgsm_buf.cost, raw_dpcgsm+256+nSizeShift, 9);
    /* ignore the rest */

    /* Trim Trailing Spaces on String Fields */
    Trim_Str(dpcgsm_buf.plmn_code);
    Trim_Str(dpcgsm_buf.imsi_no);
    Trim_Str(dpcgsm_buf.b_no);
    Trim_Str(dpcgsm_buf.a_no);
    Trim_Str(dpcgsm_buf.service_type);
    Trim_Str(dpcgsm_buf.service_id);
    Trim_Str(dpcgsm_buf.msc_id);
    Trim_Str(dpcgsm_buf.cell_id_a);
    Trim_Str(dpcgsm_buf.cell_id_b);
    Trim_Str(dpcgsm_buf.start_date);
    Trim_Str(dpcgsm_buf.start_time);
    Trim_Str(dpcgsm_buf.duration);
    Trim_Str(dpcgsm_buf.data_vol);
    Trim_Str(dpcgsm_buf.data_vol_ref);
    Trim_Str(dpcgsm_buf.tariff_class);
    Trim_Str(dpcgsm_buf.ms_roaming_num);
    Trim_Str(dpcgsm_buf.charging_origin);
    Trim_Str(dpcgsm_buf.originate_a_no);
    Trim_Str(dpcgsm_buf.supplementary_code);
    Trim_Str(dpcgsm_buf.imei);
    Trim_Str(dpcgsm_buf.out_tgrp);
    Trim_Str(dpcgsm_buf.in_tgrp);
    Trim_Str(dpcgsm_buf.cause_termination);
    Trim_Str(dpcgsm_buf.dual_serv_code);
    Trim_Str(dpcgsm_buf.cost);
    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno)); /* Added by Thanakorn on 09-Sep-2012, FMS V11 */
    strcpy(glb_OriginalBno, dpcgsm_buf.b_no);
    strcpy(glb_CurCDRDate,  dpcgsm_buf.start_date);
    strcpy(glb_CurCDRTime,  dpcgsm_buf.start_time);

    /* Construct Error Index */
    sprintf(glb_Eindex, "%s-%s-%s-%s-%s", dpcgsm_buf.record_type, dpcgsm_buf.a_no, dpcgsm_buf.start_date, dpcgsm_buf.start_time, glb_MtxType);

    return SUCCESS;
}

/*
** Name     : Read_Awn_Cdr()
**
** Description  : Reads One CDR from AWN Raw CDR file into raw buffer.
**        If Header Record is read, reads One CDR again.
**        If Trailer Record is read, reads One CDR again.
**        Parses and copies data of all fields from raw buffer to GSM global buffer.
**        Calls the Trim_Str() to strip trailing spaces for required fields.
**        Constructs Error Index for error logging.
**
** Parameters   : None
**
** Return Value : SUCCESS - on Successful completion.
**        FAILURE - on End of File.
*/

int Read_Awn_Cdr()
{
    int i = 0, pos = 0;
    // int nSizeShift = 8;     /* Bno size is extened 8 char more (inserted) */
    memset(&gsm_buf, 0x00, sizeof (gsm_buf));
    memset(raw_gsm, 0x00, sizeof (raw_gsm));
    memset(glb_Eindex, 0x00, sizeof(glb_Eindex));
    memset(glb_CurCDRDate, 0x00, sizeof(glb_CurCDRDate));
    memset(glb_CurCDRTime, 0x00, sizeof(glb_CurCDRTime));

    if ( fgets((char *)raw_temp, MAX_READ_SIZE, glb_Cdrfp) == NULL )
        return FAILURE;
    strncpy(raw_gsm, raw_temp, sizeof(raw_gsm)-1);

    glb_ReadCtr++;

    strncpy(gsm_buf.record_type, raw_gsm, 2);

    /* check if header record read */
    if ( !strcmp(gsm_buf.record_type, "10") ) {
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, gsm_buf.record_type);
        /*fwrite(&raw_gsm, SIZE_GSMRAW, 1, glb_RCdrfp);*/ /* reject the AWN Header */
        fputs(raw_gsm, glb_RCdrfp); /* reject the AWN Header */

        /* Read a Record Again */
        if ( Read_Awn_Cdr())
            return FAILURE;   /* end of file */
    }

    /* check if trailer record read */
    if ( !strcmp(gsm_buf.record_type, "90") ) { /* Trailer Record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, gsm_buf.record_type);
        /*fwrite(&raw_gsm, SIZE_GSMRAW, 1, glb_RCdrfp);*/ /* reject the AWN Trailer */
        fputs(raw_gsm, glb_RCdrfp); /* reject the AWN Trailer */

        /* Read a Record Again */
        if ( Read_Awn_Cdr())
            return FAILURE;   /* end of file */
    }

    /* check if record type = 54 -> reject MT from AWN MSC cdr since they are already from OCSVPN */
    if ( !strcmp(gsm_buf.record_type, "54") ) {
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_MtxType, gsm_buf.record_type);
        /*fwrite(&raw_gsm, SIZE_GSMRAW, 1, glb_RCdrfp);*/ /* reject the AWN Trailer */
        fputs(raw_gsm, glb_RCdrfp); /* reject the AWN Trailer */

        /* Read a Record Again */
        if ( Read_Awn_Cdr())
            return FAILURE;   /* end of file */
    }

    // if ( strlen(raw_gsm) < SIZE_GSMRAW ) {
        // nSizeShift = 0;
    // }

    /* Changed to New CDR Format - by Kawee on 20-Mar-2003 */
    strncpy(gsm_buf.imsi_no, raw_gsm+2, 15);
    strncpy(gsm_buf.b_no, raw_gsm+17, 32);
    strncpy(gsm_buf.a_no, raw_gsm+49, 18);
    strncpy(gsm_buf.service_type, raw_gsm+67, 2);
    strncpy(gsm_buf.service_id, raw_gsm+69, 4);    /* "12" is Free of Charge */
    strncpy(gsm_buf.msc_id, raw_gsm+73, 15);
    strncpy(gsm_buf.cell_id_a, raw_gsm+88, 15);
    strncpy(gsm_buf.cell_id_b, raw_gsm+103, 15);
    gsm_buf.ms_class_mark = raw_gsm[118];
    strncpy(gsm_buf.start_date, raw_gsm+119, 8); /* YYYYMMDD format */
    strncpy(gsm_buf.start_time, raw_gsm+127, 6);
    strncpy(gsm_buf.duration, raw_gsm+133, 6);
    strncpy(gsm_buf.data_vol, raw_gsm+139, 6);
    strncpy(gsm_buf.data_vol_ref, raw_gsm+145, 6);
    strncpy(gsm_buf.tariff_class, raw_gsm+151, 4);
    strncpy(gsm_buf.ms_roaming_num, raw_gsm+155, 17);
    gsm_buf.charging_indicator = raw_gsm[172];  /* '2' is Free of Charge */
    strncpy(gsm_buf.charging_origin, raw_gsm+173, 4);
    strncpy(gsm_buf.originate_a_no, raw_gsm+177, 12);
    strncpy(gsm_buf.supplementary_code, raw_gsm+188, 2);
    gsm_buf.imei_a_b_c = raw_gsm[191];
    strncpy(gsm_buf.imei, raw_gsm+192, 15);
    strncpy(gsm_buf.out_tgrp, raw_gsm+207, 10);
    strncpy(gsm_buf.in_tgrp, raw_gsm+217, 10);
    strncpy(gsm_buf.cause_termination, raw_gsm+227, 10);
    gsm_buf.dual_serv_type = raw_gsm[237];
    strncpy(gsm_buf.dual_serv_code, raw_gsm+238, 2);
    gsm_buf.channel_req = raw_gsm[240];
    gsm_buf.channel_used = raw_gsm[241];
    gsm_buf.transperancy_ind = raw_gsm[242];

    for (i = 0; i < 5; i++) {   /* Table occurs 5 times */
        pos = 243+(i * 3);
        gsm_buf.ss_event[i].action_code = raw_gsm[pos];
        strncpy(gsm_buf.ss_event[i].ss_code, raw_gsm+(pos+1), 2);
        Trim_Str(gsm_buf.ss_event[i].ss_code);
    }

    strncpy(gsm_buf.service_key, raw_gsm+258, 6);   /* Added by Kawee on 07-Apr-2005 */
    strncpy(gsm_buf.fci, raw_gsm+264, 8);           /* Added by Kawee on 07-Apr-2005 */
    if ( strlen(raw_gsm) > SIZE_GSMRAWOLD ) {
        strncpy(gsm_buf.cell4G, raw_gsm+272, 19);              /* Added by Thanakorn on 08-Jan-2016 */
    }

    /* Trim Trailing Spaces on String Fields */
    Trim_Str(gsm_buf.imsi_no);
    Trim_Str(gsm_buf.b_no);
    Trim_Str(gsm_buf.a_no);
    Trim_Str(gsm_buf.service_type);
    Trim_Str(gsm_buf.service_id);
    Trim_Str(gsm_buf.msc_id);
    Trim_Str(gsm_buf.cell_id_a);
    Trim_Str(gsm_buf.cell_id_b);
    Trim_Str(gsm_buf.start_date);
    Trim_Str(gsm_buf.start_time);
    Trim_Str(gsm_buf.duration);
    Trim_Str(gsm_buf.data_vol);
    Trim_Str(gsm_buf.data_vol_ref);
    Trim_Str(gsm_buf.tariff_class);
    Trim_Str(gsm_buf.ms_roaming_num);
    Trim_Str(gsm_buf.charging_origin);
    Trim_Str(gsm_buf.originate_a_no);
    Trim_Str(gsm_buf.supplementary_code);
    Trim_Str(gsm_buf.imei);
    Trim_Str(gsm_buf.out_tgrp);
    Trim_Str(gsm_buf.in_tgrp);
    Trim_Str(gsm_buf.cause_termination);
    Trim_Str(gsm_buf.dual_serv_code);
    Trim_Str(gsm_buf.service_key);
    Trim_Str(gsm_buf.fci);
    if ( strlen(raw_gsm) > SIZE_GSMRAWOLD ) {
        Trim_Str(gsm_buf.cell4G);
    }

    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno)); /* Added by Thanakorn on 09-Sep-2012, FMS V11 */
    strcpy(glb_OriginalBno, gsm_buf.b_no);
    strcpy(glb_CurCDRDate,  gsm_buf.start_date);
    strcpy(glb_CurCDRTime,  gsm_buf.start_time);

    /* Construct Error Index */
    sprintf(glb_Eindex, "%s-%s-%s-%s-%s", gsm_buf.record_type, gsm_buf.a_no, gsm_buf.start_date, gsm_buf.start_time, glb_MtxType);

    return SUCCESS;
}


int Sms_To_Sms_Event ()
{
    //int Ano_len = strlen(sms_buf.a_no);
    double          Charge = 0.0;
    //unsigned int    Duration = 0;       // Duration
    //time_t          Seize_time = 0;     // Seize Time in Seconds
    double          Rate_Pm = 0.0;      // Rate Per Minute

    int iCategories = 0;

    char net_orig[SIZE_NET+1];
    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    char costcode_name[SIZE_COSTCODE_NAME+1];
    char costgroup_id1[SIZE_COSTGROUP_ID+1];
    char costgroup_id2[SIZE_COSTGROUP_ID+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char rating_catalogue_id[SIZE_RATING_CATALOGUE_ID+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    char actual_rec_type[SIZE_ACTUAL_REC_TYPE+1];

    memset(net_orig, 0x00, sizeof(net_orig));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(costcode_name, 0x00, sizeof(costcode_name));
    memset(costgroup_id1, 0x00, sizeof(costgroup_id1));
    memset(costgroup_id2, 0x00, sizeof(costgroup_id2));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(rating_tariff_id, 0x00, sizeof(rating_tariff_id));
    memset(rating_catalogue_id, 0x00, sizeof(rating_catalogue_id));
    memset(fix_charge_mny, 0x00, sizeof(fix_charge_mny));
    memset(charge_rate, 0x00, sizeof(charge_rate));
    memset(actual_rec_type, 0x00, sizeof(actual_rec_type));

    // initialize Common Structure buffer for each CDR
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&sms_event, 0x00, sizeof (sms_event));

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_SMS] == 0 ) {
        // Reject BOS online record, added by Thanakorn on 26-Aug-2013
        // ignore servpackid = 5 (5 - BOS� 2G,3G)
        if ( sms_buf.servpackid[0] == '5' ) {
            fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // reject the record
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| servpackid(%s)\n", glb_Eindex, sms_buf.servpackid);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    // Feed This CDR only included AIS Installation - Kawee on 29-Dec-2005
    if ( !glb_AisInstFlag ) {   // Not Included AIS Installation
        fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strncmp(sms_buf.service_id, "12", 2) ) {  // Free of Charge
        fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Non_Charge|Service_ID %s| b_no(%s)\n", glb_Eindex, sms_buf.service_id, sms_buf.b_no);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp(sms_buf.record_type, "10") ) { // Header Record
        fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, sms_buf.record_type);
        //glb_IgnCtr++; // Dont count header or trailer record
        return FAILURE;
    }
    else if ( !strcmp(sms_buf.record_type, "90") ) {    // Trailer Record
        fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, sms_buf.record_type);
        //glb_IgnCtr++; // Dont count header or trailer record
        return FAILURE;
    }
    else if ( glb_MtxInd == SMS_TYPE ) {
        if ( !strcmp(sms_buf.record_type, "99") || !strcmp(sms_buf.record_type, "96") ) {   // Read SMS (Reject 99 and 96)
            fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
            fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s| feed this cdr on smc type\n", glb_Eindex, sms_buf.record_type);
            glb_IgnCtr++;
            return FAILURE;
        }
        else if ( strcmp(sms_buf.record_type, "98") &&
                  strcmp(sms_buf.record_type, "95") &&
                  strcmp(sms_buf.record_type, "94") ) {
            fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
            fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, sms_buf.record_type);
            glb_IgnCtr++;
            return FAILURE;
        }
    }
    // Added SMSFDA CDR Type - by Kawee on 24-Oct-2008
    else if ( glb_MtxInd == SMSFDA_TYPE ) {
        if ( strcmp(sms_buf.record_type, "99") /*&& strcmp(sms_buf.record_type, "96")*/ ) { // Accept only 99
            if ( strcmp(sms_buf.record_type, "97") || !glb_SmsNew ) {   // Added type 97 by Thanakorn on Jan-2010 -> if new and 97 don't reject
                fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
                fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, sms_buf.record_type);
                glb_IgnCtr++;
                return FAILURE;
            }
        }
        else if ( strstr(sms_buf.cell_id_a, "PPS*") ) {
            fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp); // a new record type - reject
            fprintf(glb_Ignfp, "[DET] %s|ORG_Call|DPC| cell_id_a(%s)\n", glb_Eindex, sms_buf.cell_id_a);
            glb_IgnCtr++;
            return FAILURE;
        }
    }
    // Event Type
    glb_EventId = SMS_EVENT_TYPE;   // SMS Event Type
    sprintf(sms_event.event_type, "%02d", glb_EventId);

    // Map Ano
    if ( Conv_Ano(sms_buf.a_no, sms_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
#ifdef DEBUG_ANO    // Use this for debug only
printf ("SMS ano=%-30s => %s\n", sms_buf.a_no, sms_event.mobile_num);
#endif
    if ( strlen(sms_event.mobile_num) < SIZE_PHONENO ) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, sms_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }
    // From Mobile Number
    strncpy(sms_event.from_number, sms_event.mobile_num, 18);

    // To Mobile Number
    // map b_no
    if ( !strlen(sms_buf.b_no) ) {  // b_no blank
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    Conv_Sms_Bno();
    strncpy(sms_event.to_number, com_buf.b_no, 18);
    Conv_RealBno(sms_event.to_number, sms_event.bno);   // get exact bno (without any access code)
#if 0
    // Added the following onnet/offnet by N.Thanakorn on 26-Aug-2014
    if ( strncmp(sms_event.to_number, "06", 2) == 0 ||
         strncmp(sms_event.to_number, "08", 2) == 0 ||
         strncmp(sms_event.to_number, "09", 2) == 0 ) {
        iCategories |= CAT_ONNET;
    }
#endif
#ifdef DEBUG_BNO    // Use this for debug only
printf ("SMS bno=%-30s => %s\n", sms_buf.b_no, sms_event.to_number);
#endif

    // Introduced AIN - Added below by Kawee on 04-Jan-2007
    if ( !strncmp(sms_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||    // AIN 3rd Product Intl - Added by Kawee on 11-Nov-2009
         !strncmp(sms_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||    // AIN 2nd Product Intl - Added by Kawee on 25-Aug-2008
         !strncmp(sms_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||    // AIN Intl
         !strncmp(sms_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||    // AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013
         !strncmp(sms_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
         !strncmp(sms_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {
        fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Ignfp, "[DET] %s|Send_SMS_AIN_Number|AIN_Number %s\n", glb_Eindex, sms_buf.b_no);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
    if ( !IsValid_YYYYMMDD_HHMMSS (sms_buf.start_date, sms_buf.start_time) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date(%s) start_time(%s)\n", glb_Eindex, sms_buf.start_date, sms_buf.start_time);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008
    if ( strncmp(sms_buf.start_date, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n",
            glb_Eindex, sms_buf.start_date, sms_buf.start_time, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // Seize Time & Date
    //Seize_time = Calc_SeizeTime(sms_buf.start_date, sms_buf.start_time);
    //sprintf(sms_event.time_key, "%010ld", Seize_time);
    sprintf(sms_event.time_key, "%s%s", sms_buf.start_date, sms_buf.start_time);

    // Direction
    strcpy(sms_event.direction, OUTGOING);  // Outgoing Call

    // Country Code Called
    strcpy(sms_event.country_code, "66");   // default for Thailand

    if ( !strcmp(sms_buf.record_type, "99") &&
         (!strncmp(sms_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
          !strncmp(sms_event.to_number, EPHACC_CODE, EPHACC_LEN) ||
          !strncmp(sms_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
          !strncmp(sms_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
          !strncmp(sms_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN)) ) {     // Intl' SMS
        if ( glb_MtxInd == SMSFDA_TYPE ) {
            if ( !strncmp(sms_event.to_number, "00133191", 8) ) {
                sprintf(sms_event.to_number, "005%s", sms_event.to_number+8);
            }
            else if ( !strncmp(sms_event.to_number, "0013204", 7) ) {
                sprintf(sms_event.to_number, "005%s", sms_event.to_number+7);
            }
            else if ( !strncmp(sms_event.to_number, "001860", 6) ||
                      !strncmp(sms_event.to_number, "001338", 6) ) {
                sprintf(sms_event.to_number, "005%s", sms_event.to_number+6);
            }
        }
        switch ( Parse_Country(sms_event.to_number, sms_event.country_code, &Rate_Pm) ) {
            case SUCCESS:
            case PARSE_MUL_MATCH:
                break;
            case PARSE_NOT_MATCH:
            case FAILURE:
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, sms_event.to_number);
                glb_ErrCtr++;
                return FAILURE;
        }
    }

    // SMS Type
    // strcpy(sms_event.sms_type, sms_buf.record_type);

    // CDR Categories
    if ( strncmp(sms_buf.md_msc_address, "3GTOT", 5) == 0 ) {
        if ( strcmp(sms_event.country_code, "66") == 0 ) {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_LOCAL;
        }
        else {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_IDD;
        }
    }
    else {
        if ( strncmp(sms_buf.md_msc_address, "879", 3) == 0 ) {     // Added by N.Thanakorn on 26-Jun-2014; Maritime CDR
            iCategories |= CAT_MARITIME;
            strcpy(sms_event.cell_area, DEF_CELL_AREA);
        }
        if ( strcmp(sms_event.country_code, "66") == 0 ) {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_LOCAL;
        }
        else {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_IDD;
        }
    }
#if 0
    if ( !(iCategories & CAT_ONNET) ) {     // if CAT_ONNET is not earlier assigned, set to OFFNET. Added by N.Thanakorn on 26-Aug-2014
        iCategories |= CAT_OFFNET;
    }
#endif
    if ( iCategories & CAT_TOTAL && iCategories & CAT_MARITIME ) {
        iCategories &= ~CAT_TOTAL;      // remove CAT_TOTAL out, so that maritime will not sum to Total dimension.
        iCategories &= ~CAT_LOCAL;      // remove CAT_LOCAL out, so that maritime will not sum to SMS dimension
        // iCategories &= ~CAT_ONNET;
        // iCategories &= ~CAT_OFFNET;
        iCategories &= ~CAT_IDD;
    }
    sprintf(sms_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    sprintf(sms_event.detect_params, "%s%s%s", gaszFrmSkipDet[SKIP_COLLISION], gaszFrmSkipDet[SKIP_VELOCITY], gaszFrmSkipDet[SKIP_DUPEVENT]);

    // Charge in Satang
    Charge = 0.0;
    strcpy(banding_model_id, "3");

    // Define costcode as cell_id_b for mapping ...
    if ( !strcmp(sms_buf.record_type, "96") ) {  // SMS Report
        if ( strncmp(sms_buf.md_msc_address, "879", 3) == 0 ) {     // Added by N.Thanakorn on 26-Jun-2014; Maritime CDR
            strcpy(costcode, "MDEL_R");
        }
        else {
            strcpy(costcode, "DEL_R");
        }
    }
    else if ( !strcmp(sms_buf.record_type, "99") &&      // SMS
              (!strncmp(sms_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
               !strncmp(sms_event.to_number, EPHACC_CODE, EPHACC_LEN) ||
               !strncmp(sms_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
               !strncmp(sms_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
               !strncmp(sms_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN)) &&     // Intl' SMS
              strncmp(sms_event.to_number+3, "66", 2) ) {
        strcpy(costcode, "001");    // ISMS
    }
    else if ( !strcmp(sms_buf.record_type, "99") && !strncmp(sms_buf.md_msc_address, "879", 3) ) {   // Added by N.Thanakorn on 26-Jun-2014; Maritime CDR
        costcode[0] = 'M';
        strncat(costcode, sms_event.to_number, 2);
        costcode[3] = 0;
    }
    // Added below by Kawee on 25-Apr-2006
    else if ( strncmp(sms_event.to_number, "080", 3) >= 0 && strncmp(sms_event.to_number, "089", 3) <= 0 ) {    // Normal Call B_no is 080xxxxxxx to 089xxxxxxx
        strncpy(costcode, sms_event.to_number, 3);
    }
    else if ( strncmp(sms_event.to_number, "090", 3) >= 0 && strncmp(sms_event.to_number, "099", 3) <= 0 ) {    // Normal Call B_no is 090xxxxxxx to 099xxxxxxx
        strncpy(costcode, sms_event.to_number, 3);
    }
    else if ( strncmp(sms_event.to_number, "01", 2) >= 0 && strncmp(sms_event.to_number, "09", 2) <= 0 ) {      // Normal Call B_no is 01xxxxxxx to 09xxxxxxx
        strncpy(costcode, sms_event.to_number, 2);
    }
    else {  // Special Call E.g. 900xxx
        strcpy(costcode, sms_event.to_number);
    }

    // Define event_class_id for mapping ...
    if ( !strcmp(sms_buf.record_type, "99") ) {         // SMSO
        strcpy(event_class_id, "26");
    }
    else if ( !strcmp(sms_buf.record_type, "96") ) {    // Delivery Report SMS
        strcpy(event_class_id, "24");
    }
    else if ( !strcmp(sms_buf.record_type, "98" ) ) {    // SMST
        strcpy(event_class_id, "25");
    }
    else if ( !strcmp(sms_buf.record_type, "95") ) {    // SMST (Push Service SMS)
        strcpy(event_class_id, "23");
    }
    else if ( !strcmp(sms_buf.record_type, "94") ) {    // SMSO (Mpaging Service SMS)
        strcpy(event_class_id, "22");
    }
    else if ( !strcmp(sms_buf.record_type, "97") ) {    // Biz Life (Replay Message)
        strcpy(event_class_id, "82");
    }

    if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) {     // FAILURE
        fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s) b_no(%s)\n", glb_Eindex, costcode, sms_event.to_number);
        glb_ErrCtr++;
        return FAILURE;
    }

    strcpy(rating_tariff_id, "5");  // Net_Orig Always 'GSM' Network

    if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
        fwrite(&raw_sms, (glb_SmsNew ? SIZE_SMSRAW : SIZE_SMSRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
                glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
        glb_ErrCtr++;
        Charge = 0.0;
        return FAILURE;
    }
    else {
        Charge = atof(fix_charge_mny) / 10.0;   // Convert to Satang
    }

    // Service_id
    strcpy(sms_event.service_id, sms_buf.service_id);   // Just copy

    // ------------------------------------------------
    // cell_id_a is 15 digit
    //
    // position: 1 2 3 4 5  6 7 8 9 10  11 12 13 14 15
    // eg valu   2 3 4 5 6  3 4 5 6  8   5  7  9  3  1
    // ------------------------------------------------
    // CI  = 11 - 15 => Cell        -> 57931
    // LAC =  6 - 10 => Cell Set    -> 34568
    //     =  8 -  9 => Cell Area   -> 00056
    // ------------------------------------------------
#if 0
    strncpy(sms_event.cell, sms_buf.cell_id_a+10, 5);
    strncpy(sms_event.cell_set, sms_buf.cell_id_a+5, 5);
    strcpy(sms_event.cell_area, "000");
    strncpy(sms_event.cell_area+3, sms_buf.cell_id_a+7, 2);
#endif
    if ( sms_event.cell_area[0] == '\0' ) {
        if ( Get_GeoData(sms_buf.cell_id_a, sms_event.cell, sms_event.cell_set, sms_event.cell_area) != SUCCESS ) {
            fprintf(glb_Errfp, "[DET] %s|GeoMapp|Cell_IDA| cell_id_a(%s) but not skip\n", glb_Eindex, sms_buf.cell_id_a);
            strcpy(sms_event.cell_area, DEF_CELL_AREA);
        }
    }



    // ----- not yet mapping fields -----
    // sms_event.remarks
    // sms_event.business_code
    // sms_event.pre_disc
    // sms_event.payment_type
    // sms_event.fee_charge
    // ----- not yet mapping fields -----

    strcpy(sms_event.partition_id, AWN_PARTITION);
    sprintf(sms_event.charge, "%010.0lf", Charge);
    strcpy(sms_event.original_bno, glb_OriginalBno);
    strcpy(sms_event.event_src, glb_EventSource);

    return SUCCESS;
}


int Smc_To_Sms_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Smc_To_Sms_Event");
    _p_ = 0;
#endif
    //int Ano_len = strlen(smc_buf.a_no);
    double Charge = 0.0;
    //unsigned int Duration = 0;      // Duration
    //time_t Seize_time = 0;          // Seize Time in Seconds

    double Rate_Pm = 0.0;           // Rate Per Minute

    int iCategories = 0;
    //int iFeature = 0;

    char sVolume[21+1];
    char net_orig[SIZE_NET+1];
    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    char costcode_name[SIZE_COSTCODE_NAME+1];
    char costgroup_id1[SIZE_COSTGROUP_ID+1];
    char costgroup_id2[SIZE_COSTGROUP_ID+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char rating_catalogue_id[SIZE_RATING_CATALOGUE_ID+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    char actual_rec_type[SIZE_ACTUAL_REC_TYPE+1];

    memset(sVolume, 0x00, sizeof(sVolume));
    memset(net_orig, 0x00, sizeof(net_orig));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(costcode_name, 0x00, sizeof(costcode_name));
    memset(costgroup_id1, 0x00, sizeof(costgroup_id1));
    memset(costgroup_id2, 0x00, sizeof(costgroup_id2));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(rating_tariff_id, 0x00, sizeof(rating_tariff_id));
    memset(rating_catalogue_id, 0x00, sizeof(rating_catalogue_id));
    memset(fix_charge_mny, 0x00, sizeof(fix_charge_mny));
    memset(charge_rate, 0x00, sizeof(charge_rate));
    memset(actual_rec_type, 0x00, sizeof(actual_rec_type));

    // initialize Common Structure buffer for each CDR
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&sms_event, 0x00, sizeof (sms_event));

    // Feed This CDR only included AIS Installation - Kawee on 29-Dec-2005
    if ( !glb_AisInstFlag) {    // Not Included AIS Installation
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strncmp(smc_buf.service_id, "12", 2) ) {  // Free of Charge
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Non_Charge|Service_ID %s| b_no(%s)\n", glb_Eindex, smc_buf.service_id, smc_buf.b_no);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp(smc_buf.record_type, "10") ) { // Header Record
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, smc_buf.record_type);
        //glb_IgnCtr++; // Dont count Header or Trailer record
        return FAILURE;
    }
    else if ( !strcmp(smc_buf.record_type, "90") ) {    // Trailer Record
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, smc_buf.record_type);
        //glb_IgnCtr++; // Dont count Header or Trailer record
        return FAILURE;
    }
    else if ( !strcmp(smc_buf.record_type, "98") ) {    // Read SMS
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s| feed this cdr on sms type\n", glb_Eindex, smc_buf.record_type);
        glb_IgnCtr++;
        return FAILURE;
    }
    else if ( strcmp(smc_buf.record_type, "99") ) {
        if ( strcmp(smc_buf.record_type, "97") || !glb_SmcNew ) {   // Added type 97 by Thanakorn on Jan-2010 -> if new and 97 don't reject
            fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
            fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, smc_buf.record_type);
            glb_IgnCtr++;
            return FAILURE;
        }
    }
    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_SMS] == 0 ) {
        // Reject BOS online record, added by Thanakorn on 26-Aug-2013
        // ignore MD_AUTHENTICATION_RESULT = 306, 307, 406 and 407:
        //  306 -> BOS Pre
        //  307 -> BOS Post
        //  406 -> BOS Pre
        //  407 -> BOS Post
        //
        if ( !strcmp(smc_buf.auth_result, "306") ||
             !strcmp(smc_buf.auth_result, "307") ||
             !strcmp(smc_buf.auth_result, "406") ||
             !strcmp(smc_buf.auth_result, "407") ) {
            fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| auth_result(%s)\n", glb_Eindex, smc_buf.auth_result);
            glb_IgnCtr++;
            return FAILURE;
        }
    }
    //
    // Since MD ADD FDA SMS switches and try to move SMS service to new switches.
    // During migration FDA switches and SMC switches run parallel and both switch generate same CDR that make
    // duplicate CDR on the system. To avoid the duplicate CDR, MD Change the SS_Event field to originate Addr field
    // and use it to indicate the duplicate SMS CDR.
    // if SMS CDR that originate addr field have value (don't blank) and its value matched with record in REJ_ORIG_ADDR Table,
    // it means that CDR is Duplicate CDR with FDA CDR. Thus, we reject this record.
    //
    // Added Condition check for reject SMC CDR that MD generate duplicate record with FDA CDR
    // - by Wiraphot on 07-Jan-2009
    //
    if ( smc_buf.orig_addr[0] != '\0' && Is_RejOrigAddr(smc_buf.orig_addr) ) {
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Errfp, "[DET] %s|DUP|Originate_ADDR| sms orig_addr(%s)\n", glb_Eindex, smc_buf.orig_addr);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Event Type
    glb_EventId = SMS_EVENT_TYPE;   // SMC Event Type
    sprintf(sms_event.event_type, "%02d", glb_EventId);

    // Service Number
    // map a_no
    if ( Conv_Ano(smc_buf.a_no, sms_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
#ifdef DEBUG_ANO    // Use this for debug only
printf ("SMC ano=%-30s => %s\n", smc_buf.a_no, sms_event.mobile_num);
#endif
    if ( strlen(sms_event.mobile_num) < SIZE_PHONENO) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, sms_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( Parse_PpsDesc(smc_buf.pps_desc, smc_buf.auth_result, net_orig, actual_rec_type) ) {
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Invalid|PPS_Desc %s| auth_result(%s)\n", glb_Eindex, smc_buf.pps_desc, smc_buf.auth_result);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp(net_orig, "PPS") ) {
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|ORG_Call|PPS| pps_desc(%s) auth_result(%s)\n", glb_Eindex, smc_buf.pps_desc, smc_buf.auth_result);
        glb_IgnCtr++;
        return FAILURE;
    }

    // From Mobile Number
    strncpy(sms_event.from_number, sms_event.mobile_num, 18);

    // To Mobile Number
    // map b_no
    if ( !strlen(smc_buf.b_no) ) {  // b_no blank
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    Conv_Smc_Bno();
    strncpy(sms_event.to_number, com_buf.b_no, 18);
    Conv_RealBno(sms_event.to_number, sms_event.bno);   // get exact bno (without any access code)
#if 0
    // Added the following onnet/offnet by N.Thanakorn on 26-Aug-2014
    if ( strncmp(sms_event.to_number, "06", 2) == 0 ||
         strncmp(sms_event.to_number, "08", 2) == 0 ||
         strncmp(sms_event.to_number, "09", 2) == 0 ) {
        iCategories |= CAT_ONNET;
    }
#endif
#ifdef DEBUG_BNO    // Use this for debug only
printf ("SMC bno=%-30s => %s\n", smc_buf.b_no, sms_event.to_number);
#endif

    // Introduced AIN - Added below by Kawee on 04-Jan-2007
    if ( !strncmp(sms_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||    // AIN 3rd Product Intl - Added by Kawee on 11-Nov-2009
         !strncmp(sms_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||    // AIN 2nd Product Intl - Added by Kawee on 25-Aug-2008
         !strncmp(sms_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||    // AIN Intl
         !strncmp(sms_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||    // AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013
         !strncmp(sms_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
         !strncmp(sms_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Send_SMS_AIN_Number|AIN_Number %s\n", glb_Eindex, smc_buf.b_no);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
    if ( !IsValid_YYYYMMDD_HHMMSS (smc_buf.start_date, smc_buf.start_time) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date(%s) start_time(%s)\n",
            glb_Eindex, smc_buf.start_date, smc_buf.start_time);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008
    if ( strncmp(smc_buf.start_date, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n",
            glb_Eindex, smc_buf.start_date, smc_buf.start_time, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // Seize Time & Date
    //Seize_time = Calc_SeizeTime(smc_buf.start_date, smc_buf.start_time);
    //sprintf(sms_event.time_key, "%010ld", Seize_time);
    sprintf(sms_event.time_key, "%s%s", smc_buf.start_date, smc_buf.start_time);

    // Direction
    strcpy(sms_event.direction, OUTGOING);  // Outgoing Call

    // Country Code Called
    strcpy(sms_event.country_code, "66");

    if ( !strcmp(actual_rec_type, "99") &&
         (!strncmp(sms_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
          !strncmp(sms_event.to_number, EPHACC_CODE, EPHACC_LEN) ||
          !strncmp(sms_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
          !strncmp(sms_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
          !strncmp(sms_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN)) ) {     // Intl' SMS
        switch ( Parse_Country(sms_event.to_number, sms_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, sms_event.to_number);
                glb_ErrCtr++;
                return FAILURE;
        }
    }

    // SMS Type
    // strcpy(sms_event.sms_type, actual_rec_type);

    // CDR Categories
    if ( strncmp(sms_buf.md_msc_address, "3GTOT", 5) == 0 ) {
        if ( strcmp(sms_event.country_code, "66") == 0 ) {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_LOCAL;
        }
        else {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_IDD;
        }
    }
    else {
        if ( strcmp(sms_event.country_code, "66") == 0 ) {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_LOCAL;
        }
        else {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_IDD;
        }
    }
#if 0
    if ( !(iCategories & CAT_ONNET) ) { // if CAT_ONNET is not earlier assigned, set to OFFNET. Added by N.Thanakorn on 26-Aug-2014
        iCategories |= CAT_OFFNET;
    }
#endif
    sprintf(sms_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    sprintf(sms_event.detect_params, "%s%s%s", gaszFrmSkipDet[SKIP_COLLISION], gaszFrmSkipDet[SKIP_VELOCITY], gaszFrmSkipDet[SKIP_DUPEVENT]);

    // Charge in Satang
    Rate_Pm = 0.0;
    Charge = 0.0;
    strcpy(banding_model_id, "3");

    if ( glb_SmcNew ) {     // Added new concept rating by Thanakorn on Jan-2010
        strcpy(costcode, smc_buf.operator_a);
        if ( Get_RmCostGroupId(banding_model_id, costcode, costgroup_id2) ) {
            fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| cell_ida(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }

        if ( !strcmp(actual_rec_type, "97") ) {             // Biz Life (Replay Message)
            strcpy(costcode, smc_buf.b_no);
            strcpy(event_class_id, "82");
        }
        else if ( !strcmp(actual_rec_type, "96") ) {        // SMS Report
            strcpy(costcode, "DEL_R");
            strcpy(event_class_id, "24");
        }
        else if ( !strcmp(actual_rec_type, "99") ) {        // SMS
            if ( (!strncmp(sms_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
                  !strncmp(sms_event.to_number, EPHACC_CODE, EPHACC_LEN) ||
                  !strncmp(sms_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
                  !strncmp(sms_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
                  !strncmp(sms_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN)) &&
                  strncmp(sms_event.to_number+3, "66", 2) ) {   // Intl SMS
                sprintf(costcode, "001%s", sms_event.to_number+3);
            }
            else {  // Domestic SMS
                strcpy(costcode, smc_buf.operator_b);
            }
            strcpy(event_class_id, "26");
        }

        if ( Get_RmCostGroupId(banding_model_id, costcode, costgroup_id1) ) {
            fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }

        if ( Get_XfCostBandId (banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
            fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| costgroup_id1(%s) costgroup_id2(%s)\n",
            glb_Eindex, costgroup_id1, costgroup_id2);
            glb_ErrCtr++;
            return FAILURE;
        }
    }
    else {      // old concept rating
        if ( !strcmp(actual_rec_type, "96") ) {         // SMS Report
            strcpy(costcode, "DEL_R");
        }
        else if ( !strcmp(actual_rec_type, "99") &&     // SMS
                  (!strncmp(sms_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
                   !strncmp(sms_event.to_number, EPHACC_CODE, EPHACC_LEN) ||
                   !strncmp(sms_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
                   !strncmp(sms_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
                   !strncmp(sms_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN)) &&     // Intl' SMS
                  strncmp(sms_event.to_number+3, "66", 2) )
            strcpy(costcode, "001");    // ISMS
        // Added below by Kawee on 25-Apr-2006
        else if ( strncmp(sms_event.to_number, "080", 3) >= 0 &&
            strncmp(sms_event.to_number, "089", 3) <= 0)    // Normal Call B_no is 080xxxxxxx to 089xxxxxxx
            strncpy(costcode, sms_event.to_number, 3);
        else if ( strncmp(sms_event.to_number, "090", 3) >= 0 &&
            strncmp(sms_event.to_number, "099", 3) <= 0)    // Normal Call B_no is 090xxxxxxx to 099xxxxxxx
            strncpy(costcode, sms_event.to_number, 3);
        else if ( strncmp(sms_event.to_number, "01", 2) >= 0 &&
            strncmp(sms_event.to_number, "09", 2) <= 0)     // Normal Call B_no is 01xxxxxxx to 09xxxxxxx
            strncpy(costcode, sms_event.to_number, 2);
        else                                                // Special Call E.g. 900xxx
            strcpy(costcode, sms_event.to_number);

        if ( !strcmp(actual_rec_type, "99") )               // SMSO
            strcpy(event_class_id, "26");
        else if ( !strcmp(actual_rec_type, "96") )          // Delivery Report SMS
            strcpy(event_class_id, "24");

        if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) {     // FAILURE
            fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s) b_no(%s)\n", glb_Eindex, costcode, sms_event.to_number);
            glb_ErrCtr++;
            return FAILURE;
        }
    }
    strcpy(rating_tariff_id, "5");      // Net_Orig Always 'GSM' Network

    if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
        fwrite(&raw_smc, (glb_SmcNew ? SIZE_SMCRAW : SIZE_SMCRAWOLD), 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
            glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
        glb_ErrCtr++;
        Rate_Pm = 0.0;
        Charge = 0.0;
        return FAILURE;
    }
    else {
        Charge = atof(fix_charge_mny) / 10.0;       // Convert to Satang
    }

    // Service_id
    strcpy(sms_event.service_id, sms_buf.service_id);   // Just copy

    // ------------------------------------------------
    // cell_id_a is 15 digit
    //
    // position: 1 2 3 4 5  6 7 8 9 10  11 12 13 14 15
    // eg valu   2 3 4 5 6  3 4 5 6  8   5  7  9  3  1
    // ------------------------------------------------
    // CI  = 11 - 15 => Cell        -> 57931
    // LAC =  6 - 10 => Cell Set    -> 34568
    //     =  8 -  9 => Cell Area   -> 00056
    // ------------------------------------------------
#if 0
    strncpy(sms_event.cell, sms_buf.cell_id_a+10, 5);
    strncpy(sms_event.cell_set, sms_buf.cell_id_a+5, 5);
    strcpy(sms_event.cell_area, "000");
    strncpy(sms_event.cell_area+3, sms_buf.cell_id_a+7, 2);
#endif
    if ( sms_event.cell_area[0] == '\0' ) {
        if ( Get_GeoData(sms_buf.cell_id_a, sms_event.cell, sms_event.cell_set, sms_event.cell_area) != SUCCESS ) {
            fprintf(glb_Errfp, "[DET] %s|GeoMapp|Cell_IDA| cell_id_a(%s) but not skip\n", glb_Eindex, sms_buf.cell_id_a);
            strcpy(sms_event.cell_area, DEF_CELL_AREA);
        }
    }
    // ----- not yet mapping fields -----
    // sms_event.remarks
    // sms_event.business_code
    // sms_event.pre_disc
    // sms_event.payment_type
    // sms_event.fee_charge
    // ----- not yet mapping fields -----


    strcpy(sms_event.partition_id, AWN_PARTITION);
    sprintf(sms_event.charge, "%010.0lf", Charge);
    strcpy(sms_event.original_bno, glb_OriginalBno);
    strcpy(sms_event.event_src, glb_EventSource);

    return SUCCESS;
}

/* Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007 */
int Ssp_To_Voice_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Ssp_To_Voice_Event");
    _p_ = 0;
#endif
    char    cCell_set;
    char    sCell_set[6+1];

    memset(sCell_set,0x00,sizeof(sCell_set));
    if ( !strcmp (ssp_buf.record_type, "10") ) {      /* Header Record */
        fwrite(&raw_ssp, SIZE_SSPRAW, 1, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, ssp_buf.record_type);
        //glb_IgnCtr++;
        return FAILURE;
    }
    else if ( !strcmp (ssp_buf.record_type, "90") ) {     /* Trailer Record */
        fwrite(&raw_ssp, SIZE_SSPRAW, 1, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, ssp_buf.record_type);
        //glb_IgnCtr++;
        return FAILURE;
    }

    else if ( !strcmp (ssp_buf.record_type, "20") || !strcmp (ssp_buf.record_type, "40") ) { /* MOC or MFC CDR */

        if ( !strncmp(ssp_buf.cell_id_a+5,"0169",4) ) { /* Reject SSP cell set record  = '0169'  Add by Watthikorn.T on 10-May-2010 */
            /*strcpy(szCell_set, ssp_buf.cell_id_a+10);*/
            strncpy(sCell_set, ssp_buf.cell_id_a+5,5);
            cCell_set = ssp_buf.cell_id_a[10];
            if(cCell_set >= '0' && cCell_set <= '9' ){
                fwrite(&raw_ssp, SIZE_SSPRAW, 1, glb_RCdrfp);
                fprintf(glb_Ignfp, "[DET] %s|Cell_Set|Cell_Set %s\n", glb_Eindex, sCell_set);
                glb_IgnCtr++;
                return FAILURE;
            }
        }

        return (CommonVoice_To_Voice_Event("SSP", (VOICE_RECORD *)&ssp_buf, SIZE_SSPRAW, raw_ssp));
    }
    else {
        fwrite(&raw_ssp, SIZE_SSPRAW, 1, glb_RCdrfp); /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, ssp_buf.record_type);
        glb_IgnCtr++;
        return FAILURE;
    }
}

/* Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007 */
int CommonVoice_To_Voice_Event (char *szCdrType, VOICE_RECORD *pVoiceCdrBuf, int iSizeRaw, char *szRawCdr)
{
    double       Charge = 0.0;
    unsigned int Duration = 0;      /* Duration */
    //time_t       Seize_time = 0;    /* Seize Time in Seconds */

    double  Rate_Pm = 0.0;          /* Rate Per Minute */

    int iCategories = 0;
    int iFeature = 0;
    char szDetParams[SKIP_DET_STR_SIZE];
    //int AdjResult;
    int serv_id;
    int i;
    int iShift = 0;
    int iSetBosImeiFlg = 0;
    int nSetCostCode = FALSE;

    int cIsIodc;
    char svk_cdr[SIZE_SVKCDR+1];
    char net_orig[SIZE_NET+1];
    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    char szMap_Cell_Ida[SIZE_COSTCODE+1];
    char szMap_Cell_Idb[SIZE_COSTCODE+1];
    char tmp_msrn[SIZE_COSTCODE+1];
    char costcode_name[SIZE_COSTCODE_NAME+1];
    char costgroup_id1[SIZE_COSTGROUP_ID+1];
    char costgroup_id2[SIZE_COSTGROUP_ID+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char charge_segment_id[SIZE_CHARGE_SEGMENT_ID+1];   /* Introduced AIN - Added by Kawee on 04-Jan-2007 */
    char rating_catalogue_id[SIZE_RATING_CATALOGUE_ID+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    char unit_duration[SIZE_UNIT_DURATION+1];           /* Introduced AIN - Added by Kawee on 04-Jan-2007 */
    char szTemp[10+1];
    char szTempServiceId[4+1];                          /* Added by Kawee on 12-Jun-2008 */
    char szChargeNet[SIZE_NET+1];                       /* Added by Kawee on 19-Sep-2008 */
    char szTmp[30];

    memset(svk_cdr, 0x00, sizeof(svk_cdr));
    memset(net_orig, 0x00, sizeof(net_orig));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(szMap_Cell_Ida, 0x00, sizeof(szMap_Cell_Ida));
    memset(szMap_Cell_Idb, 0x00, sizeof(szMap_Cell_Idb));
    memset(tmp_msrn, 0x00, sizeof(tmp_msrn));
    memset(costcode_name, 0x00, sizeof(costcode_name));
    memset(costgroup_id1, 0x00, sizeof(costgroup_id1));
    memset(costgroup_id2, 0x00, sizeof(costgroup_id2));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(rating_tariff_id, 0x00, sizeof(rating_tariff_id));
    memset(event_class_id, 0x00, sizeof(event_class_id));
    memset(charge_segment_id, 0x00, sizeof(charge_segment_id)); /* Introduced AIN - Added by Kawee on 04-Jan-2007 */
    memset(rating_catalogue_id, 0x00, sizeof(rating_catalogue_id));
    memset(fix_charge_mny, 0x00, sizeof(fix_charge_mny));
    memset(charge_rate, 0x00, sizeof(charge_rate));
    memset(unit_duration, 0x00, sizeof(unit_duration)); /* Introduced AIN - Added by Kawee on 04-Jan-2007 */
    memset(szChargeNet, 0x00, sizeof(szChargeNet));     /* Introduced FIX RATE - Added by Kawee on 19-Sep-2008 */
    memset(szTmp, 0x00, sizeof(szTmp));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    /* CDR Categories */
    iCategories |= CAT_TOTAL|CAT_VOICE|CAT_LOCAL;   /* Set to init Categories (then later some of them may be removed) */

    /* initialize Common Structure buffer for each CDR */
    memset(&com_buf, 0x00, sizeof(com_buf));
    memset(&voice_event, 0x00, sizeof(voice_event));
    cIsIodc = FALSE;
    strcpy(voice_event.imei, pVoiceCdrBuf->imei);   // Added by Thanakorn on 20-Jul-2011

    if ( !strncmp(pVoiceCdrBuf->service_id, "12", 2) ) {    /* Free of Charge */
        fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Non_Charge|Service_ID %s| b_no(%s)\n", glb_Eindex, pVoiceCdrBuf->service_id, pVoiceCdrBuf->b_no);
        glb_IgnCtr++;
        return FAILURE;
    }
    /* Event Type */
    glb_EventId = VOICE_EVENT_TYPE; /* VOICE Event Type */
    sprintf(voice_event.event_type, "%02d", glb_EventId);

    /* Service Number */
    /* map a_no */
    if ( Conv_Ano(pVoiceCdrBuf->a_no, com_buf.a_no) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    strncpy(voice_event.mobile_num, com_buf.a_no, 16);
#ifdef DEBUG_ANO    /* Use this for debug only */
printf ("%s ano=%-30s => %s\n", szCdrType, pVoiceCdrBuf->a_no, voice_event.mobile_num);
#endif
    if ( !strcmp(szCdrType,"DPCGSM") ) { /* DPCGSM CDR */
        strcpy(net_orig, "GSM");
    }
    else {
        if ( !strcmp(szCdrType, "SSP") )
            strcpy(svk_cdr, "SSPCDR");
        else if ( !strcmp(szCdrType, "AWN") )
            strcpy(svk_cdr, "GSMCDR");
        else
            strcpy(svk_cdr, "GSMCDR");

        if ( strcmp(pVoiceCdrBuf->data_vol_ref, "OCSVPN") == 0 ) {   // skip service mapping for Maritime MT
            strcpy(net_orig, "GSM");
        }
        else {
            if ( Get_Service(svk_cdr, pVoiceCdrBuf->service_key, pVoiceCdrBuf->fci, net_orig) &&
                 Get_Service(svk_cdr, pVoiceCdrBuf->service_key, "*", net_orig) ) {
                fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Field|FCI| cdr_type(%s) service_key(%s) fci(%s)\n", glb_Eindex, svk_cdr, pVoiceCdrBuf->service_key, pVoiceCdrBuf->fci);
                glb_ErrCtr++;
                return FAILURE;
            }
        }
    }

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_VOICE] == 0 ) {
        // in voice cdr there is a field indicates that bos online or offline,
        // so even if configured to feed only MD cdr but if bos offline flag is turned on
        // means that this cdr can be fed to FMS since it's missing from BOS side
        /* Reject BOS online record, added by Thanakorn on 26-Aug-2013 */
        if ( !strcmp(net_orig, "BOS") ) {
            if ( pVoiceCdrBuf->dual_serv_type == '1' ) {    // reject only BOS online cdr (1 = Up, 0 = Down)
                if ( Is_BosImei(voice_event.imei) ) {   /* Added by Thanakorn on 13-Nov-2013  (FMS-IMEI-11112013) */
                    iSetBosImeiFlg = 1;
                }
                else {
                    fputs(szRawCdr, glb_RCdrfp);   /* reject the record */
                    fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| service_key(%s) fci(%s)\n", glb_Eindex, pVoiceCdrBuf->service_key, pVoiceCdrBuf->fci);
                    glb_IgnCtr++;
                    return FAILURE;
                }
            }
        }
    }

    /* Added by Jetsada on 19-Dec-2005 */
    if ( (glb_AisInstFlag == FALSE && glb_DpcInstFlag == FALSE) && !strcmp(net_orig, "GSM") ) {
        fputs(szRawCdr, glb_RCdrfp); /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|ORG_Call|GSM| service_key(%s) fci(%s)\n", glb_Eindex, pVoiceCdrBuf->service_key, pVoiceCdrBuf->fci);
        glb_IgnCtr++;
        return FAILURE;
    }
    /* Modified by Jetsada on 19-Dec-2005 */
    if ( glb_12cInstFlag == FALSE && !strcmp(net_orig, "PPS") ) {
        fputs(szRawCdr, glb_RCdrfp); /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|ORG_Call|PPS| service_key(%s) fci(%s)\n", glb_Eindex, pVoiceCdrBuf->service_key, pVoiceCdrBuf->fci);
        glb_IgnCtr++;
        return FAILURE;
    }
    /* Added by Jetsada on 19-Dec-2005 */
    if ( strcmp(net_orig, "GSM") && strcmp(net_orig, "PPS") &&   /* Net is not Postpaid (GSM) and is not Prepaid (PPS) */
         strcmp(net_orig, "BOS") ) {
        fputs(szRawCdr, glb_RCdrfp); /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Field|Network| network_origin(%s) service_key(%s) fci(%s)\n", glb_Eindex, net_orig, pVoiceCdrBuf->service_key, pVoiceCdrBuf->fci);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Validate Network */
    /* Modified by Jetsada on 19-Dec-2005 */
    if ( !strcmp(net_orig, "GSM") ) {
        /* Feed This AIS CDR only included AIS Installation - Kawee on 29-Dec-2005 */
        if ( !glb_AisInstFlag && !strcmp(net_orig, "GSM") ) {   /* Not Included AIS Installation */
            fputs(szRawCdr, glb_RCdrfp); /* reject the record */
            fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS) network(%s)\n", glb_Eindex, net_orig);
            glb_IgnCtr++;
            return FAILURE;
        }
        /* Feed This DPC CDR only included DPC Installation - Kawee on 29-Dec-2005 */
        if ( !glb_DpcInstFlag && !strcmp(net_orig, "DPC") ) {     /* Not Included DPC Installation */
            fputs(szRawCdr, glb_RCdrfp); /* reject the record */
            fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC) network(%s)\n", glb_Eindex, net_orig);
            glb_IgnCtr++;
            return FAILURE;
        }
        glb_PartId = AWN_SVC_PARTITION;
    }
    else if ( !strcmp(net_orig, "PPS") ) {
        Split_Pps_Cdr(szRawCdr);    /* write pps awn record to another file */

        /* Feed This 12C CDR only included 12C Installation - Kawee on 29-Dec-2005 */
        if ( !glb_12cInstFlag && !strcmp(net_orig, "PPS") ) {     /* Not Included 12c Installation */
            fputs(szRawCdr, glb_RCdrfp); /* reject the record */
            fprintf(glb_Ignfp, "[DET] %s|Not_Install|12C| not included(12c) network(%s)\n", glb_Eindex, net_orig);
            glb_IgnCtr++;
            return FAILURE;
        }
        glb_PartId = PREPAID_SVC_PARTITION;
    }
    if ( strcmp(pVoiceCdrBuf->data_vol_ref, "OCSVPN") != 0 ) {  // skip lookup imsi vso in case of Maritime MT
        /* Added Check for reject record that IMSI exist in IMSI_VSO Table - by Kawee on 15-Aug-2008 */
        if ( Lookup_ImsiVso(pVoiceCdrBuf->imsi_no) == SUCCESS ) { /* Match IMSI in IMSI_VSO Table */
            fputs(szRawCdr, glb_RCdrfp); /* reject the record */
            fprintf(glb_Ignfp, "[DET] %s|IMSI_VSO|IMSI %s\n", glb_Eindex, pVoiceCdrBuf->imsi_no);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    /* Partition Id */  /* Added paritition_id for voice_event - by Kawee on 06-Feb-2007 */
    /* In HPFMS both Postpaid and Prepaid CDR use same partition (AIS Services) for detect Prepaid/Postpaid Mismatch Alarm */
    if ( glb_PartId == AWN_SVC_PARTITION || glb_PartId == PREPAID_SVC_PARTITION )
        strcpy(voice_event.partition_id, AWN_PARTITION);   /* Postpaid Partition */
    else {
        fprintf(glb_Errfp, "[DET] %s|Field|Partition| partition_id(%d)\n", glb_Eindex, glb_PartId);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Service Type */
    //voice_event.service_type = ST_HOME;     /* Always Home Service */
    strcpy(voice_event.service_type, ST_HOME);

    /* From Mobile Number */
    strncpy(voice_event.from_number, com_buf.a_no, 18);

    /* map b_no */
    if ( !strlen(pVoiceCdrBuf->b_no) ) { /* b_no blank */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( Conv_CommonVoice_Bno(pVoiceCdrBuf->b_no, com_buf.b_no) ) { /* Invalid b_no */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO| invalid b_no(%s)\n", glb_Eindex, pVoiceCdrBuf->b_no);
        glb_ErrCtr++;
        return FAILURE;
    }
    //strncpy(voice_event.to_number, com_buf.b_no, 18);
    strcpy(voice_event.to_number, com_buf.b_no);
    Conv_RealBno(voice_event.to_number, voice_event.bno);

#ifdef DEBUG_BNO    /* Use this for debug only */
printf ("%s bno=%-30s => %s\n", szCdrType, pVoiceCdrBuf->b_no, voice_event.to_number);
#endif
    /* Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007 */
    if ( !IsValid_YYYYMMDD_HHMMSS(pVoiceCdrBuf->start_date, pVoiceCdrBuf->start_time) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date(%s) start_time(%s)\n",
                glb_Eindex, pVoiceCdrBuf->start_date, pVoiceCdrBuf->start_time);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008 */
    if ( strncmp(pVoiceCdrBuf->start_date, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fputs(szRawCdr, glb_RCdrfp); /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n",
                glb_Eindex, pVoiceCdrBuf->start_date, pVoiceCdrBuf->start_time, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    /* Seize Time & Date */
    //Seize_time = Calc_SeizeTime (pVoiceCdrBuf->start_date, pVoiceCdrBuf->start_time);
    //sprintf(voice_event.time_key, "%010ld", Seize_time);
    sprintf(voice_event.time_key, "%s%s", pVoiceCdrBuf->start_date, pVoiceCdrBuf->start_time);

    /* Duration in Seconds */
    if ( !Is_Number(pVoiceCdrBuf->duration) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Duration| duration(%s)\n",
                glb_Eindex, pVoiceCdrBuf->duration);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( strcmp(pVoiceCdrBuf->data_vol_ref, "OCSVPN") != 0 ) {  // skip duration conversion in case of Maritime MT
        Duration = Conv_Duration(pVoiceCdrBuf->duration);       // duration in format of hhmmss, NEED to convert
        sprintf(voice_event.duration, "%06d", Duration);
    }
    else {
        Duration = atoi(pVoiceCdrBuf->duration);
        strcpy(voice_event.duration, pVoiceCdrBuf->duration);   // duration in amount of second, NO need to convese
    }


    if ( !Is_ExpressLink(voice_event.to_number) ) {
        /* Added condition to Reject Ain Min Duration - by Kawee on 09-Feb-2007 */
        if ( !strncmp(voice_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||    /* AIN 3rd Product Intl - Added by Kawee on 11-Nov-2009 */
             !strncmp(voice_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||    /* AIN 2nd Product Intl - Added by Kawee on 25-Aug-2008 */
             !strncmp(voice_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||    /* AIN Intl */
             !strncmp(voice_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
             !strncmp(voice_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
             !strncmp(voice_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {    /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
            /* if duration is < glb_AinMin_Duration seconds Reject the CDR. */
            if ( Duration < glb_AinMin_Duration ) {
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                fprintf(glb_Ignfp, "[DET] %s|Less_Duration|Duration < %ld| duration(%s)\n", glb_Eindex, glb_AinMin_Duration, pVoiceCdrBuf->duration);
                glb_DuraCtr++;
                return FAILURE;
            }
        }
        /* Added check for feed PPS CDR on GSM/SSP type by Kawee on 28-Dec-2005 */
        else if ( !strcmp(net_orig, "PPS") ) {     /* Prepaid CDR */
            /* if duration is < glb_PrepaidMin_Duration seconds Reject the CDR. */
            if ( Duration < glb_PrepaidMin_Duration ) {
                fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Ignfp, "[DET] %s|Less_Duration|Duration < %ld| duration(%s)\n", glb_Eindex, glb_PrepaidMin_Duration, pVoiceCdrBuf->duration);
                glb_DuraCtr++;
                return FAILURE;
            }
        }
        else {  /* Postpaid CDR */
            if ( strcmp(pVoiceCdrBuf->data_vol_ref, "OCSVPN") == 0 && Duration < 2 ) {
                fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Ignfp, "[DET] %s|Less_Duration|Duration < %d| duration(%s)\n", glb_Eindex, Duration, pVoiceCdrBuf->duration);
                glb_DuraCtr++;
                return FAILURE;
            }
            /* if duration is < glb_PostpaidMin_Duration seconds Reject the CDR. */
            if ( Duration < glb_PostpaidMin_Duration ) {
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                fprintf(glb_Ignfp, "[DET] %s|Less_Duration|Duration < %ld| duration(%s)\n", glb_Eindex, glb_PostpaidMin_Duration, pVoiceCdrBuf->duration);
                glb_DuraCtr++;
                return FAILURE;
            }
        }
    }

    cIsIodc = Is_IodcNumber(voice_event.to_number); /* Introduced IODC Mapping Table - Added by Kawee on 04-Dec-2007 */

    /* Country Code Called */
    strcpy(voice_event.country_code, "66");                             /* default for Thailand */
    if ( (!strncmp(voice_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
         !strncmp(voice_event.to_number, EPHACC_CODE, EPHACC_LEN)) &&   /* CAT Intl' Call */
         !cIsIodc ) {                                                   /* But not Operator Assisted Call */

        iCategories |= CAT_IDD;

        switch ( Parse_Country(voice_event.to_number, voice_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                //memset(voice_event.country_code, SPACE_CHAR, sizeof (voice_event.country_code)-1); /* reset */
                glb_ErrCtr++;
                return FAILURE;
        }
    }
    else if ( !strncmp(voice_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
              !strncmp(voice_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
              !strncmp(voice_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN) ) {  /* TOT Intl' Call */

        iCategories |= CAT_IDD;

        switch ( Parse_Country (voice_event.to_number, voice_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                //memset(voice_event.country_code, SPACE_CHAR, sizeof (voice_event.country_code)-1); /* reset */
                glb_ErrCtr++;
                return FAILURE;
        }
    }
    /* Introduced AIN - Added below by Kawee on 04-Jan-2007 */
    else if ( !strncmp(voice_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||   /* AIN 3rd Product Intl - Added by Kawee on 11-Nov-2009 */
              !strncmp(voice_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||   /* AIN 2nd Product Intl - Added by Kawee on 25-Aug-2008 */
              !strncmp(voice_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||   /* AIN Intl */
              !strncmp(voice_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {   /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
        iCategories |= CAT_IDD;

        switch ( Parse_Country (voice_event.to_number, voice_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                //memset(voice_event.country_code, SPACE_CHAR, sizeof (voice_event.country_code)-1); /* reset */
                glb_ErrCtr++;
                return FAILURE;
        }
    }
    else if ( !cIsIodc && *voice_event.to_number == '0' ) {
        /* Area Code Called (within Thailand) */
        switch ( Parse_Area (voice_event.to_number, voice_event.area_code) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
/* Removed below - by Kawee on 13-Sep-2005 */
#ifdef DONT_DELETE
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Area| b_no(%s)\n",
                        glb_Eindex, voice_event.to_number);
#endif
				break;
        }
    }
    /* Cell Location */
    if ( !strcmp(pVoiceCdrBuf->record_type, "20") ||    /* GSM */
         !strcmp(pVoiceCdrBuf->record_type, "22") ||    /* AWN */
         !strcmp(pVoiceCdrBuf->record_type, "23") ||    /* AWN */
         !strcmp(pVoiceCdrBuf->record_type, "24") ||    /* DPC */
         !strcmp(pVoiceCdrBuf->record_type, "25") ||    /* DPC */
         !strcmp(pVoiceCdrBuf->record_type, "26") ||    /* GSM */
         !strcmp(pVoiceCdrBuf->record_type, "27") ||    /* AWN */
         !strcmp(pVoiceCdrBuf->record_type, "54") ) {   /* AWN MTC */ // Added by N.Thanakorn on 26-Jun-2014; Maritime.

        /* MOC */
                /*
                ** Originating Cell, Cell Set and Cell Area Mapping from Raw cdr.
                **
                ** In the new CGI,      LAC is 5 digits in decimal format and is from 6th digit of the cell_id_a
                **                      CI is 5 digits in decimal format and is last 5 digits of the cell_ida
                **                      - Kawee 20-Mar-2003
                **
                ** Cell      - Since, CI in GSM/SSP is always "00000". Thus copy five space chars to cell.
                **             (In General Take last 5 chars (11,12,13,14,15) of cell_id_a from raw cdr.
                **             This is of Decimal value (CI).  Assign this value to FIT Cell.)
                **
                ** Cell Set  - Take 5 chars from 6th (6,7,8,9,10) of cell_id_a from raw cdr.  This is of Decimal value (LAC).
                **             Assign this value to FIT Cell Set.
                **
                ** Cell Area - Take 2 chars from 8th (8,9) of cell_id_a field from raw cdr. (This is province)
                **             Prefix 0(s) to make it 5 chars.  Assign this value to FIT Cell Area.
                */

        /* Cell ID (A-no Location) */
        //memset(voice_event.cell, SPACE_CHAR, sizeof(voice_event.cell)-1);
        if ( strlen(pVoiceCdrBuf->cell_id_a) == 15 ) {
            iShift = 0;
        }
        else {
            iShift = 1;
        }
        strncpy(voice_event.cell, pVoiceCdrBuf->cell_id_a+11-1+iShift, 5);

        strncpy(voice_event.cell_set, pVoiceCdrBuf->cell_id_a+6-1+iShift, 5);   /* Cell Set ID (A-no Location) */

        if ( strcmp(voice_event.cell_set, "62025") == 0 ) { // LAC = 62025 = AISNetCall, added by N.Thanakorn on 9-Nov-2015
            strcpy(voice_event.cell_area, "AN001");
            strcpy(voice_event.remarks, "AISNETCALL");
        }
        else {
            /* Cell Area ID (A-no Location) */
            strcpy(voice_event.cell_area, "000");
            strncpy(voice_event.cell_area+3, pVoiceCdrBuf->cell_id_a+8-1+iShift, 2);
        }

        if ( !strncmp(voice_event.to_number, "90098",  5) ||
             !strncmp(voice_event.to_number, "B98",    3) ||
             !strncmp(voice_event.to_number, "*98",    3) ||    /* Voice Info */
             !strncmp(voice_event.to_number, "90099",  5) ||
             !strncmp(voice_event.to_number, "B99",    3) ||
             !strncmp(voice_event.to_number, "*99",    3) ||    /* Voice Mail */
             !strncmp(voice_event.to_number, "900129", 6) ||
             !strncmp(voice_event.to_number, "B129",   4) ||
             !strncmp(voice_event.to_number, "*129",   4) ||    /* PPS Voice Mail */
             Is_DpcVoiceMail(voice_event.to_number) ) {
            iFeature |= FEAT_MBOX_RETR; /* Call forward to voice mail box (VMB Recording) */
        }
        /* Event Class ID for MOC */
        strcpy(event_class_id, "16");
    }
    else {  /* Call Forward */
        memset(voice_event.cell, SPACE_CHAR, sizeof(voice_event.cell)-1);
        memset(voice_event.cell_set, SPACE_CHAR, sizeof(voice_event.cell_set)-1);
        memset(voice_event.cell_area, SPACE_CHAR, sizeof(voice_event.cell_area)-1);
        /* Event Class ID for MFC */
        strcpy(event_class_id, "12");

        if ( !strcmp(pVoiceCdrBuf->record_type, "40") ||    /* GSM */
             !strcmp(pVoiceCdrBuf->record_type, "41") ||    /* AWN */
             !strcmp(pVoiceCdrBuf->record_type, "42") ||    /* AWN */
             !strcmp(pVoiceCdrBuf->record_type, "43") ||    /* DPC */
             !strcmp(pVoiceCdrBuf->record_type, "44") ||    /* DPC */
             !strcmp(pVoiceCdrBuf->record_type, "45") ) {   /* GSM */

            /* MFC */
            if ( !strncmp(voice_event.to_number, "90099",  5) ||
                 !strncmp(voice_event.to_number, "B99",    3) ||
                 !strncmp(voice_event.to_number, "*99",    3) ||
                 !strncmp(voice_event.to_number, "900129", 6) ||
                 !strncmp(voice_event.to_number, "B129",   4) ||
                 !strncmp(voice_event.to_number, "*129",   4) ||
                 !strncmp(voice_event.to_number, "T99",    3) ||
                 Is_DpcVoiceMail(voice_event.to_number) ) {
                iFeature |= FEAT_MBOX_REC;  /* Call forward to voice mail box (VMB Recording) */
            }
            else {
                iFeature |= FEAT_FORWARD;   /* Call forward to voice mail box (VMB Recording) */
            }
            /* Detection Skip Parameters */
            strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);    /* skip collision */
            strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);     /* skip velocity */
        }
    }

    if ( strncmp(pVoiceCdrBuf->cell_id_a, "52015", 5) == 0 ) {  /* Added by Thanakorn on 08-Jan-2016 */
        strcpy(voice_event.remarks, "Roam TOT");
    }

    if ( strncmp(pVoiceCdrBuf->msc_id, "6692301050", 10) == 0 ) {
        iCategories |= CAT_MARITIME;    // Added by N.Thanakorn on 26-Jun-2014; Maritime.
        strcpy(voice_event.cell_area, DEF_CELL_AREA);
        if ( !strcmp(pVoiceCdrBuf->record_type, "54") ) {
            // copy first 5 characters
            strncpy(voice_event.cell_set, pVoiceCdrBuf->cell_id_a, 5);
            // copy last 5 characters
            strncpy(voice_event.cell, pVoiceCdrBuf->cell_id_a + (strlen(pVoiceCdrBuf->cell_id_a) - 5), 5);
        }
    }

    if ( !strncmp(voice_event.to_number, LDDACC1_CODE, LDDACC1_LEN) ||      /* LDD Calls C0xxxxxxx */
         !strncmp(voice_event.to_number, LDDACC2_CODE, LDDACC2_LEN) ||      /* LDD Calls #0xxxxxxx */
         !strncmp(voice_event.to_number, "1900", 4) ||
         !strncmp(voice_event.to_number, "900909", 6) ||
         !strncmp(voice_event.to_number, "B909", 4) ||
         !strncmp(voice_event.to_number, "*909", 4) ) {     /* Added *909 as Premium call by Wiraphot on 17-April-2009 */
        /* Added "VasOrPremium" Category - Changed as below by Kawee on 22-Mar-2007 */
        /* iCategories |= CAT_PREMIUM; */   /* category - Premium Calls */
        iCategories |= CAT_PREMIUM;           /* category - Premium Calls */
    }
    /*
    ** Since, AIS have been implement Audio Text Service on *xxx,Bxxx,900xxx Number and Take care these service as VAS.
    ** For HPFMS, need to mark all Voice call to *xxx, Bxxx, 900xxx as VAS Category
    **
    ** - Added below by Kawee on 15-May-2007
    */
    else if ( !strncmp(voice_event.to_number, "900", 3) ||      /* IVR Service */
              !strncmp(voice_event.to_number, "*", 1) ||        /* IVR Service */
              !strncmp(voice_event.to_number, "B", 1) ||        /* IVR Service */
              (!strcmp(pVoiceCdrBuf->service_type, "01") && !strncmp(pVoiceCdrBuf->service_id, "37", 2)) )  /* Video Call */ {
        //iCategories |= CAT_VAS|CAT_LOCAL|CAT_OUTGOING;          /* category - VAS Calls */
        strcpy(voice_event.direction, OUTGOING);
        if ( strcmp(pVoiceCdrBuf->service_type, "01") != 0 && strncmp(pVoiceCdrBuf->service_id, "37", 2) != 0 ) {   /* Not Video Call */
            strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);     /* skip velocity for only IVR Service, Added by Thanakorn on 15-Nov-2012 */
        }
    }
    else if ( !strncmp(voice_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||     /* 007 */
              !strncmp(voice_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||   /* 008 - TOT VOIP Intl' Calls */
              !strncmp(voice_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN) )  /* 002 - TOT VOIP Malay Intl' Calls*/
        iCategories |= CAT_IDD; /* category - TOT Intl' Calls */

    if ( iCategories & CAT_IDD ) {
        iCategories &= ~CAT_LOCAL;
    }

    if ( glb_UseRatedCdr == 1 ) {
        if ( (iCategories & CAT_VOICE || iCategories & CAT_VAS) && iCategories & CAT_LOCAL ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Use_RBM|\n", glb_Eindex);
            glb_ErrCtr++;
            return FAILURE; // if RBM cdr is used, only voice local or voice vas from other cdr type is rejected.
        }
    }

    /* Features used during the call */
    /* Modified by Jetsada on 19-Dec-2005 */
    if ( !strcmp(net_orig, "GSM") || !strcmp(net_orig, "DPC") )
        iFeature |= FEAT_POSTPAID_CALL;     /* Set to POSTPAID_CALL feature */
    else
        iFeature |= FEAT_PREPAID_CALL;      /* Set to PREPAID_CALL feature */

    if ( !strcmp(pVoiceCdrBuf->service_type, "01") )               /* Bearer Service */
        iFeature |= FEAT_DATA_XMIT;
    if ( !strncmp(voice_event.to_number, "900951", 6) ||
         !strncmp(voice_event.to_number, "B951", 4) ||
         !strncmp(voice_event.to_number, "*951", 4) )
        iFeature |= FEAT_FAX;

    /* iFeature |= FEAT_FEAT_SETUP; */  /* Set The Default value is False, Removed by Kawee on 21-Oct-2005 */
    if ( Is_ExpressLink(voice_event.to_number) )
        iFeature |= FEAT_SPEED_CALL;

    if ( !strncmp(pVoiceCdrBuf->supplementary_code, "31", 2) )      /* Call Transfer */
        iFeature |= FEAT_XFER;
    else if ( !strcmp(pVoiceCdrBuf->supplementary_code, "41") )     /* Call Waiting */
        iFeature |= FEAT_WAIT;
    else if ( !strcmp(pVoiceCdrBuf->supplementary_code, "42") )     /* Call Holding */
        iFeature |= FEAT_HOLD;
    else if ( !strcmp(pVoiceCdrBuf->supplementary_code, "51") )     /* Multi party Call */
        iFeature |= FEAT_CONFERENCE;
    else if ( !strncmp(pVoiceCdrBuf->supplementary_code, "90", 2) ||    /* All Call Barring */
              !strncmp(pVoiceCdrBuf->supplementary_code, "99", 2) ||    /* All Barring of Incomming Calls Services */
              !strncmp(pVoiceCdrBuf->supplementary_code, "9A", 2) ||    /* Barring of Incomming Calls */
              !strncmp(pVoiceCdrBuf->supplementary_code, "9B", 2) )     /* Barring of all IC calls when outside HPLMN */
        iFeature |= FEAT_BAR_IN;
    else if ( !strncmp(pVoiceCdrBuf->supplementary_code, "90", 2) ||    /* All Call Barring */
              !strncmp(pVoiceCdrBuf->supplementary_code, "91", 2) ||    /* All Barring of Outgoing Calls Services */
              !strncmp(pVoiceCdrBuf->supplementary_code, "92", 2) ||    /* Barring of Outgoing Calls */
              !strncmp(pVoiceCdrBuf->supplementary_code, "93", 2) ||    /* Barring of Outgoing International Calls */
              !strncmp(pVoiceCdrBuf->supplementary_code, "94", 2) )     /* Barring of all OG International except HPLMN */
        iFeature |= FEAT_BAR_OUT;
    else if ( !strncmp(pVoiceCdrBuf->supplementary_code, "61", 2) )     /* Closed User Groups */
        iFeature |= FEAT_CLOSE_USR_GRP;
    else if ( !strncmp(pVoiceCdrBuf->supplementary_code, "43", 2) )     /* Completion to call to busy subscriber */
        iFeature |= FEAT_COMPL_BUSY;
    else if ( !strncmp(pVoiceCdrBuf->supplementary_code, "81", 2) )     /* User to User Signalling */
        iFeature |= FEAT_USER_USER_SIG;

    if ( !strncmp(pVoiceCdrBuf->service_type, "01", 2) ) {      /* Bearer Service */

        /* Implement Video Call Service - Added below by Kawee on 12-Jun-2008 */
        memset(szTempServiceId, 0x00, sizeof(szTempServiceId));
        if ( !strncmp(pVoiceCdrBuf->service_id, "37", 2) ) {    /* Begin with 37 (Video Call) */
            strncpy(szTempServiceId, pVoiceCdrBuf->service_id, 2);
        }
        else {
            strcpy(szTempServiceId, pVoiceCdrBuf->service_id);
        }

        serv_id = atoi(szTempServiceId);
        if ( (serv_id > 20 && serv_id < 27) ||  /* 21 - 26 */
             (serv_id > 33 && serv_id < 37) ||  /* 34 - 36 */
             (serv_id > 40 && serv_id < 47) ||  /* 41 - 46 */
             (serv_id > 53 && serv_id < 57) ||  /* 54 - 56 */
             (serv_id > 60 && serv_id < 67) ||  /* 61 - 66 */
             (serv_id > 71 && serv_id < 77) ||  /* 72 - 76 */
             (serv_id > 80 && serv_id < 87) ||  /* 81 - 86 */
             (serv_id > 91 && serv_id < 97) )   /* 92 - 96 */
        iFeature |= FEAT_DATA_XMIT; /* Data Transmission */
    }

    sprintf(voice_event.features, "%010d", iFeature);

    if ( Is_TollFree(voice_event.to_number, szTmp) == SUCCESS ) {   /* Added by Thanakorn on 12-Nov-2012 */
        strcat(szDetParams, gaszFrmSkipDet[SKIP_SUSP]);     /* Dont detection suspension alarm/case when call to toll_free number */
    }

    if ( iFeature & FEAT_3WAY ||        /* Is 3 Way */
         iFeature & FEAT_COMPL_BUSY ||  /* Is Call Complete to Busy */
         iFeature & FEAT_CONFERENCE ||  /* Is Call Conference */
         iFeature & FEAT_FORWARD ||     /* Is Call Forward */
         iFeature & FEAT_HOLD ||        /* Is Call Holding */
         iFeature & FEAT_WAIT ||        /* Is Call Waiting */
         iFeature & FEAT_XFER ||        /* Is Call Transfer */
         iFeature & FEAT_MBOX_REC )     /* Is VMB Recording */

        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);    /* skip collision */

    strcpy(voice_event.detect_params, szDetParams);
    /*
    ********************************************
    ** Charge in Satang
    ********************************************
    */
    /* Banding Model ID */
    strcpy(banding_model_id, "1");

    if ( strncmp(voice_event.mobile_num, "66", 2) == 0 ) {
        memset(szTemp, 0x00, sizeof(szTemp));
        strcpy(szTemp, "0");
        strncat(szTemp, voice_event.mobile_num+2, 6);
        szTemp[7] = 0;
    }
    else if ( voice_event.mobile_num[0] == '0' ) {
        memset(szTemp, 0x00, sizeof(szTemp));
        strncpy(szTemp, voice_event.mobile_num, 7);
        szTemp[7] = 0;
    }

    /* Rating Tariff ID */
    /* Added AIN 2nd Product Intl - Added by Kawee on 25-Aug-2008 */
    /* Introduced AIN - Changed as below by Kawee on 04-Jan-2007 */
    if ( !strncmp(voice_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
         !strncmp(voice_event.to_number, EPHACC_CODE, EPHACC_LEN) ||        /* CAT Intl */
         !strncmp(voice_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
         !strncmp(voice_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
         !strncmp(voice_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||
         !strncmp(voice_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||
         !strncmp(voice_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||  /* AIN Intl */
         !strncmp(voice_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
         !strncmp(voice_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
         !strncmp(voice_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) )   /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
        strcpy(rating_tariff_id, "284");
    else if ( !strcmp(net_orig, "GSM") )     /* GSM Service */
        strcpy(rating_tariff_id, "1");
    else                                    /* DPC Service */
        strcpy(rating_tariff_id, "4");

    if ( Get_CostcodeBno(pVoiceCdrBuf->b_no, costcode) == SUCCESS ) {    // Added by Thanakorn on 23-Apr-2014
        nSetCostCode = TRUE;
    }

    /* Added check for feed PPS CDR on SSP/GSM/DPCGSM type by Kawee on 28-Dec-2005 */
    if ( !strcmp(net_orig, "PPS") ) {          /* PPS Service */
        /* Do not Calculate Charge rate for PPS CDR, we check only velocity */
        Rate_Pm = 0.0;          /* No Charge */
        Charge = 0.0;
    }
    else if ( !strncmp(voice_event.to_number, "000", 3) ) { /* AIS Extension Call */
        Rate_Pm = 0.0;          /* No Charge */
        Charge = 0.0;
    }
    else if ( cIsIodc ) {       /* Operator Assisted */
        Rate_Pm = 0.0;
        Charge = 0.0;
    }
#ifdef  PREFIX_FOR_LONGCALL
    /* Introduced Calculate Charge for Prefix for Long Call (C999xxxxxxxxx) - by Kawee on 04-Dec-2007 */
    else if ( !strncmp(voice_event.to_number, LCACC_CODE, LCACC_LEN) ) {    /* AIS Long Call */
        memset(costcode, 0x00, sizeof(costcode));
        if ( Conv_CommonVoice_Bno(voice_event.to_number+LCACC_LEN, costcode) ) {  /* Invalid b_no */
            fprintf(glb_Errfp, "[DET] %s|Field|B_NO| invalid map b_no(%s)\n", glb_Eindex, pVoiceCdrBuf->b_no);
            glb_ErrCtr++;
            return FAILURE;
        }
        memset(costcode_name, 0x00, sizeof(costcode_name));
        if ( Get_RmCostGroupId2(banding_model_id, costcode, costgroup_id1, costcode_name) ) {
            fputs(szRawCdr, glb_RCdrfp); /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }

        /* Introduced Oper Field in HPERM - Added below by Kawee on 18-Sep-2008 */
        if ( strcmp(voice_event.area_code, "") ) { /* Area Code not Blank */
            strcpy(voice_event.oper_name,"FIX");
        }
        else {
            strncpy(voice_event.oper_name,costcode_name,SIZE_OPER);
        }
        /*
        ** Long Call Charging Concept
        ** ===========================
        ** For First 30 Minutes Duration Charge 10 Baht (10 Baht/30 Minutes)
        ** For Next Minute (31st Minute) Charge 1 Baht/1 Minutes
        ** For Second over 1 Minute round up to 1 Minute
        **
        ** Example
        ** Duration (Seconds)       Calculation         Charge Value (Satang)
        ** ==================       ===========         =====================
        ** 1                1000 (Fixed)            1000
        ** ...              ...             ...
        ** 1800             1000 (Fixed)            1000
        ** 1801             1000 + (1 Min x 100 Satang) 1100
        ** 1860             1000 + (1 Min x 100 Satang) 1100
        ** 1861             1000 + (2 Min x 100 Satang) 1200
        */

        Rate_Pm = 1.0;               /* Charge Rate is 1 Baht Per Minute (For Second Hour and so on) */
        if ( Duration <= 1800 ) {   /* First Hour */
            Charge = 1000.0;        /* Fixed Charge 20 Baht/Hour for First Hour */
        }
        else {
            Charge = (double)Calc_NatlCharge(Duration-1800, Rate_Pm) + 10.0;    /* Calc in Baht Unit */
            Charge = (double)Charge * 100;      /* Convert to Satang */
        }
    }
#endif  /* PREFIX_FOR_LONGCALL */
    /* Changed from using INTL_RATE.DAT to use COSTCODE.DAT and RATINGELEMENT.DAT table - by Kawee on 05-Nov-2008 */
    else if ( !strncmp(voice_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
              !strncmp(voice_event.to_number, EPHACC_CODE, EPHACC_LEN) ) {

        /* CAT International call */
        if ( nSetCostCode == FALSE ) {  // Added by Thanakorn on 23-Apr-2014
            // cost code as got from the mapping table ELSE
            // cost code as first 10 digits Bno
            strncpy(costcode, voice_event.to_number, 10);
        }
        strcpy(charge_segment_id, "37");

        if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) {     /* FAILURE */
            fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTCODE| null cost_band_id of banding_model_id(%s) costcode(%s)\n", glb_Eindex, banding_model_id, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }

        if ( Parse_RatingElement4(rating_tariff_id, cost_band_id, event_class_id, charge_segment_id, fix_charge_mny, charge_rate, unit_duration)    ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s) charge_segment_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id, charge_segment_id);
            fputs(szRawCdr, glb_RCdrfp); /* reject the record */
            glb_ErrCtr++;
            return FAILURE;
        }
        else {
            /* Get Rate in Baht Unit */
            if ( *charge_rate )
                Rate_Pm = (double)atol(charge_rate) / 100000.0;
            else
                Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

            Charge = (double)Calc_IntlCharge(Duration, Rate_Pm);
            Charge = (double)Charge * 100;     /* Convert to Satang */
        }
    }
    else if ( !strncmp(voice_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
              !strncmp(voice_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ) {

        /* TOT International call Except 002 */
        if ( nSetCostCode == FALSE ) {    // Added by Thanakorn on 23-Apr-2014
            // cost code as got from the mapping table ELSE
            // cost code as first 10 digits Bno
            strncpy(costcode, voice_event.to_number, 10);
        }
        if ( Lookup_Costcode(banding_model_id, costcode, costgroup_id1, cost_band_id, costcode_name) ) {
            fputs(szRawCdr, glb_RCdrfp); /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !*costgroup_id1 && !*cost_band_id ) {  /* Both Cost_Group_Id and Cost_Band_Id are NULL */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_Blank_After_COSTCODE| costgroup_id1 and cost_band_id are null of banding_model_id(%s) costcode(%s)\n",
                    glb_Eindex, banding_model_id, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        else if ( *costgroup_id1 ) {    /* Cost_Group_Id is Not NULL */
            strcpy(costcode, szTemp);
            if ( Get_RmCostGroupId(banding_model_id, costcode, costgroup_id2) ) {
                fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*costgroup_id2 ) {    /* Cost_Group_Id1 is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_ID2_Blank_After_COSTCODE| costgroup_id2 is null of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( Get_XfCostBandId(banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
                fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| [1]costgroup_id1(%s) costgroup_id2(%s)\n",
                        glb_Eindex, costgroup_id1, costgroup_id2);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTGROUP| null cost_band_id of banding_model_id(%s) costgroup_id1(%s) costgroup_id2(%s)\n",
                    glb_Eindex, banding_model_id, costgroup_id1, costgroup_id2);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                glb_ErrCtr++;
                return FAILURE;
            }
            else {
                /* Get Rate in Baht Unit */
                if ( *charge_rate )
                    Rate_Pm = (double)atol(charge_rate) / 100000.0;
                else
                    Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

                Charge = (double)Calc_IntlCharge (Duration, Rate_Pm);
                Charge = (double)Charge * 100;     /* Convert to Satang */
            }
        }
        else {  /* Cost_Group_Id is NULL */
            if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
                glb_ErrCtr++;
                return FAILURE;
            }
            else {
                /* Get Rate in Baht Unit */
                if ( *charge_rate )
                    Rate_Pm = (double)atol(charge_rate) / 100000.0;
                else
                    Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

                Charge = (double)Calc_IntlCharge(Duration, Rate_Pm);
                Charge = (double)Charge * 100;     /* Convert to Satang */
            }
        }
    }
    /* Introduced AIN - Added below by Kawee on 04-Jan-2007 */
    /* AIN 2nd Product Intl - Added below by Kawee on 25-Aug-2008 */
    else if ( !strncmp(voice_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||     /* AIN 3rd Product Intl */
              !strncmp(voice_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||     /* AIN 2nd Product Intl */
              !strncmp(voice_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||     /* AIN Intl */
              !strncmp(voice_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {    /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
        strncpy(costcode, voice_event.to_number, 10);
        strcpy(charge_segment_id, "37");

        if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) {     /* FAILURE */
            fputs(szRawCdr, glb_RCdrfp); /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTCODE| null cost_band_id of banding_model_id(%s) costcode(%s)\n", glb_Eindex, banding_model_id, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( Parse_RatingElement4(rating_tariff_id, cost_band_id, event_class_id, charge_segment_id, fix_charge_mny, charge_rate, unit_duration) ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s) charge_segment_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id, charge_segment_id);
            fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
            glb_ErrCtr++;
            return FAILURE;
        }
        else {
            /* Get Rate in Baht Unit */
            Rate_Pm = ((double)atol(charge_rate) / 100000.0) / (atol(unit_duration) / 100.0) * 60.0;

            Charge = (double)Calc_AinIntlCharge(Duration, Rate_Pm);
            Charge = (double)Charge * 100;     /* Convert to Satang */
        }
    }
    else if ( (!strncmp(voice_event.to_number, "1900", 4) ||    /* Audio Text */
               !strncmp(voice_event.to_number, "900", 3) ||     /* IVR Service */
               !strncmp(voice_event.to_number, "*", 1) ||       /* IVR Service */
               !strncmp(voice_event.to_number, "B", 1) ||       /* IVR Service */
               /* Video Call Service - Added by Kawee on 11-Jun-2008 */
               (!strcmp(pVoiceCdrBuf->service_type, "01") && !strncmp(pVoiceCdrBuf->service_id, "37",2)) ||
               !strncmp(voice_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN)) && nSetCostCode == FALSE ) {  /* TOT International call */

        /* Video Call Service - Added by Kawee on 11-Jun-2008 */
        if ( !strcmp(pVoiceCdrBuf->service_type, "01") && !strncmp(pVoiceCdrBuf->service_id, "37",2) ) {
            strcpy(costcode, "VIDEOCALL");
            strcpy(rating_tariff_id, "1");  /* GSM */
            strcpy(event_class_id, "83");   /* Fixed this value for Video Call */
            if ( Get_RmCostBandId2(banding_model_id, costcode, cost_band_id, voice_event.remarks) ) {  /* FAILURE */
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTCODE| null cost_band_id of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
        }
        /* Added below - by Kawee on 18-Apr-2007 */
        else if ( !strncmp(voice_event.to_number, "900", 3) ||  /* IVR Service */
                  !strncmp(voice_event.to_number, "*", 1) ||    /* IVR Service */
                  !strncmp(voice_event.to_number, "B", 1) ) {   /* IVR Service */

            strcpy(costcode, voice_event.to_number);

            if ( Get_RmCostBandId2(banding_model_id, costcode, cost_band_id, voice_event.remarks) ) {  /* FAILURE */

                memset(szTemp, 0x00, sizeof(szTemp));
                if ( !strncmp(voice_event.to_number, "900", 3) ) {  /* IVR Service */
                    /* strncpy(szTemp, voice_event.to_number+3, 4); */
                    strcpy(szTemp, voice_event.to_number+3);
                }
                else {  /* Bno started with '*' or 'B' */
                    /* strncpy(szTemp, voice_event.to_number+1, 4); */
                    strcpy(szTemp, voice_event.to_number+1);
                }

                for ( i=0; i<3; i++ ) {
                    strcpy(costcode, ivracc_tab[i]);
                    strcat(costcode, szTemp);

                    memset(voice_event.remarks, 0x00, sizeof(voice_event.remarks));
                    if ( Get_RmCostBandId2(banding_model_id, costcode, cost_band_id, voice_event.remarks) ) {  /* FAILURE */
                        continue;
                    }
                    if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
                        continue;
                    }
                    break;
                }
                if ( i >= 3 ) {
                    fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, voice_event.to_number);
                    glb_ErrCtr++;
                    return FAILURE;
                }
            }
        }
        else {
            if ( !strncmp(voice_event.to_number, "1900", 4) ) {     /* Audio Text */
                strcpy(costcode, "1900");
                strncpy(costcode+4, voice_event.to_number+4, 10);
            }
            else if ( !strncmp(voice_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN) ) {    /* TOT Intl' 002 */
                strncpy(costcode, voice_event.to_number, 3+7);
            }
            /* Added below condition for 10 Digits - by Kawee on 04-Apr-2006 */
            else if ( !strncmp(voice_event.to_number, "08", 2) ) {  /* Mobile Number */
                strncpy(costcode, voice_event.to_number, 7);
            }
            else if ( !strncmp(voice_event.to_number, "09", 2) ) {  /* Mobile Number */
                strncpy(costcode, voice_event.to_number, 7);
            }
            else {
                strncpy(costcode, voice_event.to_number, 6);        /* Lan Line */
            }

            if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) { /* FAILURE */
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*cost_band_id ) { /* Cost_Band_Id is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTCODE| null cost_band_id of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
        }
        if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
            fputs(szRawCdr, glb_RCdrfp); /* reject the record */
            glb_ErrCtr++;
            return FAILURE;
        }
        else {
            /* Get Rate in Baht Unit */
            if ( *charge_rate )
                Rate_Pm = (double)atol(charge_rate) / 100000.0;
            else
                Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

            if ( !strncmp(voice_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN) ) {
                /* TOT Intl' 002 */
                Charge = (double)Calc_IntlCharge(Duration, Rate_Pm);
                Charge = (double)Charge * 100;     /* Convert to Satang */
            }
            else {
                /*
                ** Changed Voice Charge Concept by don't use duration
                ** for calculate in case that use fix_charge_mny
                ** - by Kawee on 04-Jul-2007
                */
                if ( *charge_rate ) {
                    Charge = (double)Calc_NatlCharge(Duration, Rate_Pm);
                    Charge = (double)Charge * 100;     /* Convert to Satang */
                }
                else {
                    Charge = (double)Rate_Pm * 100;    /* Convert to Satang */
                }
            }
        }
    }
    /* Added below - by Kawee on 19-Apr-2007 */
    else if ( voice_event.to_number[0] == '1' && strlen(voice_event.to_number) < SIZE_PHONENO-2 ) { /* Special Number */

        strncpy(costcode, voice_event.to_number, 6);        /* Special Number 1xxx */

        if ( Lookup_Costcode(banding_model_id, costcode, costgroup_id1, cost_band_id, costcode_name) ) {    /* FAILURE */
            fputs(szRawCdr, glb_RCdrfp); /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !*costgroup_id1 && !*cost_band_id ) {  /* Both Cost_Group_Id and Cost_Band_Id are NULL */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_Blank_After_COSTCODE| costgroup_id1 and cost_band_id are null of banding_model_id(%s) costcode(%s)\n",
                    glb_Eindex, banding_model_id, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        else if ( *costgroup_id1 ) {    /* Cost_Group_Id is Not NULL */

            /* Get cell_id_a from ANo as a costcode for mapping to get costgroup_id2 */
            if ( strncmp(pVoiceCdrBuf->cell_id_a, "52001", 5) == 0 ) {
                strcpy(szTemp, "L");
                strncat(szTemp, (pVoiceCdrBuf->cell_id_a)+5, 5);
                szTemp[6] = 0;
            }
            else if ( strncmp(pVoiceCdrBuf->cell_id_a, "52003", 5 ) == 0 ) {
                strcpy(szTemp, "M");
                strncat(szTemp, (pVoiceCdrBuf->cell_id_a)+5, 5);
                szTemp[6] = 0;
            }

            strcpy(costcode, szTemp);
            if ( Get_RmCostGroupId(banding_model_id, costcode, costgroup_id2) ) {
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*costgroup_id2 ) {    /* Cost_Group_Id1 is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_ID2_Blank_After_COSTCODE| costgroup_id2 is null of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( Get_XfCostBandId(banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| [2]costgroup_id1(%s) costgroup_id2(%s)\n",
                        glb_Eindex, costgroup_id1, costgroup_id2);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*cost_band_id ) {   /* Cost_Band_Id is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTGROUP| null cost_band_id of banding_model_id(%s) costgroup_id1(%s) costgroup_id2(%s)\n",
                        glb_Eindex, banding_model_id, costgroup_id1, costgroup_id2);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( Parse_RatingElement3Avg(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
                        glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                glb_ErrCtr++;
                return FAILURE;
            }
        }
        else {  /* Cost_Band_Id is Not NULL */
            if ( Parse_RatingElement3Avg(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                glb_ErrCtr++;
                return FAILURE;
            }
        }
        /* Added Operator Information here - by Kawee on 22-Sep-2008 */
        strncpy(voice_event.oper_name, costcode_name, SIZE_OPER);

        /*
        ** For Special require to use rating as billing system
        ** by lookup costcode to find rating.
        ** No need to use fixed rate as normal voice
        ** - commented by Kawee on 19-Sep-2008
        */
        /* Get Rate in Baht Unit */
        /*
        ** Changed Voice Charge Concept by don't use duration
        ** for calculate in case that use fix_charge_mny
        ** - by Kawee on 04-Jul-2007
        */
        if ( *charge_rate ) {
            Rate_Pm = (double)atol(charge_rate) / 100000.0;
            Charge = (double)Calc_NatlCharge(Duration, Rate_Pm);
            Charge = (double)Charge * 100;     /* Convert to Satang */
        }
        else {
            Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;
            Charge = (double)Rate_Pm * 100;    /* Convert to Satang */
        }
    }
    else {  /* Normal Call */
        if ( !strcmp(pVoiceCdrBuf->record_type, "40") ||    /* GSM */
             !strcmp(pVoiceCdrBuf->record_type, "41") ||    /* AWN */
             !strcmp(pVoiceCdrBuf->record_type, "42") ||    /* AWN */
             !strcmp(pVoiceCdrBuf->record_type, "43") ||    /* DPC, TOT Roam */
             !strcmp(pVoiceCdrBuf->record_type, "44") ||    /* DPC */
             !strcmp(pVoiceCdrBuf->record_type, "45") ) {   /* GSM */
            /* MFC */
            // prepare cell_id_b to map costgroup_id1
            if ( nSetCostCode == TRUE && !(iCategories & CAT_MARITIME) ) {  // Cost code is set and cat is not maritime
                strcpy(szMap_Cell_Idb, costcode);   // earlier assigned above.
            }
            else {
                Trim_ZeroLeading(tmp_msrn, pVoiceCdrBuf->ms_roaming_num, 10);
                if ( !*tmp_msrn ) {     // no msrn field
                    if ( strncmp(pVoiceCdrBuf->imsi_no, "52003", 5) == 0 ) {
                        strcpy(szMap_Cell_Idb, "MF6803");     // AWN sub
                    }
                    else {
                        strcpy(szMap_Cell_Idb, "LF6801");     // AIS sub
                    }
                }
                else if ( strncmp(tmp_msrn, "66", 2) == 0 ) {
                    strncpy(szMap_Cell_Idb, tmp_msrn+2, 10);
                }
                else {
                    if ( strncmp(pVoiceCdrBuf->imsi_no, "52003", 5) == 0 ) {
                        strcpy(szMap_Cell_Idb, "MR6803");     // AWN sub
                    }
                    else {
                        strcpy(szMap_Cell_Idb, "LR6801");     // AIS sub
                    }
                }
            }

            /* prepare cell_id_a from IMSI for mapping to get costgroup_id2 */
            if ( strncmp(pVoiceCdrBuf->cell_id_a, "52015", 5) == 0 ) {  /* Added by Thanakorn on 08-Jan-2016 */
                // strcpy(szMap_Cell_Ida, "LTOT3G");
                strcpy(szMap_Cell_Ida, "S");
                strncat(szMap_Cell_Ida, (pVoiceCdrBuf->cell_id_a)+5, 5);
                szMap_Cell_Ida[6] = 0;
            }
            else if ( strncmp(pVoiceCdrBuf->msc_id, "6692301050", 10) == 0 && strcmp(pVoiceCdrBuf->record_type, "42") == 0 ) {   // Added by N.Thanakorn on 26-Jun-2014; Maritime.
                strcpy(szMap_Cell_Ida, "MO");
                strncat(szMap_Cell_Ida, (pVoiceCdrBuf->cell_id_a)+5, 5);
                szMap_Cell_Ida[7] = 0;
            }
            else if ( strcmp(voice_event.cell_set, "62025") == 0 ) {    // AISNetCall, added by N.Thanakorn on 9-Nov-2015
                strcpy(szMap_Cell_Ida, "AISNETCALL");
                strcpy(voice_event.remarks, "AISNETCALL");
            }
            else if ( strncmp(pVoiceCdrBuf->imsi_no, "52001", 5) == 0 ) {
                sprintf(szMap_Cell_Ida, "AIS%c%c", pVoiceCdrBuf->imsi_no[5], pVoiceCdrBuf->imsi_no[6]);     // using position of 6 and 7 of IMSI
            }
            else if ( strncmp(pVoiceCdrBuf->imsi_no, "52003", 5) == 0 ) {
                sprintf(szMap_Cell_Ida, "AWN%c%c", pVoiceCdrBuf->imsi_no[5], pVoiceCdrBuf->imsi_no[6]);     // using position of 6 and 7 of IMSI
            }
            else {
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| imsi(%s)\n", glb_Eindex, pVoiceCdrBuf->imsi_no);
                glb_ErrCtr++;
                return FAILURE;
            }
        }
        else {
            /* MOC */
            /* prepare cell_id_b to get costgroup_id1 from mapping table */
            if ( nSetCostCode == TRUE ) {           // Added by Thanakorn on 23-Apr-2014
                strcpy(szMap_Cell_Idb, costcode);   // earlier assigned above.
            }
            else if ( !strncmp(voice_event.to_number, LDDACC1_CODE, LDDACC1_LEN) ||     /* LDD Calls C0xxxxxxx */
                      !strncmp(voice_event.to_number, LDDACC2_CODE, LDDACC2_LEN) ) {    /* LDD Calls #0xxxxxxx */
                strcpy(szMap_Cell_Idb, "#0");
                strncat(szMap_Cell_Idb+2, voice_event.to_number+2, 4);
            }
            else if ( !strncmp(voice_event.to_number, "08", 2) || !strncmp(voice_event.to_number, "09", 2) ) {  /* Mobile Number */
                Trim_ZeroLeading(szMap_Cell_Idb, pVoiceCdrBuf->ms_roaming_num, 10);     /* Added by Thanakorn on Jan-2010 */
                if ( *szMap_Cell_Idb ) {                                                /* Added by Thanakorn on Jan-2010 */
                    if ( Get_RmCostGroupId2(banding_model_id, szMap_Cell_Idb, costgroup_id1, costcode_name) ) {
                        strncpy(szMap_Cell_Idb, voice_event.to_number, 10);
                        if ( Get_RmCostGroupId2(banding_model_id, szMap_Cell_Idb, costgroup_id1, costcode_name) ) {
                            fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
                            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, szMap_Cell_Idb);
                            glb_ErrCtr++;
                            return FAILURE;
                        }
                    }
                }
                else {
                    strncpy(szMap_Cell_Idb, voice_event.to_number, 10);
                }
            }
            else {  /* Lan Line */
                strncpy(szMap_Cell_Idb, voice_event.to_number, 10);
            }

            /* prepare cell_id_a from cell_id_a field for mapping to get costgroup_id2 */
            if ( strncmp(pVoiceCdrBuf->cell_id_a, "52015", 5) == 0 ) {  /* Added by Thanakorn on 08-Jan-2016 */
                // strcpy(szMap_Cell_Ida, "LTOT3G");
                strcpy(szMap_Cell_Ida, "S");
                strncat(szMap_Cell_Ida, (pVoiceCdrBuf->cell_id_a)+5, 5);
                szMap_Cell_Ida[6] = 0;
            }
            else if ( strncmp(pVoiceCdrBuf->msc_id, "6692301050", 10) == 0 ) {   // Added by N.Thanakorn on 26-Jun-2014; Maritime.
                if ( strcmp(pVoiceCdrBuf->record_type, "23") == 0 ) {
                    strcpy(szMap_Cell_Ida, "MO");
                    strncat(szMap_Cell_Ida, (pVoiceCdrBuf->cell_id_a)+5, 5);
                    szMap_Cell_Ida[7] = 0;
                }
                else if ( strcmp(pVoiceCdrBuf->record_type, "54") == 0 ) {
                    if ( strcmp(pVoiceCdrBuf->data_vol_ref, "OCSVPN") != 0 ) {  // cdr is from MSC
                        strcpy(szMap_Cell_Ida, "MT87901001");                   // Added by N.Thanakorn on 08-Oct-2014; Maritime V2.
                        strcpy(szMap_Cell_Idb, "MA_MT");
                    }
                    else {                                                      // cdr is from OCS and VPN
                        // strcpy(szMap_Cell_Ida, pVoiceCdrBuf->cell_id_a);
                        sprintf(szMap_Cell_Ida, "MT%s", pVoiceCdrBuf->cell_id_a);
                        if ( strcmp(pVoiceCdrBuf->service_id, "37") == 0 ) {    // it's BEARER_CAPABILITY = 8
                            strcpy(szMap_Cell_Idb, "MA_MTVIDEOCALL");
                        }
                        else {
                            strcpy(szMap_Cell_Idb, "MA_MT");
                        }
                        // pVoiceCdrBuf->cell_id_a;    // CALLED_LAC
                    }
                }
            }
            else if ( strcmp(voice_event.cell_set, "62025") == 0 ) {    // AISNetCall, added by N.Thanakorn on 9-Nov-2015
                strcpy(szMap_Cell_Ida, "AISNETCALL");
                strcpy(voice_event.remarks, "AISNETCALL");
            }
            else if ( strncmp(pVoiceCdrBuf->cell_id_a, "52001", 5) == 0 ) {
                strcpy(szMap_Cell_Ida, "L");
                strncat(szMap_Cell_Ida, (pVoiceCdrBuf->cell_id_a)+5, 5);
                szMap_Cell_Ida[6] = 0;
            }
            else if ( strncmp(pVoiceCdrBuf->cell_id_a, "52003", 5) == 0 ) {
                strcpy(szMap_Cell_Ida, "M");
                strncat(szMap_Cell_Ida, (pVoiceCdrBuf->cell_id_a)+5, 5);
                szMap_Cell_Ida[6] = 0;
            }
            else {
                fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| cell_ida(%s)\n", glb_Eindex, pVoiceCdrBuf->cell_id_a);
                glb_ErrCtr++;
                return FAILURE;
            }
        }

        if ( voice_event.cell_area[0] == '\0' ) {
            if ( Get_GeoData(pVoiceCdrBuf->cell_id_a, voice_event.cell, voice_event.cell_set, voice_event.cell_area) != SUCCESS ) {
                fprintf(glb_Errfp, "[DET] %s|GeoMapp|Cell_IDA| cell_id_a(%s) but not skip\n", glb_Eindex, pVoiceCdrBuf->cell_id_a);
                strcpy(voice_event.cell_area, UNK_CELL_AREA);
            }
        }

        memset(costcode_name, 0x00, sizeof(costcode_name));
        /* check if costgroup_id1 exist, otherwise cost_band_id will be used as mapping field for rating  */
        if ( Lookup_Costcode(banding_model_id, szMap_Cell_Idb, costgroup_id1, cost_band_id, costcode_name) ) {  /* FAILURE */
            fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, szMap_Cell_Idb);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !strncmp(costcode_name, "AIS", 3) || !strncmp(costcode_name, "AWN", 3) ) {
            strcpy(szChargeNet, costcode_name);
        }
        else {
            strcpy(szChargeNet, "OTH");
        }

        /* Introduced Oper Field in HPERM - Added below by Kawee on 18-Sep-2008 */
        if ( strcmp(voice_event.area_code, "") ) { /* Area Code not Blank */
            strcpy(voice_event.oper_name, "FIX");
        }
        else {
            strncpy(voice_event.oper_name, costcode_name, SIZE_OPER);
        }

        /* --- Rating Section --- */
        if ( glb_UseFixRateFlag == 'Y' &&
             Get_FixRate(szChargeNet, charge_rate) == SUCCESS &&
             !(iCategories & CAT_MARITIME) ) {
            /* Get Rate in Satang Unit */
            /*
            ** Changed Voice Charge Concept to fix rate and calculate with duration
            ** - by Kawee on 19-Sep-2008
            */
            Rate_Pm = (double)atol(charge_rate) / 100.0;
            Charge = (double)Calc_NatlCharge (Duration, Rate_Pm);
            Charge = (double)Charge * 100;     /* Convert to Satang */
        }
        else {
            if ( !*costgroup_id1 && !*cost_band_id ) {  /* Both Cost_Group_Id and Cost_Band_Id are NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_Blank_After_COSTCODE| costgroup_id1 and cost_band_id are null of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, szMap_Cell_Idb);
                glb_ErrCtr++;
                return FAILURE;
            }
            else if ( *costgroup_id1 ) {    /* Cost_Group_Id is Not NULL */
                if ( Get_RmCostGroupId(banding_model_id, szMap_Cell_Ida, costgroup_id2) ) {
                    fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| cell_ida(%s)\n", glb_Eindex, szMap_Cell_Ida);
                    glb_ErrCtr++;
                    return FAILURE;
                }
                if ( !*costgroup_id2 ) {    /* Cost_Group_Id1 is NULL */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_ID2_Blank_After_COSTCODE| costgroup_id2 is null of banding_model_id(%s) costcode(%s)\n",
                            glb_Eindex, banding_model_id, szMap_Cell_Ida);
                    glb_ErrCtr++;
                    return FAILURE;
                }
                if ( Get_XfCostBandId(banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
                    fputs(szRawCdr, glb_RCdrfp); /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| [3]costgroup_id1(%s) costgroup_id2(%s)\n",
                        glb_Eindex, costgroup_id1, costgroup_id2);
                    glb_ErrCtr++;
                    return FAILURE;
                }
                if ( !*cost_band_id ) {   /* Cost_Band_Id is NULL */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTGROUP| null cost_band_id of banding_model_id(%s) costgroup_id1(%s) costgroup_id2(%s)\n",
                            glb_Eindex, banding_model_id, costgroup_id1, costgroup_id2);
                    glb_ErrCtr++;
                    return FAILURE;
                }
            }

            /* costgroup_id1 is NULL or cost_band_id is set */
            if ( Parse_RatingElement3Avg(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fputs(szRawCdr, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
                        glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                glb_ErrCtr++;
                return FAILURE;
            }
            else {
                /* Get Rate in Baht Unit */
                /*
                ** Changed Voice Charge Concept by don't use duration
                ** for calculate in case that use fix_charge_mny
                ** - by Kawee on 04-Jul-2007
                */
                if ( *charge_rate ) {
                    Rate_Pm = (double)atol(charge_rate) / 100000.0;
                    Charge = (double)Calc_NatlCharge(Duration, Rate_Pm);
                    Charge = (double)Charge * 100;      /* Convert to Satang */
                }
                else {
                    Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;
                    Charge = (double)Rate_Pm * 100;     /* Convert to Satang */
                }
            }
        }
    }   // End of normal voice call section

    if ( !(iCategories & CAT_MARITIME) ) {  /* if category is not maritime then further check for onelove and tollfree */
        if ( Is_OneLoveNum(voice_event.from_number, voice_event.to_number) == SUCCESS ) {  /* Added by Thanakorn on Sep-2013 */
            Charge = 0;     /* set charge = zero when call to one love number */
        }
        else if ( Is_TollFree(voice_event.to_number, szTmp) == SUCCESS ) {   /* Added by Thanakorn on Aug-2015 */
            Charge = 0;
        }
    }

    if ( iSetBosImeiFlg == 1 ) {    /* Add by Thanakorn on 13-Nov-2013 (FMS-IMEI-11112013) */
        Charge = 0;
        strcat(szDetParams, gaszFrmSkipDet[SKIP_DETECTION]);
        strcat(szDetParams, gaszFrmSkipDet[SKIP_DEST]);
        strcat(szDetParams, gaszFrmSkipDet[SKIP_THRESHOLD]);
        strcat(szDetParams, gaszFrmSkipDet[SKIP_USAGEACCUM]);
        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);
        strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);
        strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);
        strcpy(voice_event.detect_params, szDetParams);
    }

    sprintf(voice_event.charge, "%010.0lf", Charge);
    sprintf(voice_event.fee_charge, "%010.0lf", 0.0);    // Added by N.Thanakorn on 08-Oct-2014, Maritime;

    if ( iCategories & CAT_MARITIME ) {
        iCategories &= ~CAT_TOTAL;
        iCategories &= ~CAT_VAS;
        iCategories &= ~CAT_PREMIUM;
        if ( iCategories & CAT_IDD ) {  // Added by N.Thanakorn on 08-Oct-2014, Maritime;
            sprintf(voice_event.charge, "%010.0lf", (Charge+(25*100)));     // adds extra charge for maritime idd 25 THB
            sprintf(voice_event.fee_charge, "%010d", (25*100));
        }
    }

    sprintf(voice_event.categories, "%08d", iCategories);
    strcpy(voice_event.original_bno, glb_OriginalBno);
    strcpy(voice_event.event_src, glb_EventSource);

    if ( iCategories & CAT_IDD ) {  // Added by Thanakorn
        iCategories &= ~CAT_LOCAL;
        glb_EventId = VOICE_EVENT_TYPE_IDD; // Actually it's voice event but just for categorize Priority Tube by IUM)
    }

    return SUCCESS;
}

/* ---------------------------------------------------------------------------------------------- */
/* Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007 */
int Ain_To_Voice_Event ()
{
    double          Rate_Pm = 0.0;  /* Rate Per Minute */
    double          Charge = 0.0;
    unsigned int    Duration = 0;   /* Duration */
    //time_t          Seize_time = 0; /* Seize Time in Seconds */

    int iCategories = 0;
    int iFeature = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    char *pchDestCode;
    char sRatingTariffId[6+1];
    char sCostCodeMap[SIZE_COSTCODE+1];
    char sModClassId[6+1];
    char sTimePlanId[4+1];
    char sTimeRateId[4+1];
    char sStartDay[3+1];
    char sCdrType[1+1];
    char sSubType[SIZE_AIN_SUBTYPE+1];
    char sMtxID[15+1];
    char sCostBandId[SIZE_COSTBAND_ID+1];
    char sStepGrp[4+1];
    char sStepSeq[1+1];

    char sOrigCostCodeMap[SIZE_COSTCODE+1];
    char sDestCostCodeMap[SIZE_COSTCODE+1];
    char sOrigOperCarrId[SIZE_OPER_CARRIER_ID+1];
    char sDestOperCarrId[SIZE_OPER_CARRIER_ID+1];
    char sOrigOperSingleBillFlag[SIZE_OPER_SINGLE_BILL_FLAG+1];

    char sChargeRate[SIZE_CHARGE_RATE+1];
    char sStartDateTime[SIZE_DATETIME+1];
    char sSubCarrier[SIZE_AIN_SUBCARRIER+1];
    char sTargetName[SIZE_AIN_TARGET_NAME+1];

    memset(sRatingTariffId, 0x00, sizeof(sRatingTariffId));
    memset(sCostCodeMap, 0x00, sizeof(sCostCodeMap));
    memset(sModClassId, 0x00, sizeof(sModClassId));
    memset(sTimePlanId, 0x00, sizeof(sTimePlanId));
    memset(sTimeRateId, 0x00, sizeof(sTimeRateId));
    memset(sStartDay, 0x00, sizeof(sStartDay));
    memset(sMtxID, 0x00, sizeof(sMtxID));
    memset(sSubType, 0x00, sizeof(sSubType));
    memset(sCostBandId, 0x00, sizeof(sCostBandId));
    memset(sCdrType, 0x00, sizeof(sCdrType));
    memset(sStepGrp, 0x00, sizeof(sStepGrp));
    memset(sStepSeq, 0x00, sizeof(sStepSeq));

    memset(sOrigCostCodeMap, 0x00, sizeof(sOrigCostCodeMap));
    memset(sDestCostCodeMap, 0x00, sizeof(sDestCostCodeMap));
    memset(sOrigOperCarrId, 0x00, sizeof(sOrigOperCarrId));
    memset(sDestOperCarrId, 0x00, sizeof(sDestOperCarrId));
    memset(sOrigOperSingleBillFlag, 0x00, sizeof(sOrigOperSingleBillFlag));
    memset(sChargeRate, 0x00, sizeof(sChargeRate));
    memset(sStartDateTime, 0x00, sizeof(sStartDateTime));
    memset(sSubCarrier, 0x00, sizeof(sSubCarrier));
    memset(sTargetName, 0x00, sizeof(sTargetName));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    /* initialize Common Structure buffer for each CDR */
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&voice_event, 0x00, sizeof (voice_event));

    /* Feed This CDR only included AIN Installation - Kawee on 29-Jan-2007 */
    if ( !glb_AinInstFlag) {     /* Not Included AIN Installation */
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIN| not included(AIN)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* ***Check RecordType, only RecordType of 02 will be processed*** */
    if ( !strcmp(pbuf_ain[AIN_TAG], "01") ) {        /* Header Record */
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, pbuf_ain[AIN_TAG]);
        //glb_IgnCtr++;
        return FAILURE;
    }
    else if ( !strcmp(pbuf_ain[AIN_TAG], "09") ) {       /* Trailer Record */
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, pbuf_ain[AIN_TAG]);
        //glb_IgnCtr++;
        return FAILURE;
    }
    else if ( strcmp(pbuf_ain[AIN_TAG], "02") ) {        /* CDR Data Record */
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_MtxType, pbuf_ain[AIN_TAG]);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* Check for Unknown Event Type and Reject - Kawee 29-Jan-2007 */
    // 101 -> Complete call
    // 102 -> Incomplete call
    // Process only 101 and 102 otherwise will be rejected.
    // also feed incomplete call (102) to count attempts - added by Thanakorn on Aug-2016
    if ( strcmp(pbuf_ain[AIN_ETID], "101") && strcmp(pbuf_ain[AIN_ETID], "102") )
    {   /* Unknown Event Type */
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Field|Event_Type| b_no(%s) event_type_id(%s)\n",
            glb_Eindex, pbuf_ain[AIN_DIALNO], pbuf_ain[AIN_ETID]);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Use below for Verify Originate B-Number */
    /* Using Original B-No to lookup AIN Subscriber Type Master Table to get Subscriber Type and Subscirber Carrier */
    strcpy(sSubCarrier, "AIN");
    if ( Parse_AinSubType(sSubCarrier, pbuf_ain[AIN_ORGBNO], sSubType) ) {   /* Failure */
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Field|SUB_Type| sub_carrier(%s) orig_bno(%s)\n",
            glb_Eindex, sSubCarrier, pbuf_ain[AIN_ORGBNO]);
        glb_ErrCtr++;
        return FAILURE;
    }
    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno)); /* Added by Thanakorn on 09-Sep-2012, FMS V11 */
    strncpy(glb_OriginalBno, pbuf_ain[AIN_ORGBNO], 100);

    /* Validate Network */
    /* Using Incoming Route to lookup AIN Route Master Table to get OrigCostCodeMap, OrigOperCarrierId */
    if ( Parse_AinRouteMaster (pbuf_ain[AIN_INROUTE], sOrigOperCarrId, sOrigCostCodeMap, sMtxID) ) {
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Field|INC_Route| incoming_route(%s)\n", glb_Eindex, pbuf_ain[AIN_INROUTE]);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Check if MTX_ID.CDR == MTX_ID.AIN_ROUTE_MASTER */
    if ( strcmp(sMtxID, pbuf_ain[AIN_MTXID]) ) {
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Field|MTX_ID| incoming_route(%s) mtx_id(%s)\n",
            glb_Eindex, pbuf_ain[AIN_INROUTE], pbuf_ain[AIN_MTXID]);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( Parse_AinE1Mapping (pbuf_ain[AIN_ESRC], sTargetName) ) {
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| event_source(%s)\n", glb_Eindex, pbuf_ain[AIN_ESRC]);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Prepare Destination Code */
    /* Added AIN 3rd Product Intl - by Kawee on 11-Nov-2009 */
    if ( !strncmp(pbuf_ain[AIN_DIALNO], AIN3RDACC_CODE, AIN3RDACC_LEN) ||      /* B-No starts with AIN 3rd Product Code */
         !strncmp(pbuf_ain[AIN_DIALNO], AWNIDDACC_COD3, AIN3RDACC_LEN) ) {      /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
        pchDestCode = pbuf_ain[AIN_DIALNO]+AIN3RDACC_LEN;
        strcpy(sRatingTariffId, "000132");
        strcpy(sCostCodeMap, "AINM");
        strcpy(sModClassId, "000022");
        strcpy(sTimePlanId, "0001");
        strcpy(sCdrType, "I");
    }
    /* Added AIN 2nd Product Intl - by Kawee on 25-Aug-2008 */
    else if ( !strncmp(pbuf_ain[AIN_DIALNO], AIN2NDACC_CODE, AIN2NDACC_LEN) ||     /* B-No starts with AIN 2nd Product Code */
              !strncmp(pbuf_ain[AIN_DIALNO], AWNIDDACC_COD2, AIN2NDACC_LEN) ) {    /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
        pchDestCode = pbuf_ain[AIN_DIALNO]+AIN2NDACC_LEN;
        strcpy(sRatingTariffId, "000132");
        strcpy(sCostCodeMap, "AINM");
        strcpy(sModClassId, "000022");
        strcpy(sTimePlanId, "0001");
        strcpy(sCdrType, "I");
    }
    else if ( !strncmp(pbuf_ain[AIN_DIALNO], AINIDDACC_CODE, AINIDDACC_LEN) ||     /* B-No starts with AIN Access Code */
              !strncmp(pbuf_ain[AIN_DIALNO], AWNIDDACC_COD1, AINIDDACC_LEN) ) {    /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
        pchDestCode = pbuf_ain[AIN_DIALNO]+AINIDDACC_LEN;
        strcpy(sRatingTariffId, "000017");
        strcpy(sCostCodeMap, "AINC");
        strcpy(sModClassId, "000001");
        strcpy(sTimePlanId, "0003");
        strcpy(sCdrType, "I");
    }
    else {
        fputs (raw_input, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Field|Mobile_NO| dialled_no(%s)\n", glb_Eindex, pbuf_ain[AIN_DIALNO]);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Using sCostCodeMap and Destination Code to lookup AIN Cost Code Table to get Cost Band Id */
    if ( Parse_AinCostCode2 (sCostCodeMap, pchDestCode, sCdrType, sCostBandId) ) {    /* Failure */
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Code| costcode(%s) destcode(%s) cdrtype(%s) b_no(%s)\n",
            glb_Eindex, sCostCodeMap, pchDestCode, sCdrType, pbuf_ain[AIN_DIALNO]);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Using sStartDay and sTimePlanId to lookup BasicTimeRate Table to get TimeRateId */
    strcpy(sStartDay, "ALL");
    if ( Parse_AinBasicTimeRate(sStartDay, sTimePlanId, pbuf_ain[AIN_EDTM], sTimeRateId) ) {  /* Failure */
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Rating|Time_Rate_ID| start_day(%s) time_plan_id(%s) date_time(%s)\n",
            glb_Eindex, sStartDay, sTimePlanId, pbuf_ain[AIN_EDTM]);
        glb_ErrCtr++;
        return FAILURE;
    }

    strcpy(sStepGrp, "0001");
    strcpy(sStepSeq, "1");
    strcpy(sSubType, "ALL");

    /*
    ** Using Rating Tariff Id, Cost Band Id, Modifier Class Id,
    **       Time Plan Id, Time Rate Id, Step Group, Step Seq and
    **       Subscriber Type.
    ** to lookup AIN Rating Tariff Element Table for get Charge Rate per Minute
    */
    if ( Parse_AinRatingTariffElement2 (sRatingTariffId, sCostBandId, sModClassId, sTimePlanId, sTimeRateId, sStepGrp, sStepSeq, sSubType, sChargeRate) ) {   /* Failure */
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Tariff| rating_tariff_id(%s) cost_band_id(%s) mod_class_id(%s) time_plan_id(%s) time_rate_id(%s) step_grp(%s) step_seq(%s) sub_type(%s)\n", glb_Eindex, sRatingTariffId, sCostBandId, sModClassId, sTimePlanId, sTimeRateId, sStepGrp, sStepSeq, sSubType);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Charge in Satang */
    /* Get Rate in Baht Unit */
    Rate_Pm = atof (sChargeRate);
    Duration = atoi(pbuf_ain[AIN_DURA]);

    Charge = (double) Calc_AinIntlCharge2 (Duration, Rate_Pm);
    Charge = (double) Charge * 100;     /* Convert to Satang */
    sprintf(voice_event.charge, "%010.0lf", Charge);
    sprintf(voice_event.fee_charge, "%010.0lf", 0.0);

    /* Event Type */
    glb_EventId = VOICE_EVENT_TYPE; /* 03 = VOICE Event Type */
    sprintf(voice_event.event_type, "%02d", glb_EventId);

    /* Partition Id */
    strcpy(voice_event.partition_id, AIN_PARTITION);    /* 04 = AIN Partition */

    /* Service Number */
    /* map a_no */
    if ( Conv_Ain_Ano (sTargetName, com_buf.a_no))
        return FAILURE;
    strncpy(voice_event.mobile_num, com_buf.a_no, 16);

    /* Service Type */
    //voice_event.service_type = ST_HOME;     /* Always Home Service */
    strcpy(voice_event.service_type, ST_HOME);

    /* From Mobile Number */
    if ( Conv_Ain_Ano (pbuf_ain[AIN_ESRC], com_buf.a_no))
        return FAILURE;
    strncpy(voice_event.from_number, com_buf.a_no, 18);

    /* To Mobile Number */
    /* No need to Mapping B-Number only copy */
    strncpy(voice_event.to_number, pbuf_ain[AIN_DIALNO], 18);
    Conv_RealBno(voice_event.to_number, voice_event.bno);

    /* Seize Time & Date */
    if ( strlen(pbuf_ain[AIN_EDTM]) < 19) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| event_date_time(%s) expected (YYYY/MM/DD-hh-mm-ss.tt)\n", glb_Eindex, pbuf_ain[AIN_EDTM]);
        glb_ErrCtr++;
        return FAILURE;
    }
    strncpy(sStartDateTime, pbuf_ain[AIN_EDTM], 4);
    strncat (sStartDateTime, pbuf_ain[AIN_EDTM]+5, 2);
    strncat (sStartDateTime, pbuf_ain[AIN_EDTM]+8, 2);
    strncat (sStartDateTime, pbuf_ain[AIN_EDTM]+11, 2);
    strncat (sStartDateTime, pbuf_ain[AIN_EDTM]+14, 2);
    strncat (sStartDateTime, pbuf_ain[AIN_EDTM]+17, 2);
    if ( !IsValid_YYYYMMDDHHMMSS (sStartDateTime) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| event_date_time(%s) expected (YYYY/MM/DD-hh-mm-ss.tt)\n", glb_Eindex, pbuf_ain[AIN_EDTM]);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008 */
    if ( strncmp(sStartDateTime, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
            glb_Eindex, pbuf_ain[AIN_EDTM], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }
    //Seize_time = Calc_SeizeTime (sStartDateTime, sStartDateTime+8);
    //sprintf(voice_event.time_key, "%010ld", Seize_time);
    sprintf(voice_event.time_key, "%s", sStartDateTime);
    strncpy(glb_CurCDRDate, sStartDateTime, SIZE_YYYYMMDD);
    strcpy(glb_CurCDRTime,  sStartDateTime+SIZE_YYYYMMDD);

    /* Duration in Seconds */
    sprintf(voice_event.duration, "%06d", Duration);

    /* if duration is < glb_AinMin_Duration seconds Reject the CDR. */
    if ( Duration < glb_AinMin_Duration) {
        fputs (raw_input, glb_RCdrfp);          /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Less_Duration|Duration < %ld| duration(%s)\n", glb_Eindex, glb_AinMin_Duration, pbuf_ain[AIN_DURA]);
        glb_DuraCtr++;
        return FAILURE;
    }

    /* Country Code Called */
    strcpy(voice_event.country_code, "66");     /* default for Thailand */
    switch ( Parse_Country(voice_event.to_number, voice_event.country_code, &Rate_Pm) ) {
        case SUCCESS :
        case PARSE_MUL_MATCH :
            break;
        case PARSE_NOT_MATCH :
        case FAILURE :
            fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, voice_event.to_number);
            //memset(voice_event.country_code, SPACE_CHAR, sizeof (voice_event.country_code)-1); /* reset */
            glb_ErrCtr++;
            return FAILURE;
    }

    /* Area Code Called */
    /* No Area Code - Always Blank */
    /* memset(voice_event.area_code, SPACE_CHAR, sizeof(voice_event.area_code)-1); */

    /* Cell Location */
    memset(voice_event.cell, SPACE_CHAR, sizeof(voice_event.cell)-1);
    memset(voice_event.cell_set, SPACE_CHAR, sizeof(voice_event.cell_set)-1);
    memset(voice_event.cell_area, SPACE_CHAR, sizeof(voice_event.cell_area)-1);

    /* CDR Categories */
    iCategories |= CAT_TOTAL|CAT_VOICE; /* Set to Total Category and Voice Category */
    iCategories |= CAT_IDD;             /* Set to AIN International Category */
    strcpy(voice_event.direction, OUTGOING);
    // iCategories |= CAT_OUTGOING;        /* Set to Outgoing Call Category, All Call is Outgoing call */
    // if ( strcmp(pbuf_ain[AIN_ETID], "102") == 0 ) {
    //     iCategories |= CAT_INCOMP_CALL;     // incomplete call category for AIN - added by Thanakorn on Aug-2016
    // }

    sprintf(voice_event.categories, "%08d", iCategories);

    /* Features used during the call */
    if ( !strcmp(pbuf_ain[AIN_MT], "CF") ) {   /* MFC */
        iFeature |= FEAT_FORWARD;   /* Call forward call */
    }
    sprintf(voice_event.features, "%010d", iFeature);

    /* Always Skip Velocity check, since don't have cell information */
    /* szDetParams |= SKIP_ACCUM_PATTERN; */       /* skip accumulator pattern */
    /* szDetParams |= SKIP_DEST; */                /* skip destination check */
    /* szDetParams |= SKIP_DEST_USAGE; */          /* skip destination usage */
    /* szDetParams |= SKIP_PATTERN; */             /* skip pattern check */
    /* szDetParams |= SKIP_SEQ_PATTERN; */         /* skip sequence pattern check */
    /* szDetParams |= SKIP_SUSP; */                /* skip suspension check */
    /* szDetParams |= SKIP_THRESHOLD; */           /* skip threshold check */
    /* szDetParams |= SKIP_USAGEACCUM; */         /* skip usage accumulation */
    /* szDetParams |= SKIP_DUPEVENT; */           /* skip duplicate event check */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_AUTHORIZEDFEATURE]);       /* skip authorized feature */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_BLACKLIST]);                /* skip black list */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_IMMEDIATEROAM]);           /* skip immediate roam check */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_UNKNOWN]);                  /* skip unknown entity */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_PREMATURECHANGE]);         /* skip premature change check */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_ROAMNOHOME]);              /* skip roam no home check */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);                /* skip collision */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);                 /* skip velocity */

    strcpy(voice_event.detect_params, szDetParams);
    strcpy(voice_event.original_bno, glb_OriginalBno);
    strcpy(voice_event.event_src, glb_EventSource);

    if ( iCategories & CAT_IDD ) {  // Added by Thanakorn
        glb_EventId = VOICE_EVENT_TYPE_IDD; // Actually it's voice event but just for categorize Priority Tube by IUM)
    }

    return SUCCESS;
}

/* Added Gprs_To_Data_Event function - by Jetsada on 08-Aug-2005 */
int Gprs_To_Data_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Gprs_To_Data_Event");
    _p_ = 0;
#endif
    char sApn[64+1];
    int  i;
    /* initialize Common Structure buffer for each CDR */
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&data_event, 0x00, sizeof (data_event));
    memset(sApn, 0x00, sizeof(sApn));

    if ( !strcmp(pbuf_gprs[GPR_REC_TYPE],"18") ||   /* Added by Watthikorn on 24-May-2010 */
         !strcmp(pbuf_gprs[GPR_REC_TYPE],"19") ||   /* 18 -> for SGSN. 19,70,225 -> for GGSN. */
         !strcmp(pbuf_gprs[GPR_REC_TYPE],"70") ||   /* Added rec_type 19,70,225 by N.Thanakorn on 17-Oct-2013 */
         !strcmp(pbuf_gprs[GPR_REC_TYPE],"225") ) {

        /* convert access point name to lower case before check mapping */
        for( i =0; i < strlen(pbuf_gprs[GPR_APN_NI]); i++)
            sApn[i] = tolower(pbuf_gprs[GPR_APN_NI][i]);
        Trim_Str(sApn);

        if ( !Parse_Apn(pbuf_gprs[GPR_REC_TYPE], sApn) ) {
            fprintf(glb_Ignfp, "[DET] %s|APN|APN %s| rec_type(%s) match apn table\n", glb_Eindex, pbuf_gprs[GPR_APN_NI], pbuf_gprs[GPR_REC_TYPE]);
            fputs(raw_input, glb_RCdrfp);  /* reject the gprs cdr record type as 18 and apn found  APN Table */
            glb_IgnCtr++;
            return FAILURE;
        }
        else {
            return (Gprs_To_Data_Event_18());
        }
    }
    else {
        fputs(raw_input, glb_RCdrfp);  /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, pbuf_gprs[GPR_REC_TYPE]);
        glb_IgnCtr++;
        return FAILURE;
    }
}

/* Added DpcGprs_To_Data_Event by Thanakorn on 19-Feb-2011 */
int DpcGprs_To_Data_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> DpcGprs_To_Data_Event");
    _p_ = 0;
#endif
    char sNetOrig[SIZE_NET+1];
    char sCostgroupId[SIZE_COSTGROUP_ID+1];
    char sCostbandId[SIZE_COSTBAND_ID+1];
    char sVolume[21+1];
    char sApn[64+1];
    int  i;

    //time_t  Seize_time = 0;     // Seize Time in Seconds

    double dwUplinkVolume = 0.0;
    double dwDownlinkVolume = 0.0;

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    memset(sNetOrig, 0x00, sizeof(sNetOrig));
    memset(sCostgroupId, 0x00, sizeof(sCostgroupId));
    memset(sCostbandId, 0x00, sizeof(sCostbandId));
    memset(sVolume, 0x00, sizeof(sVolume));
    memset(sApn, 0x00, sizeof(sApn));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    // initialize Common Structure buffer for each CDR
    memset(&com_buf, 0x00, sizeof(com_buf));
    memset(&data_event, 0x00, sizeof(data_event));

    if ( !glb_DpcInstFlag) {    // Not Included AIS Installation
        fputs(raw_input, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_GPRS] == 0 ) {
        // Reject BOS online record, added by Thanakorn on 26-Aug-2013
        // ignore Charging Charateristic (CC) = 1 (Hot Billing BOS)
        if ( atoi(pbuf_gprs[GPR_CHG_CHAR]) == 1 ) {
            fputs(raw_input, glb_RCdrfp);   // reject the GPRS Trailer
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| chg_char(%s)\n", glb_Eindex, pbuf_gprs[GPR_CHG_CHAR]);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    // convert access point name to lower case
    for( i =0; i < strlen(pbuf_gprs[GPR_APN_NI]); i++)
        sApn[i] = tolower(pbuf_gprs[GPR_APN_NI][i]);
    Trim_Str(sApn);

    if ( !strcmp(pbuf_gprs[GPR_REC_TYPE], "18") ) { // Added by Watthikorn on 24-May-2010
        if ( !Parse_Apn(pbuf_gprs[GPR_REC_TYPE], sApn)){
            fprintf(glb_Ignfp, "[DET] %s|APN|APN %s| rec_type(%s) match apn table\n", glb_Eindex, pbuf_gprs[GPR_APN_NI], pbuf_gprs[GPR_REC_TYPE]);
            fputs(raw_input, glb_RCdrfp);   // reject the gprs cdr record type as 18 and apn found  APN Table
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    if ( strcmp(pbuf_gprs[GPR_REC_TYPE], "18") ) {
        fputs(raw_input, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, pbuf_gprs[GPR_REC_TYPE]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( strncasecmp (pbuf_gprs[GPR_APN_NI], "EDGE", 4) ) {
        fputs(raw_input, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Errfp, "[DET] %s:|Field|APN| apn(%s)\n", glb_Eindex, pbuf_gprs[GPR_APN_NI]);   // need_to_check
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strncmp(pbuf_gprs[GPR_SRV_IMSI], "52023", 5) ) {
        fputs(raw_input, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Errfp, "[DET] %s|Field|IMSI| invalid imsi(%s)\n", glb_Eindex, pbuf_gprs[GPR_SRV_IMSI]);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Event Type
    glb_EventId = DATA_EVENT_TYPE;  // Data Event Type
    sprintf(data_event.event_type, "%02d", glb_EventId);

    // map a_no (calling_number)
    if ( Conv_Gprs_Ano())
        return FAILURE;

    // Service Num
    strncpy(data_event.mobile_num, com_buf.a_no, 16);

    // From Number
    strncpy(data_event.from_number, com_buf.a_no, 18);

    if ( !IsValid_YYYYMMDD_HHMMSS (pbuf_gprs[GPR_REC_OPEN_DATE], pbuf_gprs[GPR_REC_OPEN_TIME]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| open_date(%s) open_time(%s)\n",
            glb_Eindex, pbuf_gprs[GPR_REC_OPEN_DATE], pbuf_gprs[GPR_REC_OPEN_TIME]);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008
    if ( strncmp(pbuf_gprs[GPR_REC_OPEN_DATE], glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fputs(raw_input, glb_RCdrfp);   // reject the GPRS Trailer
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n",
            glb_Eindex, pbuf_gprs[GPR_REC_OPEN_DATE], pbuf_gprs[GPR_REC_OPEN_TIME], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // Time Key
    //Seize_time = Calc_SeizeTime (pbuf_gprs[GPR_REC_OPEN_DATE], pbuf_gprs[GPR_REC_OPEN_TIME]);
    //sprintf(data_event.time_key, "%010ld", Seize_time);
    sprintf(data_event.time_key, "%s%s", pbuf_gprs[GPR_REC_OPEN_DATE], pbuf_gprs[GPR_REC_OPEN_TIME]);

    // Duration
    strcpy(data_event.duration, "000000");

    // Volume1(FRM), Total Volume in bytes
    dwUplinkVolume = ceil((atof(pbuf_gprs[GPR_VOL_UP_LINK])/1024.0));       // Convert Uplink Volume to Kbytes
    dwDownlinkVolume = ceil((atof(pbuf_gprs[GPR_VOL_DW_LINK])/1024.0));     // Convert Downlink Volume to Kbytes
    sprintf(sVolume, "%010.0lf", dwUplinkVolume+dwDownlinkVolume);          // Calculate Total Volume
    strncpy(data_event.vol_total, sVolume+strlen(sVolume)-10 , 10);         // Copy only last 10 Chars to vol_total

    // Charge
    //
    // DPC GPRS Volume base charge rate is 1000 satang / 1Mbytes
    // Unit in satang
    //
    sprintf(data_event.charge, "%010.0lf", (dwUplinkVolume + dwDownlinkVolume) * 1000);

    //
    // Originating Cell, Cell Set and Cell Area Mapping from Raw cdr.
    //
    // In the new CGI,      LAC is 5 digits in decimal format and is from 6th digit of the cell_id_a
    //                      CI is 5 digits in decimal format and is last 5 digits of the cell_ida
    //                      - Kawee 20-Mar-2003
    //
    // Cell      - Since, CI in SSP is always "00000". Thus copy five space chars to cell.
    //             (In General Take last 5 chars (11,12,13,14,15) of cell_id_a from raw cdr.
    //             This is of Decimal value (CI).  Assign this value to FIT Cell.)
    //
    // Cell Set  - Take 5 chars from 6th (6,7,8,9,10) of cell_id_a from raw cdr.  This is of Decimal value (LAC).
    //             Assign this value to FIT Cell Set.
    //
    // Cell Area - Take 2 chars from 8th (8,9) of cell_id_a field from raw cdr. (This is province)
    //             Prefix 0(s) to make it 5 chars.  Assign this value to FIT Cell Area.
    //

    // Cell
#if 0
    strncpy(data_event.cell, pbuf_gprs[GPR_CELL_ID]+11-1, 5);

    // Cell Set
    strncpy(data_event.cell_set, pbuf_gprs[GPR_CELL_ID]+6-1, 5);

    // Cell Area
    strcpy(data_event.cell_area, "000");
    strncpy(data_event.cell_area+3, pbuf_gprs[GPR_CELL_ID]+8-1, 2);
#endif

    if ( Get_GeoData(pbuf_gprs[GPR_CELL_ID], data_event.cell, data_event.cell_set, data_event.cell_area) != SUCCESS ) {
        fprintf(glb_Errfp, "[DET] %s|GeoMapp|Cell_IDA| cell_id_a(%s) but not skip\n", glb_Eindex, pbuf_gprs[GPR_CELL_ID]);
        strcpy(data_event.cell_area, DEF_CELL_AREA);
    }


    // CDR Categories
    iCategories |= CAT_DATA|CAT_LOCAL;     // Set to Total, GPRS and Outgoing Category
    sprintf(data_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    //
    // Since AIS have Multi-SIM Service, one phone number can have mulitple SIM with different IMSI.
    // Thus, Skip both Velocity and Collision.
    // - Kawee 21-Oct-2005
    //
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         // Always skip velocity check for gprs
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        // Always skip collision check for gprs
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        // skip duplication check for non voice events
    strcpy(data_event.detect_params, szDetParams);

    // ----- not yet mapping fields -----
    // data_event.pre_disc
    // data_event.remarks
    // ----- not yet mapping fields -----

    // Added by Wiraphot on 14-Jan-2009
    // memset(data_event.servpackid, SPACE_CHAR, sizeof(data_event.servpackid)-1); // Copy Blank to Service Package Id
    strcpy(data_event.event_src, glb_EventSource);
    strcpy(data_event.partition_id, AWN_PARTITION);

    return SUCCESS;
}

/* Added Gprst_To_Data_Event function - by Jetsada on 08-Aug-2005 */
int Gprst_To_Data_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Gprst_To_Data_Event");
    _p_ = 0;
#endif
    /* initialize Common Structure buffer for each CDR */
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&data_event, 0x00, sizeof (data_event));

    /* added by thanakorn on 24-Jun-2013 */
    if ( strcmp(gprst_buf.cos, "51") &&             /* GSM */
         strcmp(gprst_buf.cos, "31") &&             /* DPC */
         strcmp(gprst_buf.cos, "600001") &&         /* AWN Postpaid */
         strcmp(gprst_buf.cos, "600002") &&         /* AWN Postpaid */
         strcmp(gprst_buf.cos, "600003") &&         /* AWN Postpaid */
         strcmp(gprst_buf.cos, "600004") &&         /* AWN Postpaid */
         strcmp(gprst_buf.cos, "600005") &&         /* AWN Postpaid */
         strcmp(gprst_buf.cos, "600007") &&         /* AWN MVPN Postpaid */
         strcmp(gprst_buf.cos, "906") &&            /* AWN Postpaid */
         strcmp(gprst_buf.cos, "909") &&            /* AWN Postpaid */
         strcmp(gprst_buf.cos, "214") ) {           /* AWN Postpaid */
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp);   /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|COS|COS %s\n", glb_Eindex, gprst_buf.cos);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp(gprst_buf.record_type, "bcudr") ) {
        return Gprst_To_Data_Event_Bcudr();
    }
    else {
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp); /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, gprst_buf.record_type);
        glb_IgnCtr++;
        return FAILURE;
    }
}

// Added Mms_To_Mms_Event function - by Jetsada on 09-Aug-2005
int Mms_To_Mms_Event ()
{
    // initialize Common Structure buffer for each CDR
    memset(&com_buf, 0x00, sizeof(com_buf));
    memset(&mms_event, 0x00, sizeof(mms_event));
    memset(&sms_event, 0x00, sizeof(sms_event));

    // added by thanakorn on 24-Jun-2013
    if ( strcmp(mms_buf.scos, "51") &&          // GSM
         strcmp(mms_buf.scos, "31") &&          // DPC
         strcmp(mms_buf.scos, "600001") &&      // AWN Postpaid
         strcmp(mms_buf.scos, "600002") &&      // AWN Postpaid
         strcmp(mms_buf.scos, "600003") &&      // AWN Postpaid
         strcmp(mms_buf.scos, "600004") &&      // AWN Postpaid
         strcmp(mms_buf.scos, "600005") &&      // AWN Postpaid
         strcmp(mms_buf.scos, "600007") &&      // AWN MVPN Postpaid
         strcmp(mms_buf.scos, "906") &&         // AWN Postpaid
         strcmp(mms_buf.scos, "909") &&         // AWN Postpaid
         strcmp(mms_buf.scos, "214") ) {        // AWN Postpaid
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Ignfp, "[DET] %s|COS|COS %s\n", glb_Eindex, mms_buf.scos);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp (mms_buf.record_type, "tcudr") ) {
        return (Mms_To_Mms_Event_Tcudr());
    }
    else {
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // a new record type - reject
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, mms_buf.record_type);
        glb_IgnCtr++;
        return FAILURE;
    }
}

/* Added Rbt_To_Rbt_Event function - by Jetsada on 09-Aug-2005 */
int Rbt_To_Rbt_Event ()
{
    //unsigned int    Duration = 0;   /* Duration */
    //time_t      Seize_time = 0; /* Seize Time in Seconds */
    unsigned long   iCharge = 0;
    char        sCostCode[128];
    char        sCostBandId[32];
    char        sFixedChgMny[SIZE_FIXED_CHARGE+1];  /* Size for Keep long Value */
    char        sChargeRate[SIZE_CHARGE_RATE+1];    /* Size for Keep long Value */
    char        sBandingModelId[2+1];
    char        sRatingTariffId[2+1];

    //int Ano_len = strlen(pbuf_rbt[RBT_MSISDN]);

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    memset(sCostCode, 0x00, sizeof(sCostCode));
    memset(sCostBandId, 0x00, sizeof(sCostBandId));
    memset(sFixedChgMny, 0x00, sizeof(sFixedChgMny));
    memset(sChargeRate, 0x00, sizeof(sChargeRate));
    memset(sBandingModelId, 0x00, sizeof(sBandingModelId));
    memset(sRatingTariffId, 0x00, sizeof(sRatingTariffId));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    /* initialize Common Structure buffer for each CDR */
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&rbt_event, 0x00, sizeof (rbt_event));

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_RBT] == 0 ) {
        /* Reject BOS online record, added by Thanakorn on 26-Aug-2013 */
        /* ignore inflag = 3, 4,5 and 6:
        //    3�-> BOS-2G Postpaid
        //    4 -> BOS-2G Prepaid
        //    5 -> BOS-3G Postpaid
        //    6 -> BOS-3G Prepaid
        */
        if ( atoi(pbuf_rbt[RBT_INFLG]) >= 3 && atoi(pbuf_rbt[RBT_INFLG]) <= 6 ) {
            fputs(raw_input, glb_RCdrfp);
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| in_flag(%s)\n", glb_Eindex, pbuf_rbt[RBT_INFLG]);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    if ( strcmp(pbuf_rbt[RBT_EVT], "0") &&      /* Not Activating RBT Service */
         strcmp(pbuf_rbt[RBT_EVT], "3") &&      /* Not Modifying RBT Ring */
         strcmp(pbuf_rbt[RBT_EVT], "5") &&      /* Not Music station selection */
         strcmp(pbuf_rbt[RBT_EVT], "6") &&      /* Not Music station extension */
         strcmp(pbuf_rbt[RBT_EVT], "I") &&
         strcmp(pbuf_rbt[RBT_EVT], "J") ) {
        fputs(raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Field|Event_Type| event_type(%s)\n", glb_Eindex, pbuf_rbt[RBT_EVT]);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_rbt[RBT_INFLG], "2") ) {   /* Not MF RTBS Subscriber */
        fputs(raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Field|INFlag| in_flag(%s)\n", glb_Eindex, pbuf_rbt[RBT_INFLG]);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_rbt[RBT_EVT], "0") &&      /* Not Activating RBT Service */
         !strlen(pbuf_rbt[RBT_RGNO]) ) {        /* RingNo blank */
        fputs(raw_input, glb_RCdrfp);
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Blank| event_type(%s)\n", glb_Eindex, pbuf_rbt[RBT_EVT]);
        glb_ErrCtr++;
        return FAILURE;
    }
    glb_EventId = VAS_EVENT_TYPE;

    /* map service number */
    if ( Conv_Ano(pbuf_rbt[RBT_MSISDN], rbt_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( strlen(rbt_event.mobile_num) < SIZE_PHONENO) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, rbt_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* From Mobile Number */
    strcpy(rbt_event.from_number, rbt_event.mobile_num);

    /* Ring Number requested */
    strcpy(rbt_event.ring_no, pbuf_rbt[RBT_RGNO]);

    strcpy(rbt_event.cos_id, pbuf_rbt[RBT_COS]);

    /* Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007 */
    if ( !IsValid_YYYYMMDDHHMMSS (pbuf_rbt[RBT_TRT]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date_time(%s)\n",
                glb_Eindex, pbuf_rbt[RBT_TRT]);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008 */
    if ( strncmp(pbuf_rbt[RBT_TRT], glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fputs(raw_input, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
                glb_Eindex, pbuf_rbt[RBT_TRT], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    /* Seize Time & Date */
    //Seize_time = Calc_SeizeTime(pbuf_rbt[RBT_TRT], pbuf_rbt[RBT_TRT]+SIZE_YYYYMMDD);
    //sprintf(rbt_event.time_key, "%010ld", Seize_time);
    sprintf(rbt_event.time_key, "%s", pbuf_rbt[RBT_TRT]);

    /* Charge */
    if ( !strcmp(pbuf_rbt[RBT_EVT], "0") ) {    /* Activate RBT Service */
        iCharge = 3000;                         /* Fixed Charge 30 Baht (3000 Satang) */
    }
    else {
        strcpy(sBandingModelId, "4");
        strcpy(sCostCode, "RBT");           /* Fixed Costcode = RBTx */
        strncpy(sCostCode+3,pbuf_rbt[RBT_RGNO], 1); /* x = First Character of Ring No */
        strcpy(sRatingTariffId, "7");

        if ( Get_RmCostBandId(sBandingModelId, sCostCode, sCostBandId) ) {  /* FAILURE */
            fputs(raw_input, glb_RCdrfp);
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Code| banding_model_id(%s) costcode(%s)\n", glb_Eindex, sBandingModelId, sCostCode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( Get_VasGroupCodeByGrpName(gszCostcode_Desc, rbt_event.vas_grp) != SUCCESS ) {
            Get_VasGroupCodeByGrpName(gszCostcode_Name, rbt_event.vas_grp);
        }

        if ( Parse_RatingElement2(sRatingTariffId, sCostBandId, sFixedChgMny, sChargeRate) ) {
            fputs(raw_input, glb_RCdrfp);
            fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s)\n", glb_Eindex, sRatingTariffId, sCostBandId);
            glb_ErrCtr++;
            return FAILURE;
        }

        if ( !sChargeRate[0] || !strcmp(sChargeRate, "0") ) {   /* Null or Zero */
            if ( !sFixedChgMny[0] ) {   /* Null */
                iCharge = 0;
            }
            else {
                iCharge = atol(sFixedChgMny) / 10;  /* Satang Unit */
            }
        }
        else {
            iCharge = atol(sChargeRate) / 1000;     /* Satang Unit */
        }
    }
    sprintf(rbt_event.charge, "%010ld", iCharge);   /* Use IN Charge Rate */

    /* Ring Type */
    strcpy(rbt_event.ring_type, rbt_event.event_type);

    /* Operation Source */
    *rbt_event.op_source = *pbuf_rbt[RBT_SRC];

    /* CDR Categories */
    /* Added "VasOrPremium" Category - Changed as below by Kawee on 22-Mar-2007 */
    /* iCategories |= CAT_TOTAL|CAT_VAS|CAT_OUTGOING; */    /* Set to Total, VAS, and Outgoint Category */
    strcpy(voice_event.direction, OUTGOING);

    /* Set to Total, VAS, VAS_OR_PREMIUM, and Outgoint Category */
    iCategories |= CAT_TOTAL|CAT_VAS|CAT_LOCAL;
    sprintf(rbt_event.categories, "%08d", iCategories);

    /* Detection Skip Parameters */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);         /* Always skip collision check for RBT */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);          /* Always skip velocity check for RBT */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);          /* skip duplication check for non voice events */
    strcpy(rbt_event.detect_params, szDetParams);

    return (CommonVas_To_Vas_Event(glb_MtxInd, (void *)&rbt_event));

}

/*------------------------------------------------------------------------------------*/

/* Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007 */
int Gsm_To_Event ()
{
    /* Feed This CDR only included AIS Installation - Kawee on 29-Dec-2005 */
    if ( !glb_AisInstFlag ) {     /* Not Included AIS Installation */
        fputs(raw_gsm, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp(gsm_buf.record_type, "10") ) {  /* Header Record */
        fputs(raw_gsm, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, gsm_buf.record_type);
        //glb_IgnCtr++;
        return FAILURE;
    }
    else if ( !strcmp(gsm_buf.record_type, "90") ) { /* Trailer Record */
        fputs(raw_gsm, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, gsm_buf.record_type);
        //glb_IgnCtr++;
        return FAILURE;
    }
    else if ( !strcmp(gsm_buf.record_type, "20") || !strcmp(gsm_buf.record_type, "40") ||   /* Voice CDR */
              !strcmp(gsm_buf.record_type, "26") || !strcmp(gsm_buf.record_type, "45") ||   /* Support 3G */
              !strcmp(gsm_buf.record_type, "24") || !strcmp(gsm_buf.record_type, "43") ) {  /* Request by K.Nopporn */
        return (Gsm_To_Voice_Event());
    }
    else if ( !strcmp(gsm_buf.record_type, "81") ) { /* Dropped Record Type */
        fputs(raw_gsm, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, gsm_buf.record_type);
        glb_IgnCtr++;
        return FAILURE;
    }
    /* // removed by Thanakorn on 04-Sep-2013, because they will only use of FDA and SMSC
    else if ( !strcmp(gsm_buf.record_type, "71") || !strcmp(gsm_buf.record_type, "21") ||
             !strcmp(gsm_buf.record_type, "77") ) {     // Support 3G
        return (Gsm_To_Sms_Event());
    }
    */
    else {
        fputs(raw_gsm, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, gsm_buf.record_type);
        glb_IgnCtr++;
        return FAILURE;
    }
}

int Awn_To_Event ()
{
    /* Feed This CDR only included AWN Installation - Kawee on 29-Dec-2005 */
    if ( !glb_AisInstFlag) {     /* Not Included Awn Installation */
        fputs(raw_gsm, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp(gsm_buf.record_type, "10") ) {  /* Header Record */
        fputs(raw_gsm, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, gsm_buf.record_type);
        //glb_IgnCtr++;
        return FAILURE;
    }
    else if ( !strcmp(gsm_buf.record_type, "90") ) { /* Trailer Record */
        fputs(raw_gsm, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, gsm_buf.record_type);
        //glb_IgnCtr++;
        return FAILURE;
    }
    else if ( !strcmp(gsm_buf.record_type, "22") ||     /*  Mobile Originated Call , Calling no. is AWN  */
             !strcmp(gsm_buf.record_type, "23") ||      /*  Mobile Originated Call , Calling no. is AWN, IR, NR in AWN network  */
             !strcmp(gsm_buf.record_type, "24") ||      /*  Mobile Originated Call TOT Roam  */
             !strcmp(gsm_buf.record_type, "41") ||      /*  Mobile Forwarded Call, Calling no. is AWN  */
             !strcmp(gsm_buf.record_type, "42") ||      /*  Mobile Forwarded Call, Calling no. is AWN in AWN network  */
             !strcmp(gsm_buf.record_type, "43") ||      /*  Mobile Forwarded Call TOT Roam */
             !strcmp(gsm_buf.record_type, "27") ||      /*  Mobile Originated Call , Calling no. is AIS in AWN network  */
             !strcmp(gsm_buf.record_type, "46") ||      /*  Mobile Forwarded Call, Calling no. is AIS in AWN network  */
             !strcmp(gsm_buf.record_type, "54") ) {     /*  Mobile Terminated Call for Maritime CDR, Added by N.Thanakorn on 26-Jun-2014; Maritime  */
        return Gsm_To_Voice_Event();        /* Voice CDR */
    }
    /* // removed by Thanakorn on 04-Sep-2013, because they will only use of FDA and SMSC
    else if ( !strcmp(gsm_buf.record_type, "73") ||     // Mobile Originated SMS, Calling no. is AWN Originated SMS (via non-AWN SMSC) and roaming in AIS network
             !strcmp(gsm_buf.record_type, "74") ||     //  Mobile Originated SMS, Calling no. is AWN Originated SMS (via non-AWN SMSC) in AWN network
             !strcmp(gsm_buf.record_type, "75") ||
             !strcmp(gsm_buf.record_type, "78") ) {    //  Mobile Originated SMS, Calling no. is AIS Originated SMS (via non-AIS SMSC) in AWN network
    */
    else if ( !strcmp(gsm_buf.record_type, "75") ) {
        return (Gsm_To_Sms_Event());           /* SMS CDR */
    }
    else {
        fputs(raw_gsm, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, gsm_buf.record_type);
        glb_IgnCtr++;
        return FAILURE;
    }
}

/*------------------------------------------------------------------------------------*/
/* Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007 */
int Gsm_To_Voice_Event ()
{
#ifdef _PRNT_FUNC_CALL_     // using verification done
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Gsm_To_Voice_Event");
    _p_ = 0;
#endif
    if ( glb_MtxInd == AWN_TYPE || glb_MtxInd == OCSVPN_TYPE ) {
        return (CommonVoice_To_Voice_Event("AWN", (VOICE_RECORD *)&gsm_buf, SIZE_GSMRAW, raw_gsm));
    }
    else {
        return (CommonVoice_To_Voice_Event("GSM", (VOICE_RECORD *)&gsm_buf, SIZE_GSMRAW, raw_gsm));
    }
}

/*------------------------------------------------------------------------------------*/

int Gsm_To_Sms_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Gsm_To_Sms_Event");
    _p_ = 0;
#endif
    //int Ano_len = strlen(gsm_buf.a_no);
    double      Charge = 0.0;
    //unsigned int    Duration = 0;   // Duration
    //time_t      Seize_time = 0;     // Seize Time in Seconds

    int iCategories = 0;
    //int iFeature = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    char net_orig[SIZE_NET+1];
    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    char costcode_name[SIZE_COSTCODE_NAME+1];
    char costgroup_id1[SIZE_COSTGROUP_ID+1];
    char costgroup_id2[SIZE_COSTGROUP_ID+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char rating_catalogue_id[SIZE_RATING_CATALOGUE_ID+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    char actual_rec_type[SIZE_ACTUAL_REC_TYPE+1];

    memset(net_orig, 0x00, sizeof(net_orig));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(costcode_name, 0x00, sizeof(costcode_name));
    memset(costgroup_id1, 0x00, sizeof(costgroup_id1));
    memset(costgroup_id2, 0x00, sizeof(costgroup_id2));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(rating_tariff_id, 0x00, sizeof(rating_tariff_id));
    memset(rating_catalogue_id, 0x00, sizeof(rating_catalogue_id));
    memset(fix_charge_mny, 0x00, sizeof(fix_charge_mny));
    memset(charge_rate, 0x00, sizeof(charge_rate));
    memset(actual_rec_type, 0x00, sizeof(actual_rec_type));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    // initialize Common Structure buffer for each CDR
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&sms_event, 0x00, sizeof (sms_event));

    // Feed This CDR only included AIS Installation - Kawee on 29-Dec-2005
    if ( !glb_AisInstFlag) {            // Not Included AIS Installation
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strncmp(gsm_buf.service_id, "12", 2) ) {      // Free of Charge
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Non_Charge|Service_ID %s| b_no(%s)\n", glb_Eindex, gsm_buf.service_id, gsm_buf.b_no);
        glb_IgnCtr++;
        return FAILURE;
    }
    // Event Type
    glb_EventId = SMS_EVENT_TYPE;   // SMS Event Type
    sprintf(sms_event.event_type, "%02d", glb_EventId);

    // Service Number
    // map a_no
    if ( Conv_Gsm_Ano())
        return FAILURE;

    strncpy(sms_event.mobile_num, com_buf.a_no, 16);
#ifdef DEBUG_ANO    // Use this for debug only
printf ("GSM ano=%-30s => %s\n", gsm_buf.a_no, sms_event.mobile_num);
#endif

    // Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
    if ( Get_Service("GSMCDR", gsm_buf.service_key, gsm_buf.fci, net_orig) &&
        Get_Service("GSMCDR", gsm_buf.service_key, "*", net_orig) ) {
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        fprintf(glb_Errfp, "[DET] %s|Field|FCI| service_key(%s) fci(%s)\n", glb_Eindex, gsm_buf.service_key, gsm_buf.fci);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_SMS] == 0 ) {
        // in voice cdr there is a field indicates that bos online or offline,
        // so even if configured to feed only MD cdr but if bos offline flag is turned on
        // means that this cdr can be fed to FMS since it's missing from BOS side
        // Reject BOS online record, added by Thanakorn on 26-Aug-2013
        if ( !strcmp(net_orig, "BOS") ) {
            if ( gsm_buf.dual_serv_type == '1' ) {  // reject only BOS online cdr (1 = Up, 0 = Down)
                fputs(raw_gsm, glb_RCdrfp);     // reject the record
                fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| network_origin(%s) service_key(%s) fci(%s)\n", glb_Eindex, net_orig, gsm_buf.service_key, gsm_buf.fci);
                glb_IgnCtr++;
                return FAILURE;
            }
        }
    }

    if ( strcmp(net_orig, "GSM") ) {    // Net is not Postpaid (GSM)
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        fprintf(glb_Errfp, "[DET] %s|Field|Network| network_origin(%s) service_key(%s) fci(%s)\n", glb_Eindex, net_orig, gsm_buf.service_key, gsm_buf.fci);
        glb_ErrCtr++;
        return FAILURE;
    }
    // From Mobile Number
    strncpy(sms_event.from_number, com_buf.a_no, 18);

    // To Mobile Number
    // map b_no
    if ( Conv_Gsm_Bno() )
        return FAILURE;

    strncpy(sms_event.to_number, com_buf.b_no, 18);
    Conv_RealBno(sms_event.to_number, sms_event.bno);   // get exact bno (without any access code)

#ifdef DEBUG_BNO    // Use this for debug only
printf ("GSM bno=%-30s => %s\n", gsm_buf.b_no, sms_event.to_number);
#endif

    // Introduced AIN - Added below by Kawee on 04-Jan-2007
    if ( !strncmp(sms_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||    // AIN 3rd Product Intl - Added by Kawee on 11-Nov-2009
         !strncmp(sms_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||    // AIN 2nd Product Intl - Added by Kawee on 25-Aug-2008
         !strncmp(sms_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||    // AIN Intl
         !strncmp(sms_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
         !strncmp(sms_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
         !strncmp(sms_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {   // AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Send_SMS_AIN_Number|AIN_Number %s\n", glb_Eindex, gsm_buf.b_no);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
    if ( !IsValid_YYYYMMDD_HHMMSS (gsm_buf.start_date, gsm_buf.start_time) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date(%s) start_time(%s)\n",
            glb_Eindex, gsm_buf.start_date, gsm_buf.start_time);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008
    if ( strncmp(gsm_buf.start_date, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n",
            glb_Eindex, gsm_buf.start_date, gsm_buf.start_time, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // Seize Time & Date
    //Seize_time = Calc_SeizeTime (gsm_buf.start_date, gsm_buf.start_time);
    //sprintf(sms_event.time_key, "%010ld", Seize_time);
    sprintf(sms_event.time_key, "%s%s", gsm_buf.start_date, gsm_buf.start_time);

    // Direction
    strcpy(sms_event.direction, INCOMING);  // Incoming Call

    // Country Code Called
    strcpy(sms_event.country_code, "66");   // Default for Thailand

    // SMS Type
    // strcpy(sms_event.sms_type, gsm_buf.record_type);

    // CDR Categories
    iCategories |= CAT_TOTAL|CAT_SMS|CAT_LOCAL;   // Set to Total Category and SMS Category
    sprintf(sms_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);    // Always skip collision check for sms
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);     // Always skip velocity check for sms
    strcpy(sms_event.detect_params, szDetParams);

    // Charge in Satang
    Charge = 0.0;
    strcpy(banding_model_id, "3");

    strcpy(costcode, "AIS");    // as cell_id_a
    if ( Get_RmCostGroupId(banding_model_id, costcode, costgroup_id2) ) {
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| cell_ida(%s)\n", glb_Eindex, costcode);
        glb_ErrCtr++;
        return FAILURE;
    }

    strcpy(costcode, "SMS");    // as cell_id_b
    if ( Get_RmCostGroupId(banding_model_id, costcode, costgroup_id1) ) {
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( Get_XfCostBandId (banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| costgroup_id1(%s) costgroup_id2(%s)\n",
        glb_Eindex, costgroup_id1, costgroup_id2);
        glb_ErrCtr++;
        return FAILURE;
    }

    strcpy(rating_tariff_id, "5");      // Net_Orig Always 'GSM'
    strcpy(event_class_id, "21");       // For 71 Record_Type (Sent SMS)

    if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
        glb_ErrCtr++;
        Charge = 0.0;
        return FAILURE;
    }
    else {
        Charge = atof(fix_charge_mny) / 10;     // Convert to Satang
    }

    // Service_id
    strcpy(sms_event.service_id, gsm_buf.service_id);   // Just copy

    // ------------------------------------------------
    // cell_id_a is 15 digit
    //
    // position: 1 2 3 4 5  6 7 8 9 10  11 12 13 14 15
    // eg valu   2 3 4 5 6  3 4 5 6  8   5  7  9  3  1
    // ------------------------------------------------
    // CI  = 11 - 15 => Cell        -> 57931
    // LAC =  6 - 10 => Cell Set    -> 34568
    //     =  8 -  9 => Cell Area   -> 00056
    // ------------------------------------------------
#if 0
    strncpy(sms_event.cell, gsm_buf.cell_id_a+10, 5);
    strncpy(sms_event.cell_set, gsm_buf.cell_id_a+5, 5);
    strcpy(sms_event.cell_area, "000");
    strncpy(sms_event.cell_area+3, gsm_buf.cell_id_a+7, 2);
#endif
    if ( sms_event.cell_area[0] == '\0' ) {
        if ( Get_GeoData(gsm_buf.cell_id_a, sms_event.cell, sms_event.cell_set, sms_event.cell_area) != SUCCESS ) {
            fprintf(glb_Errfp, "[DET] %s|GeoMapp|Cell_IDA| cell_id_a(%s) but not skip\n", glb_Eindex, gsm_buf.cell_id_a);
            strcpy(sms_event.cell_area, DEF_CELL_AREA);
        }
    }

    // ----- not yet mapping fields -----
    // sms_event.remarks
    // sms_event.business_code
    // sms_event.pre_disc
    // sms_event.payment_type
    // sms_event.fee_charge
    // ----- not yet mapping fields -----

    strcpy(sms_event.partition_id, AWN_PARTITION);
    sprintf(sms_event.charge, "%010.0lf", Charge);
    strcpy(sms_event.original_bno, glb_OriginalBno);
    strcpy(sms_event.event_src, glb_EventSource);
    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/
/*
** Added Gprst_To_Data_Event_Bcudr function - by Jetsada on 08-Aug-2005
*/
int Gprst_To_Data_Event_Bcudr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Gprst_To_Data_Event_Bcudr");
    _p_ = 0;
#endif
    char sNetOrig[SIZE_NET+1];
    char sCostgroupId[SIZE_COSTGROUP_ID+1];
    char sCostbandId[SIZE_COSTBAND_ID+1];

    char sVolume[21+1];
    char sAccessPoint[31+128];
    //char *sTemp;

    unsigned int Duration = 0;   // Duration
    //time_t  Seize_time = 0;         // Seize Time in Seconds

    unsigned long lVolume = 0;
    unsigned long iCharge = 0;

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    double dVolRating = 0.1;       // Set default to 0.1 BAHT per KB
    char szSvcDesc[30];
    int nVolOverHeadTOT = 0;

    memset(sNetOrig, 0x00, sizeof(sNetOrig));
    memset(sCostgroupId, 0x00, sizeof(sCostgroupId));
    memset(sCostbandId, 0x00, sizeof(sCostbandId));
    memset(sVolume, 0x00, sizeof(sVolume));
    memset(sAccessPoint, 0x00, sizeof(sAccessPoint));
    memset(szSvcDesc, 0x00, sizeof(szSvcDesc));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    // Check for Reject Test Record - Added below by Kawee on 01-Feb-2006
    if ( gprst_buf.ti == '1' ) {      // Test Record
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp);   // reject the GPRST record
        fprintf(glb_Ignfp, "[DET] %s|TEST|TEST| ti(%c)\n", glb_Eindex, gprst_buf.ti);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_VSCP] == 0 ) {
        // Reject BOS online record, added by Thanakorn on 26-Aug-2013
        // ignore servpackid = 5 (5 - BOS� 2G,3G)
        if ( gprst_buf.servpackid[0] == '5' ) {
            fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp);   // reject the GPRST record
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| servpackid(%s)\n", glb_Eindex, gprst_buf.servpackid);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    // For CDR that cgrn_id (Called Party Roaming Network Id) does not "52001" is Call Outbound
    // This IR SCP GPRS Data
    if ( strncmp(gprst_buf.cgrn_id, "520", 3) && strncmp(gprst_buf.cgrn_id, "901", 3) ) {   // Call Out Bound Record
        // To be put some code here
        return (Gprst_To_IR_Event());
    }
    else {
        iCategories |= CAT_LOCAL;
    }
    // Event Type
    glb_EventId = DATA_EVENT_TYPE;  // Data Event Type
    sprintf(data_event.event_type, "%02d", glb_EventId);

    // map a_no (calling_number)
    if ( Conv_Gprst_Ano() ) {
        return FAILURE;
    }

    // Service Num
    strncpy(data_event.mobile_num, com_buf.a_no, 16);
    // Don't Feed CDR That COS=51 if not included AIS Installation - Kawee on 29-Dec-2005
    if ( !glb_AisInstFlag && !strcmp(gprst_buf.cos, "51") ) {   // Not Included AIS Installation
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp);   // reject the GPRST record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Don't Feed CDR That COS=31 if not included DPC Installation - Kawee on 29-Dec-2005
    if ( !glb_DpcInstFlag && !strcmp(gprst_buf.cos, "31") ) {   // Not Included DPC Installation
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp);   // reject the GPRST record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    StrToUpper(gprst_buf.spnamemo, strlen(gprst_buf.spnamemo), sNetOrig);
    if ( strcmp(sNetOrig, "AIS") && strcmp(sNetOrig, "DPC") && strcmp(sNetOrig, "AWN") ) {
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp);   // reject the GPRST record
        fprintf(glb_Errfp, "[DET] %s|Field|Network| a_no(%s) network(%s)\n", glb_Eindex, data_event.mobile_num, sNetOrig);
        glb_ErrCtr++;
        return FAILURE;
    }

    // From Number
    strncpy(data_event.from_number, com_buf.a_no, 18);

    // Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
    if ( !IsValid_YYYYMMDDHHMMSS (gprst_buf.start_datetime) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date_time(%s)\n",
                glb_Eindex, gprst_buf.start_datetime);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008
    if ( strncmp(gprst_buf.start_datetime, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp);   // reject the GPRST record
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
                glb_Eindex, gprst_buf.start_datetime, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // check if it
    if ( glb_BcNewField > NUMFLD_GPRSTOLD ) {
        if ( gprst_buf.servpackid[0] == '4' && strcmp(gprst_buf.bearer_id, "02099") == 0 && strcmp(gprst_buf.cgrn_id, "52015") == 0 ) {
            strcpy(szSvcDesc, "3GTOT");
            nVolOverHeadTOT = 20;   // Volume overhead for 3GTOT is 20kb
        }
        else {
            if ( Get_SvcType(gprst_buf.speedType, gprst_buf.rat, gprst_buf.servpackid, gprst_buf.bearer_id, &dVolRating, szSvcDesc) == FAILURE ) {
                dVolRating = 0.1;   // Set default to 0.1 BAHT per KB
            }

        }
    }
    dVolRating *= 100;  // change BAHT to Satang

    // Time Key
    //Seize_time = Calc_SeizeTime(gprst_buf.start_datetime, gprst_buf.start_datetime+SIZE_YYYYMMDD);
    //sprintf(data_event.time_key, "%010ld", Seize_time);
    sprintf(data_event.time_key, "%s", gprst_buf.start_datetime);

    // Duration
    if ( gprst_buf.tbcf == '0' ) {  // GPRS Volumn Based Charging
        strcpy(data_event.duration, "000000");
    }
    else {
        Duration = Calc_Duration(gprst_buf.start_datetime, gprst_buf.start_datetime+SIZE_YYYYMMDD, gprst_buf.stop_datetime, gprst_buf.stop_datetime+SIZE_YYYYMMDD);
        sprintf(data_event.duration, "%06d", Duration);
    }

    // Volume1(FRM), Total Volume in bytes
    if ( gprst_buf.tbcf == '0' ) {  // GPRS Volume Based Charging
        lVolume = bcudrCorrectVol(gprst_buf.vol, gprst_buf.rqr);
    }

    sprintf(sVolume, "%010.0lf", ceil(lVolume/1024.0));     // convert to Kbyte
    strncpy(data_event.vol_total, sVolume+strlen(sVolume)-10 , 10);     // Copy only Last 10 Chars

    // added by thanakorn on 24-Jun-2013
    if ( strcmp(gprst_buf.cos, "51") &&             // GSM
         strcmp(gprst_buf.cos, "31") &&             // DPC
         strcmp(gprst_buf.cos, "600001") &&         // AWN Postpaid
         strcmp(gprst_buf.cos, "600002") &&         // AWN Postpaid
         strcmp(gprst_buf.cos, "600003") &&         // AWN Postpaid
         strcmp(gprst_buf.cos, "600004") &&         // AWN Postpaid
         strcmp(gprst_buf.cos, "600005") &&         // AWN Postpaid
         strcmp(gprst_buf.cos, "600007") &&         // AWN MVPN Postpaid
         strcmp(gprst_buf.cos, "906") &&            // AWN Postpaid
         strcmp(gprst_buf.cos, "909") &&            // AWN Postpaid
         strcmp(gprst_buf.cos, "214") ) {           // AWN Postpaid
        strcpy(data_event.charge, gprst_buf.vol_cost);
    }
    else if ( !strncmp(gprst_buf.cgrn_id, "901", 3) ) { // Added by N.Thanakorn on 26-Jun-2014; Maritime CDR.
        strcpy(data_event.charge, gprst_buf.netprice);  // netprice is in satang unit;
    }
    else {      // GSM, DPC and AWN
        if ( gprst_buf.tbcf == '0' ) {  // GPRS Volumn Based Charging
            iCharge = (ceil(lVolume / 1024.0) + nVolOverHeadTOT) * dVolRating;  // Charge Rate = 10 Satangs / 1 Kbytes
        }
        else {  // Charge Rate = 1 Baht / Minute
            iCharge = ceil(Duration/60.0)*100;
        }
        sprintf(data_event.charge, "%010ld", iCharge);
    }

    // Cell Area
    strcpy(data_event.cell_area, DEF_CELL_AREA);      // Use Dummy Value for GPRS

    // Cell Set
    strcpy(data_event.cell_set, "33333");       // Use Dummy Value for GPRS

    // Cell
    strcpy(data_event.cell, "33333");           // Use Dummy Value for GPRS

    // CDR Categories
    // Add the following if-else block by N. Thanakorn on 21-Jan-2014
    if ( !strncmp(gprst_buf.cgrn_id, "52003", 5) ) {    // Charging Id = "52003"
        iCategories |= CAT_DATA;
    }
    else {                                              // cgrn_id = "52001"
        if ( !strncmp(gprst_buf.rat, "1", 1) ) {        // rat = "1"
            iCategories |= CAT_DATA;
        }
        else {                                          // rat = "2"
            //iCategories |= CAT_DATA|CAT_GPRS;         // GPRS (2G)
            // Removed CAT_GPRS by N.Thanakorn on Jul-2014
            iCategories |= CAT_DATA;
        }
        if ( !strncmp(gprst_buf.cgrn_id, "901", 3) ) {  // Added by N.Thanakorn on 26-Jun-2014; Maritime CDR.
            iCategories |= CAT_MARITIME;
            strcpy(voice_event.cell_area, DEF_CELL_AREA);
        }
    }
    sprintf(data_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    //
    // Since AIS have Multi-SIM Service, one phone number can have mulitple SIM with different IMSI.
    // Thus, Skip both Velocity and Collision.
    // - Kawee 21-Oct-2005
    //
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         // Always skip velocity check for gprs
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        // Always skip collision check for gprs
    //
    // Since CDR from VSCP can dup in event_type, time_key and duration
    // Need more condition check for checkdup, this will be done in custom checkdup process
    // - Added below by Kawee on 20-Mar-2008
    //
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);                     // Always skip duplicate event check for CDR from VSCP
    strcpy(data_event.detect_params, szDetParams);

    // ----- not yet mapping fields -----
    // data_event.pre_disc
    // data_event.remarks
    // ----- not yet mapping fields -----

    // Added by Wiraphot on 14-Jan-2009
    // strcpy(data_event.servpackid, gprst_buf.servpackid);
    strcpy(data_event.event_src, glb_EventSource);
    strcpy(data_event.partition_id, AWN_PARTITION);

    return SUCCESS;
}

/*
** Added Gprst_To_IR_Event function - by Thanakorn on Oct-2012
*/
int Gprst_To_IR_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Gprst_To_IR_Event");
    _p_ = 0;
#endif
    char sAccessPoint[31+128];
    char *sTemp;
    double dwVolume = 0.0;

    //unsigned int Duration = 0;   /* Duration */
    //time_t Seize_time = 0; /* Seize Time in Seconds */

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];
    double nGprMin, nGprRnd;
    double iCharge = 0;

    memset(&ir_event, 0x00, sizeof(ir_event));
    memset(sAccessPoint, 0x00, sizeof(sAccessPoint));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    glb_EventId = IR_EVENT_TYPE;
    sprintf(ir_event.event_type, "%d", IR_EVENT_TYPE);

    if ( !IsValid_YYYYMMDDHHMMSS (gprst_buf.start_datetime) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date_time(%s)\n",
            glb_Eindex, gprst_buf.start_datetime);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008 */
    if ( strncmp(gprst_buf.start_datetime, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp); /* reject the GPRST record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
            glb_Eindex, gprst_buf.start_datetime, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }
    /* Time Key */
    //Seize_time = Calc_SeizeTime (gprst_buf.start_datetime, gprst_buf.start_datetime+SIZE_YYYYMMDD);
    //sprintf(ir_event.time_key, "%010ld", Seize_time);
    sprintf(ir_event.time_key, "%s", gprst_buf.start_datetime);
    strcpy(ir_event.call_start_time, gprst_buf.start_datetime);

    /* Validate Network */
    if ( strcmp(gprst_buf.cos, "51") &&
        strcmp(gprst_buf.cos, "31") ) {  /* Not GSM and DPC COS */
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp); /* reject the GPRST record */
        fprintf(glb_Errfp, "[DET] %s|Field|COS_ID| cos(%s)\n", glb_Eindex, gprst_buf.cos);
        glb_ErrCtr++;
        return FAILURE;
    }


    /* Don't Feed CDR That COS=51 if not included AIS Installation - Kawee on 29-Dec-2005 */
    if ( !glb_AisInstFlag && !strcmp(gprst_buf.cos, "51") ) {     /* Not Included AIS Installation */
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp); /* reject the GPRST record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* Don't Feed CDR That COS=31 if not included DPC Installation - Kawee on 29-Dec-2005 */
    if ( !glb_DpcInstFlag && !strcmp(gprst_buf.cos, "31") ) {     /* Not Included DPC Installation */
        fwrite(&raw_gprst, SIZE_GPRSTRAW, 1, glb_RCdrfp); /* reject the GPRST record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* map a_no (calling_number) */
    if ( Conv_Gprst_Ano())
        return FAILURE;

    /* Service Num */
    strncpy(ir_event.mobile_num, com_buf.a_no, 16);
    /* From Number */
    strncpy(ir_event.from_number, com_buf.a_no, 18);

    // strcpy(ir_event.call_type, "18");

    dwVolume = ceil((atof(gprst_buf.vol)/1024.0));    /* convert to Kbyte */

    strcpy(ir_event.utc_offset, "+700");   /* ir scp is recorded in Thailand local time */

    /* Access Point */
    if ( (sTemp = strstr(gprst_buf.rqr, "-"))!= NULL) {
        strncpy(sAccessPoint, gprst_buf.rqr, sTemp - gprst_buf.rqr);
        // strncpy(ir_event.access_point, sAccessPoint, 18);
    }

    /* Rating */
    Get_CarrierPriceGprs(gprst_buf.cgrn_id, &iCharge, &nGprMin, &nGprRnd);
    iCharge=(iCharge/1000.0);
    if ( nGprMin > 0 && nGprRnd > 0 ) {
        if ( dwVolume <= 0 ) {
            iCharge = 0;
        }
        else {
            if ( (double)(dwVolume) <= (double)nGprMin ) {
                iCharge *= nGprMin;
            }
            else {
                iCharge = (ceil(dwVolume/nGprRnd))*nGprRnd*iCharge;
            }
        }
    }
    else {
        iCharge *= dwVolume;
    }

    sprintf(ir_event.charge, "%010.0lf", (iCharge*100));     /* Convert to Satang */
    //dwVolume = /*ceil*/((atof(gprst_buf.vol)/1024.0/1024.0));       /* Convert to Mbyte */
    // sprintf(ir_event.volume1, "%010.0lf", dwVolume);

    /* Volume2 , Uplink Volume in Kbytes */
    // strcpy(ir_event.volume2, "0000000000");

    /* Volume3 , Downlink Volume in Kbytes */
    // strcpy(ir_event.volume3, "0000000000");

    strcpy(ir_event.call_start_time, gprst_buf.start_datetime);

    // Get_CellAreaFromCarrier(gprst_buf.cgrn_id, ir_event.cell_area, ir_event.plmn_code, ir_event.country_code);

    /* Cell Set */
    // strcpy(ir_event.cell_set, "00000");       /* Use Dummy Value for GPRS */

    /* Cell */
    // strcpy(ir_event.cell, "00000");           /* Use Dummy Value for GPRS */

    iCategories |= CAT_DATA|CAT_IR;
    sprintf(ir_event.categories, "%08d", iCategories);

    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         /* Always skip velocity check for gprs */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        /* Always skip collision check for gprs */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        /* Always skip duplicate event check for CDR from VSCP */
    strcpy(ir_event.detect_params, szDetParams);

    strcpy(ir_event.event_src, glb_EventSource);
    strcpy(ir_event.partition_id, AWN_PARTITION);

    return SUCCESS;
}

/*
** Added Gprs_To_Data_Event_18 function - by Jetsada on 08-Aug-2005
*/
int Gprs_To_Data_Event_18()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Gprs_To_Data_Event_18");
    _p_ = 0;
#endif
    char    sNetOrig[SIZE_NET+1];
    char    sCostgroupId[SIZE_COSTGROUP_ID+1];
    char    sCostbandId[SIZE_COSTBAND_ID+1];

    char    sVolume[21+1];

    //time_t  Seize_time = 0; // Seize Time in Seconds

    double  dwUplinkVolume = 0.0;
    double  dwDownlinkVolume = 0.0;

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    memset(sNetOrig, 0x00, sizeof(sNetOrig));
    memset(sCostgroupId, 0x00, sizeof(sCostgroupId));
    memset(sCostbandId, 0x00, sizeof(sCostbandId));
    memset(sVolume, 0x00, sizeof(sVolume));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    // Event Type
    glb_EventId = DATA_EVENT_TYPE;  // Data Event Type
    sprintf(data_event.event_type, "%02d", glb_EventId);

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_GPRS] == 0 ) {
        // Reject BOS online record, added by Thanakorn on 26-Aug-2013
        // ignore Charging Charateristic (CC) = 1 (Hot Billing BOS)
        if ( atoi(pbuf_gprs[GPR_CHG_CHAR]) == 1 ) {
            fputs(raw_input, glb_RCdrfp);   // reject the GPRS Trailer
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| chg_char(%s)\n", glb_Eindex, pbuf_gprs[GPR_CHG_CHAR]);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    // Added if-else block by N.Thanakorn on 17-Oct-2013
    if ( !strcmp(pbuf_gprs[GPR_REC_TYPE], "18") ) { // from SGSN
        if ( strncmp(pbuf_gprs[GPR_SRV_IMSI], "52001", 5) &&   // AIS
             strncmp(pbuf_gprs[GPR_SRV_IMSI], "52023", 5) ) {  // reject when imsi is not started with 52001 or 52023
            fputs(raw_input, glb_RCdrfp); // a new record type - reject
            fprintf(glb_Errfp, "[DET] %s|Field|IMSI| invalid imsi(%s)\n", glb_Eindex, pbuf_gprs[GPR_SRV_IMSI]);
            glb_ErrCtr++;
            return FAILURE;
        }
    }
    else {  // from GGSN (rec_type, 19, 70, 225)
        if ( strncmp(pbuf_gprs[GPR_SRV_IMSI], "52003", 5) ) {   // AWN, reject when imsi is not started wiht 52003
            fputs(raw_input, glb_RCdrfp); // a new record type - reject
            fprintf(glb_Errfp, "[DET] %s|Field|IMSI| invalid imsi(%s)\n", glb_Eindex, pbuf_gprs[GPR_SRV_IMSI]);
            glb_ErrCtr++;
            return FAILURE;
        }
    }

    // map a_no (calling_number)
    if ( Conv_Gprs_Ano() )
        return FAILURE;

    // Service Num
    strncpy(data_event.mobile_num, com_buf.a_no, 16);
    //
    // Since AIS have Multi-SIM Service, one phone number can have mulitple SIM with different IMSI.
    // Thus, Skip both Velocity and Collision. Don't feed GPRS CDR for Prepaid
    //
    // - Kawee 28-Dec-2005

    // Feed This CDR only included AIS Installation - Kawee on 29-Dec-2005
    if ( !glb_AisInstFlag) {    // Not Included AIS Installation
        fputs(raw_input, glb_RCdrfp);   // reject the GPRS Trailer
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }
    // From Number
    strncpy(data_event.from_number, com_buf.a_no, 18);

    // Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
    if ( !IsValid_YYYYMMDD_HHMMSS (pbuf_gprs[GPR_REC_OPEN_DATE], pbuf_gprs[GPR_REC_OPEN_TIME]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| open_date(%s) open_time(%s)\n",
            glb_Eindex, pbuf_gprs[GPR_REC_OPEN_DATE], pbuf_gprs[GPR_REC_OPEN_TIME]);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008
    if ( strncmp(pbuf_gprs[GPR_REC_OPEN_DATE], glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fputs(raw_input, glb_RCdrfp); // reject the GPRS Trailer
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n",
            glb_Eindex, pbuf_gprs[GPR_REC_OPEN_DATE], pbuf_gprs[GPR_REC_OPEN_TIME], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // Time Key
    //Seize_time = Calc_SeizeTime (pbuf_gprs[GPR_REC_OPEN_DATE], pbuf_gprs[GPR_REC_OPEN_TIME]);
    //sprintf(data_event.time_key, "%010ld", Seize_time);
    sprintf(data_event.time_key, "%s%s", pbuf_gprs[GPR_REC_OPEN_DATE], pbuf_gprs[GPR_REC_OPEN_TIME]);

    // Duration
    strcpy(data_event.duration, "000000");

    // Total Volume in bytes
    dwUplinkVolume = ceil(atof(pbuf_gprs[GPR_VOL_UP_LINK])/1024.0);        // Convert Uplink Volume to Kbytes
    dwDownlinkVolume = ceil(atof(pbuf_gprs[GPR_VOL_DW_LINK])/1024.0);    // Convert Downlink Volume to Kbytes

    // Charge
    //
    // GPRS Volume base charge rate is 10 satang / 1Kbytes
    // Unit in satang
    sprintf(data_event.charge, "%010.0lf", (dwUplinkVolume + dwDownlinkVolume) * 10);

    // Volume1(FRM), Total Volume in Kbytes
    sprintf(sVolume, "%010.0lf", dwUplinkVolume+dwDownlinkVolume);      // Calculate Total Volume
    strncpy(data_event.vol_total, sVolume+strlen(sVolume)-10 , 10);     // Copy only last 10 Chars to vol_total

    //
    // Originating Cell, Cell Set and Cell Area Mapping from Raw cdr.
    //
    // In the new CGI,      LAC is 5 digits in decimal format and is from 6th digit of the cell_id_a
    //                      CI is 5 digits in decimal format and is last 5 digits of the cell_ida
    //                      - Kawee 20-Mar-2003
    //
    // Cell      - Since, CI in SSP is always "00000". Thus copy five space chars to cell.
    //         (In General Take last 5 chars (11,12,13,14,15) of cell_id_a from raw cdr.
    //         This is of Decimal value (CI).  Assign this value to FIT Cell.)
    //
    // Cell Set  - Take 5 chars from 6th (6,7,8,9,10) of cell_id_a from raw cdr.  This is of Decimal value (LAC).
    //             Assign this value to FIT Cell Set.
    //
    // Cell Area - Take 2 chars from 8th (8,9) of cell_id_a field from raw cdr. (This is province)
    //             Prefix 0(s) to make it 5 chars.  Assign this value to FIT Cell Area.
    //
#if 0
    // Cell
    strncpy(data_event.cell, pbuf_gprs[GPR_CELL_ID]+11-1, 5);

    // Cell Set
    strncpy(data_event.cell_set, pbuf_gprs[GPR_CELL_ID]+6-1, 5);

    // Cell Area
    strcpy(data_event.cell_area, "000");
    strncpy(data_event.cell_area+3, pbuf_gprs[GPR_CELL_ID]+8-1, 2);
#endif
    if ( data_event.cell_area[0] == '\0' ) {
        if ( Get_GeoData(pbuf_gprs[GPR_CELL_ID], data_event.cell, data_event.cell_set, data_event.cell_area) != SUCCESS ) {
            fprintf(glb_Errfp, "[DET] %s|GeoMapp|Cell_IDA| cell_id_a(%s) but not skip\n", glb_Eindex, pbuf_gprs[GPR_CELL_ID]);
            strcpy(data_event.cell_area, DEF_CELL_AREA);
        }
    }
    // CDR Categories
    iCategories |= CAT_DATA|CAT_LOCAL;    // Set to Total, 3G and Outgoing Category
    sprintf(data_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    //
    // Since AIS have Multi-SIM Service, one phone number can have mulitple SIM with different IMSI.
    // Thus, Skip both Velocity and Collision.
    // - Kawee 21-Oct-2005
    //
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         // Always skip velocity check for gprs
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        // Always skip collision check for gprs
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        // skip duplication check for non voice events
    strcpy(data_event.detect_params, szDetParams);

    // ----- not yet mapping fields -----
    // data_event.pre_disc
    // data_event.remarks
    // ----- not yet mapping fields -----

    // Added by Wiraphot on 14-Jan-2009
    // memset(data_event.servpackid, SPACE_CHAR, sizeof(data_event.servpackid)-1); // Copy Blank to Service Package Id
    strcpy(data_event.event_src, glb_EventSource);
    strcpy(data_event.partition_id, AWN_PARTITION);

    return SUCCESS;
}
//------------------------------------------------------------------------------------*/

//
// Added Mms_To_Mms_Event_Tcudr function - by Jetsada on 09-Aug-2005
//
int Mms_To_Mms_Event_Tcudr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Mms_To_Mms_Event_Tcudr");
    _p_ = 0;
#endif
    //time_t      Seize_time = 0; // Seize Time in Seconds

    char net_orig[SIZE_NET+1];
    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    //char cost_group_id[SIZE_COSTGROUP_ID+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char rating_catalogue_id[SIZE_RATING_CATALOGUE_ID+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    memset(net_orig, 0x00, sizeof(net_orig));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(rating_tariff_id, 0x00, sizeof(rating_tariff_id));
    memset(event_class_id, 0x00, sizeof(event_class_id));
    memset(rating_catalogue_id, 0x00, sizeof(rating_catalogue_id));
    memset(fix_charge_mny, 0x00, sizeof(fix_charge_mny));
    memset(charge_rate, 0x00, sizeof(charge_rate));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_VSCP] == 0 ) {
        // Reject BOS online record, added by Thanakorn on 26-Aug-2013
        // ignore servpackid = 5 (5 - BOS� 2G,3G)
        if ( atoi(mms_buf.servpackid) == 5 ) {
            fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // reject the record
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| servpackid(%s)\n", glb_Eindex, mms_buf.servpackid);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    // Condition Checking for Reject Record
    if ( strcmp(mms_buf.cause, "000") ) {   // End Cause is not Success (cause is 000, means Success)
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);    // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Cause|Cause %s\n", glb_Eindex, mms_buf.cause);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Check for Reject Test Record - Added below by Kawee on 01-Feb-2006
    if ( mms_buf.ti == '1') {   // Test Record
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|TEST|TEST| ti(%c)\n", glb_Eindex, mms_buf.ti);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( mms_buf.ppf != '0') {  // Not Postpaid
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);    // reject the record
        fprintf(glb_Ignfp, "[DET] %s|PPF|Not_Postpaid| ppf(%c)\n", glb_Eindex, mms_buf.ppf);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( mms_buf.leg == '0') {
        if ( strncmp(mms_buf.tele_id, "01", 2) ) {  // Not Start with 01 (01xxx)
            fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp); // reject the record
            fprintf(glb_Ignfp, "[DET] %s|TEL_SERV|Leg %c| tele_id(%s)\n", glb_Eindex, mms_buf.leg, mms_buf.tele_id);
            glb_IgnCtr++;
            return FAILURE;
        }
    }
    else if ( mms_buf.leg == '1') {
        if ( strcmp(mms_buf.tele_id, "01900") ) {   // Not 01900
            fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // reject the record
            fprintf(glb_Ignfp, "[DET] %s|TEL_SERV|Leg %c| tele_id(%s)\n", glb_Eindex, mms_buf.leg, mms_buf.tele_id);
            glb_IgnCtr++;
            return FAILURE;
        }
    }
    else {
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|TEL_SERV|Leg %c| tele_id(%s)\n", glb_Eindex, mms_buf.leg, mms_buf.tele_id);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Check the Cat_Id field should not blank. This field use for rating
    if ( *mms_buf.cat_id == '\0' ) {
        fprintf(glb_Errfp, "[DET] %s|Field|CAT_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Check the CP_Id field should not blank. This field use for rating
    if ( *mms_buf.cp_id == '\0' ) {
        fprintf(glb_Errfp, "[DET] %s|Field|CP_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Check the Sid field should not blank. This field use for rating
    if ( *mms_buf.sid == '\0' ) {
        fprintf(glb_Errfp, "[DET] %s|Field|SID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    // MMS is now change to SMS Event Type
    glb_EventId = SMS_EVENT_TYPE;
    sprintf(sms_event.event_type, "%02d", glb_EventId);

    // Direction
    strcpy(sms_event.direction, OUTGOING);  // Outgoing Call

    // Partition
    strcpy(sms_event.partition_id, AWN_PARTITION);

    // Service Number
    if ( Conv_Ano(mms_buf.subject, com_buf.a_no) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    //strncpy(mms_event.mobile_num, com_buf.a_no, 16);
    strncpy(sms_event.mobile_num, com_buf.a_no, 16);

    if ( glb_TcNewField > NUMFLD_MMSOLD ) {    // new format // Added by Thanakorn on Jan-2010
        StrToUpper(mms_buf.spnamemo, strlen(mms_buf.spnamemo), net_orig);
        if ( strcmp(net_orig, "AIS") && strcmp(net_orig, "DPC") && strcmp(net_orig, "AWN") ) {
            fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp); // reject the record
            fprintf(glb_Errfp, "[DET] %s|Field|Network| a_no(%s) network(%s)\n", glb_Eindex, sms_event.mobile_num, net_orig);
            glb_ErrCtr++;
            return FAILURE;
        }
    }

    // Don't Feed AIS CDR when not included AIS Installation - Kawee on 29-Dec-2005
    if ( !glb_AisInstFlag && !strcmp(net_orig, "AIS") ) {   // Not Included AIS Installation
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS) network(%s)\n", glb_Eindex, net_orig);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Don't Feed DPC CDR when not included DPC Installation - Kawee on 29-Dec-2005
    if ( !glb_DpcInstFlag && !strcmp(net_orig, "DPC") ) {   // Not Included DPC Installation
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC) network(%s)\n", glb_Eindex, net_orig);
        glb_IgnCtr++;
        return FAILURE;
    }
#ifdef AWN_ENABLED
    if ( !glb_AisInstFlag && !strcmp(net_orig, "AWN") ) {   // Not Included AIS Installation
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS) network(%s)\n", glb_Eindex, net_orig);
        glb_IgnCtr++;
        return FAILURE;
    }
#endif
    // From Number
    //strncpy(mms_event.from_number, com_buf.a_no, 18);
    strncpy(sms_event.from_number, com_buf.a_no, 18);

    // Target Object
    //strcpy(mms_event.target_object, mms_buf.object);

    // Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
    if ( !IsValid_YYYYMMDDHHMMSS (mms_buf.start_datetime) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date_time(%s)\n", glb_Eindex, mms_buf.start_datetime);
        glb_ErrCtr++;
        return FAILURE;
    }

    // Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008
    if ( strncmp(mms_buf.start_datetime, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
            glb_Eindex, mms_buf.start_datetime, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // Seize Time & Date
    //Seize_time = Calc_SeizeTime (mms_buf.start_datetime, mms_buf.start_datetime+SIZE_YYYYMMDD);
    //sprintf(sms_event.time_key, "%010ld", Seize_time);
    sprintf(sms_event.time_key, "%s", mms_buf.start_datetime);

    // Total Message Size
    // Just Copy. We don't do volume based threshold for MMS!!
    // strcpy(mms_event.data_volume, mms_buf.size);

    // Charge in Satang
    sprintf(costcode, "%s%s%s6", mms_buf.cat_id, mms_buf.cp_id, mms_buf.sid);
    strcpy(banding_model_id, "12");
    strcpy(rating_tariff_id, "54");
    strcpy(event_class_id, "41");

    if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) { // FAILURE
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Code| banding_model_id(%s) costcode(%s)\n", glb_Eindex, banding_model_id, costcode);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
        fwrite(&raw_mms, SIZE_MMSRAW, 1, glb_RCdrfp);   // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
            glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
        glb_ErrCtr++;
        return FAILURE;
    }

    //sprintf(mms_event.charge, "%010ld", atol(fix_charge_mny)/10);
    sprintf(sms_event.charge, "%010ld", atol(fix_charge_mny)/10);

    // Sub-Service ID
    //strcpy(mms_event.service_id, mms_buf.sid);
    strcpy(sms_event.service_id, mms_buf.sid);

    // Fee
    strcpy(sms_event.fee_charge, mms_buf.fee);

    // Remark
    strcpy(sms_event.remarks, "MMS");

    // Event Source
    strcpy(sms_event.event_src, glb_EventSource);

    // ----- not yet mapping fields -----
    // sms_event.to_number
    // sms_event.sms_type
    // sms_event.original_bno
    // sms_event.bno
    // sms_event.area_code
    // sms_event.cell_area
    // sms_event.cell_set
    // sms_event.cell
    // sms_event.business_code
    // sms_event.pre_disc
    // sms_event.payment_type
    // ----- not yet mapping fields -----

    // Service Category ID
    //strcpy(mms_event.service_cat, mms_buf.cat_id);

    // Content Provider ID
    //strcpy(mms_event.content_id, mms_buf.cp_id);

    // Bearer Code
    //*mms_event.bearer_code = mms_buf.ob;

    // CDR Categories
    iCategories |= CAT_MMS|CAT_SMS|CAT_TOTAL|CAT_LOCAL;
    //sprintf(mms_event.categories, "%08d", iCategories);
    sprintf(sms_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        // Always skip collision check for mms
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         // Always skip velocity check for mms
    //
    // Since CDR from VSCP can dup in event_type, time_key and duration
    // Need more condition check for checkdup, this will be done in custom checkdup process
    // - Added below by Kawee on 20-Mar-2008
    //
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        // Always skip duplicate event check for CDR from VSCP
    //strcpy(mms_event.detect_params, szDetParams);
    strcpy(sms_event.detect_params, szDetParams);

    return SUCCESS;

}

// ------------------------------------------------------------------------------------

//
// Added Cdg_To_Cdg_Event_Ctudr function - by Jetsada on 09-Aug-2005
//
int Cdg_To_Cdg_Event_Ctudr()
{
    //time_t  Seize_time = 0; // Seize Time in Seconds

    char sVolume[21+1];
    char net_orig[SIZE_NET+1];
    char bearer_code[1+1];
    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char rating_catalogue_id[SIZE_RATING_CATALOGUE_ID+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    char szCDG_TI[5];
    char szTempAno[SIZE_MOBILE_NUM];
    char szTemp[10];
    char company_name[50+1];
    char service_name[50+1];

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    memset(sVolume, 0x00, sizeof(sVolume));
    memset(net_orig, 0x00, sizeof(net_orig));
    memset(bearer_code, 0x00, sizeof(bearer_code));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(rating_tariff_id, 0x00, sizeof(rating_tariff_id));
    memset(event_class_id, 0x00, sizeof(event_class_id));
    memset(rating_catalogue_id, 0x00, sizeof(rating_catalogue_id));
    memset(fix_charge_mny, 0x00, sizeof(fix_charge_mny));
    memset(charge_rate, 0x00, sizeof(charge_rate));
    memset(szCDG_TI, 0x00, sizeof(szCDG_TI));
    memset(szTemp, 0x00, sizeof(szTemp));
    memset(company_name, 0x00, sizeof(company_name));
    memset(service_name, 0x00, sizeof(service_name));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_VSCP] == 0 ) {
        // Reject BOS online record, added by Thanakorn on 26-Aug-2013
        // ignore servpackid = 5 (5 - BOS� 2G,3G)
        if ( atoi(pbuf_cdg[CDG_SRVPKID]) == 5 ) {
            fputs (raw_input, glb_RCdrfp);  // reject the CDG record
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| servpackid(%s)\n", glb_Eindex, pbuf_cdg[CDG_SRVPKID]);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    if ( strcmp(pbuf_cdg[CDG_APPID], "66*4186788") == 0 || strcmp(pbuf_cdg[CDG_APPID], "66*4186789") == 0 ) {
        fputs (raw_input, glb_RCdrfp);  // reject the CDG record
        fprintf(glb_Ignfp, "[DET] %s|APPID|Google_Play| appid(%s)\n", glb_Eindex, pbuf_cdg[CDG_APPID]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( glb_CtNewField > CDG_PKGID+1) {        // for new field; the field CDG_TI, CDG_CUSTID is switched each other
        strcpy(szCDG_TI, pbuf_cdg[CDG_TI]);
    }
    else {
        strcpy(szCDG_TI, pbuf_cdg[CDG_CUSTID]); // old field
    }

    // Added check for Reject Test Record - by Kawee on 15-Aug-2007
    if ( !strcmp(szCDG_TI, "1") ) {     // Test CDR
        fputs (raw_input, glb_RCdrfp);  // reject the CDG record
        fprintf(glb_Ignfp, "[DET] %s|TEST|TEST| ti(%s)\n", glb_Eindex, szCDG_TI);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Added check for Reject Cause is not equal to "000" - by Thanakorn on 15-Aug-2012
    if ( strcmp(pbuf_cdg[CDG_CAUSE], "000") ) {     // Reject when CDG_CAUSE != 000
        fputs (raw_input, glb_RCdrfp);              // reject the CDG record
        fprintf(glb_Ignfp, "[DET] %s|Cause|Cause %s| only (000) accepted\n", glb_Eindex, pbuf_cdg[CDG_CAUSE]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_cdg[CDG_PPF], "0") ) {     // Not Postpaid
        fputs (raw_input, glb_RCdrfp);          // reject the CDG record
        fprintf(glb_Ignfp, "[DET] %s|PPF|Not_Postpaid| ppf(%s)\n", glb_Eindex, pbuf_cdg[CDG_PPF]);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Don't Feed AIS CDR when not included AIS Installation - Kawee on 29-Dec-2005
    if ( !glb_AisInstFlag && !strcmp(pbuf_cdg[CDG_COS], "51") ) {   // Not Included AIS Installation
        fputs (raw_input, glb_RCdrfp);  // reject the CDG record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS) cos(%s)\n", glb_Eindex, pbuf_cdg[CDG_COS]);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Don't Feed DPC CDR when not included DPC Installation - Kawee on 29-Dec-2005
    if ( !glb_DpcInstFlag && !strcmp(pbuf_cdg[CDG_COS], "31") ) {   // Not Included AIS Installation
        fputs (raw_input, glb_RCdrfp);  // reject the CDG record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC) cos(%s)\n", glb_Eindex, pbuf_cdg[CDG_COS]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp(pbuf_cdg[CDG_CCT], "00") ) {
        fputs (raw_input, glb_RCdrfp);  // reject the CDG record
        fprintf(glb_Ignfp, "[DET] %s|Non_Charge|CCT %s\n", glb_Eindex, pbuf_cdg[CDG_CCT]);
        glb_IgnCtr++;
        return FAILURE;
    }
    else if ( !*pbuf_cdg[CDG_CCT]) {    // CCT is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|CCT_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_cdg[CDG_CATID]) {   // CATID is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|CAT_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    strcpy(szTempAno, pbuf_cdg[CDG_MSISDN]);

    if ( !*pbuf_cdg[CDG_CPID]) {    // CPID is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|CP_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( !*pbuf_cdg[CDG_SID]) {     // SID is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|SID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( !*pbuf_cdg[CDG_SGWID]) {   // SGWID is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|SGW_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    glb_EventId = VAS_EVENT_TYPE;

    // Service Number
    if ( Conv_Ano(szTempAno, cdg_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strlen(cdg_event.mobile_num) < SIZE_PHONENO) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, cdg_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }

    // From Mobile Number
    strcpy(cdg_event.from_number, cdg_event.mobile_num);

    // Application Id
    strncpy(cdg_event.app_id, pbuf_cdg[CDG_APPID], sizeof(cdg_event.app_id)-1);

    // Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
    if ( !IsValid_YYYYMMDDHHMMSS (pbuf_cdg[CDG_START]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date_time(%s)\n", glb_Eindex, pbuf_cdg[CDG_START]);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008
    if ( strncmp(pbuf_cdg[CDG_START], glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fputs(raw_input, glb_RCdrfp);   // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n", glb_Eindex, pbuf_cdg[CDG_START], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // Seize Time & Date
    //Seize_time = Calc_SeizeTime (pbuf_cdg[CDG_START], pbuf_cdg[CDG_START]+SIZE_YYYYMMDD);
    //sprintf(cdg_event.time_key, "%010ld", Seize_time);
    sprintf(cdg_event.time_key, "%s", pbuf_cdg[CDG_START]);

    // // Total Message Size (Kbytes)
    // sprintf(sVolume, "%010.0lf", ceil(atol(pbuf_cdg[CDG_SIZE]) / 1024.0));  // Convert to Kbytes
    // strncpy(cdg_event.data_volume, sVolume+strlen(sVolume)-10 , 10);        // Copy only Last 10 Chars

    // Content Contained Type
    // strcpy(cdg_event.content_type, pbuf_cdg[CDG_CCT]);
    int cct = atoi(pbuf_cdg[CDG_CCT]);
    if ( cct == 9 )
        iCategories |= CAT_VAS_SUBS;
    else if ( cct == 10 )
        iCategories |= CAT_VAS_RECUR;
    else if ( cct == 11 )
        iCategories |= CAT_VAS_ONETIME;

    // Directrion
    strcpy(cdg_event.direction, OUTGOING);   // Outgoing

    // Sub-Service ID
    strcpy(cdg_event.service_id, pbuf_cdg[CDG_SID]);

    // Service Category ID
    strcpy(cdg_event.service_cat, pbuf_cdg[CDG_CATID]);

    // IMSI
    strcpy(cdg_event.imsi, pbuf_cdg[CDG_IMSI]);

    // Charging Id
    strcpy(cdg_event.charging_id, pbuf_cdg[CDG_CHGID]);

    // Short Code
    strrcpy(szTemp, pbuf_cdg[CDG_SID], 5);
    sprintf(cdg_event.short_code, "%s%s%s%s", szTemp, pbuf_cdg[CDG_CCT], pbuf_cdg[CDG_CATID], pbuf_cdg[CDG_CPID]);

    // Vas Description
    Get_UsMapData(szTemp, pbuf_cdg[CDG_CATID], pbuf_cdg[CDG_CPID], pbuf_cdg[CDG_CCT], company_name, service_name);
    sprintf(cdg_event.vas_desc, "%s,%s", company_name, service_name);

    // Content Provider ID
    strcpy(cdg_event.content_id, pbuf_cdg[CDG_CPID]);

    // Service Gateway ID
    // strcpy(cdg_event.sgw_id, pbuf_cdg[CDG_SGWID]);

    strcpy(cdg_event.remarks, pbuf_cdg[CDG_MKTYPE]);

    // Bearer Code
    if ( Get_Bearer (pbuf_cdg[CDG_SGWID], bearer_code) ) {    // Failure
        fputs (raw_input, glb_RCdrfp);  // reject the record
        fprintf(glb_Errfp, "[DET] %s|Field|SGW_ID| sgwid(%s)\n", glb_Eindex, pbuf_cdg[CDG_SGWID]);
        glb_ErrCtr++;
        return FAILURE;
    }
    *cdg_event.bearer_code = *bearer_code;

    // CDR Categories
    // Added "VasOrPremium" Category - Changed as below by Kawee on 22-Mar-2007
    iCategories |= CAT_TOTAL|CAT_VAS|CAT_LOCAL;    // Set to Total, VAS and Outgoing Category
    sprintf(cdg_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        // Always skip collision check for cdg
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         // Always skip velocity check for cdg
    //
    // Since CDR from VSCP can dup in event_type, time_key and duration
    // Need more condition check for checkdup, this will be done in custom checkdup process
    // - Added below by Kawee on 20-Mar-2008
    //
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        // Always skip duplicate event check for CDR from VSCP
    strcpy(cdg_event.detect_params, szDetParams);

    // Charge in Satang
    sprintf(costcode, "%s%s%s%s%s%s", pbuf_cdg[CDG_CATID], pbuf_cdg[CDG_CPID], pbuf_cdg[CDG_SID], cdg_event.bearer_code, pbuf_cdg[CDG_CCT], pbuf_cdg[CDG_PKGID]);
    strcpy(banding_model_id, "4");

    if ( !strcmp(pbuf_cdg[CDG_COS], "31") )     // DPC
        strcpy(rating_tariff_id, "56");
    else {  // 51, 600001-600005, 600007, 906, 909, 214
        strcpy(rating_tariff_id, "7");          // GSM, AWN
    }

    if ( Get_RmCostBandId2(banding_model_id, costcode, cost_band_id, cdg_event.vas_name) ) {  // FAILURE
        fputs (raw_input, glb_RCdrfp);  // reject the CDG record
        fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Code| banding_model_id(%s) costcode(%s)\n", glb_Eindex, banding_model_id, costcode);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( Get_VasGroupCodeByGrpName(gszCostcode_Desc, cdg_event.vas_grp) != SUCCESS ) {
        Get_VasGroupCodeByGrpName(gszCostcode_Name, cdg_event.vas_grp);
    }

    if ( Parse_RatingElement2(rating_tariff_id, cost_band_id, fix_charge_mny, charge_rate) ) {
        fputs (raw_input, glb_RCdrfp);  // reject the CDG record
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s)\n",
            glb_Eindex, rating_tariff_id, cost_band_id);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( *charge_rate == '\0' || *charge_rate == '0') {
        if ( *fix_charge_mny == '\0' || *fix_charge_mny == '0' )
            sprintf(cdg_event.charge, "%010d", 0);
        else
            sprintf(cdg_event.charge, "%010ld", atol(fix_charge_mny)/10);   // Satang Unit
    }
    else
        sprintf(cdg_event.charge, "%010ld", atol(charge_rate)/1000);        // Satang Unit

    // Vas Name - Already Assigned Value, during get CostBandId. See Charge.
    return (CommonVas_To_Vas_Event(glb_MtxInd, (void *)&cdg_event));

}
// ------------------------------------------------------------------------------------

/*
** Added Cdg_To_Dcb_Event function - by N.Thanakorn on 20-May-2014
*/
int Cdg_To_Dcb_Event ()
{
    //time_t  Seize_time = 0; /* Seize Time in Seconds */

    char sVolume[21+1];
    char net_orig[SIZE_NET+1];
    char bearer_code[1+1];
    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char rating_catalogue_id[SIZE_RATING_CATALOGUE_ID+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    char szCDG_TI[5];
    char szTmpVasName[60+1];
    long lCharge = 0L;
    long lPreDisc = 0L;

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    /* initialize Common Structure buffer for each CDR */
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&cdg_event, 0x00, sizeof (cdg_event));
    memset(sVolume, 0x00, sizeof(sVolume));
    memset(net_orig, 0x00, sizeof(net_orig));
    memset(bearer_code, 0x00, sizeof(bearer_code));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(rating_tariff_id, 0x00, sizeof(rating_tariff_id));
    memset(event_class_id, 0x00, sizeof(event_class_id));
    memset(rating_catalogue_id, 0x00, sizeof(rating_catalogue_id));
    memset(fix_charge_mny, 0x00, sizeof(fix_charge_mny));
    memset(charge_rate, 0x00, sizeof(charge_rate));
    memset(szCDG_TI, 0x00, sizeof(szCDG_TI));
    memset(szTmpVasName, 0x00, sizeof(szTmpVasName));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    if ( glb_MtxInd == DCBCT_TYPE ) {   // DCB as a ctudr cdr file
        // Reject this ctudr cdr record as it has already come in DCB log cdr record
        if ( strcmp(pbuf_cdg[CDG_APPID], "66*4186788") == 0 || strcmp(pbuf_cdg[CDG_APPID], "66*4186789") == 0 ) {
            fputs (raw_input, glb_RCdrfp);  // reject the CDG record
            fprintf(glb_Ignfp, "[DET] %s|APPID|Google_Play| appid(%s)\n", glb_Eindex, pbuf_cdg[CDG_APPID]);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    /* Add Check as below by Kawee on 29-Dec-2005, modified by thanakorn on 17-Jun-2013 */
    if ( strcmp(pbuf_cdg[CDG_COS], "51") &&             /* GSM */
         strcmp(pbuf_cdg[CDG_COS], "31") &&             /* DPC */
         strcmp(pbuf_cdg[CDG_COS], "600001") &&         /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "600002") &&         /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "600003") &&         /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "600004") &&         /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "600005") &&         /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "600007") &&         /* AWN MVPN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "906") &&            /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "909") &&            /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "999") &&
         strcmp(pbuf_cdg[CDG_COS], "214") &&
         strcmp(pbuf_cdg[CDG_COS], "241") ) {           /* AWN Postpaid */

        fputs (raw_input, glb_RCdrfp); /* reject the CDG record */
        fprintf(glb_Ignfp, "[DET] %s|COS|COS %s\n", glb_Eindex, pbuf_cdg[CDG_COS]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_cdg[CDG_REC_TYPE], "ctudr") ) {
        fputs (raw_input, glb_RCdrfp);  /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, pbuf_cdg[CDG_REC_TYPE]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_DCB] == 0 ) {
        /* Reject BOS online record, added by Thanakorn on 26-Aug-2013 */
        /* ignore servpackid = 5 (5 - BOS� 2G,3G) */
        //
        //if ( atoi(pbuf_cdg[CDG_SRVPKID]) == 5 ) {
        //    fputs(raw_input, glb_RCdrfp);  /* reject the CDG record */
        //    fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| servpackid(%s)\n", glb_Eindex, pbuf_cdg[CDG_SRVPKID]);
        //    glb_IgnCtr++;
        //    return FAILURE;
        //}
    }

    if ( glb_CtNewField > CDG_PKGID+1) {    /* for new field; the field CDG_TI, CDG_CUSTID is switched each other */
        strcpy(szCDG_TI, pbuf_cdg[CDG_TI]);
    }
    else {
        strcpy(szCDG_TI, pbuf_cdg[CDG_CUSTID]); /* old field */
    }

    /* Added check for Reject Test Record - by Kawee on 15-Aug-2007 */
    if ( !strcmp(szCDG_TI, "1") ) {     /* Test CDR */
        fputs (raw_input, glb_RCdrfp);  /* reject the CDG record */
        fprintf(glb_Ignfp, "[DET] %s|TEST|TEST| ti(%s)\n", glb_Eindex, szCDG_TI);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* Added check for Reject Cause is not equal to "000" - by Thanakorn on 15-Aug-2012 */
    if ( strcmp(pbuf_cdg[CDG_CAUSE], "000") ) {   /* Reject when CDG_CAUSE != 000 */
        fputs (raw_input, glb_RCdrfp); /* reject the CDG record */
        fprintf(glb_Ignfp, "[DET] %s|Cause|Cause %s| only (000) accepted\n", glb_Eindex, pbuf_cdg[CDG_CAUSE]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_cdg[CDG_PPF], "0") ) {   /* Not Postpaid */
        fputs (raw_input, glb_RCdrfp); /* reject the CDG record */
        fprintf(glb_Ignfp, "[DET] %s|PPF|Not_Postpaid| ppf(%s)\n", glb_Eindex, pbuf_cdg[CDG_PPF]);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* Don't Feed AIS CDR when not included AIS Installation - Kawee on 29-Dec-2005 */
    if ( !glb_AisInstFlag && !strcmp(pbuf_cdg[CDG_COS], "51") ) {     /* Not Included AIS Installation */
        fputs (raw_input, glb_RCdrfp); /* reject the CDG record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS) cos(%s)\n", glb_Eindex, pbuf_cdg[CDG_COS]);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* Don't Feed DPC CDR when not included DPC Installation - Kawee on 29-Dec-2005 */
    if ( !glb_DpcInstFlag && !strcmp(pbuf_cdg[CDG_COS], "31") ) {     /* Not Included AIS Installation */
        fputs (raw_input, glb_RCdrfp); /* reject the CDG record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(dpc) cos(%s)\n", glb_Eindex, pbuf_cdg[CDG_COS]);
        glb_IgnCtr++;
        return FAILURE;
    }

    int cct = atoi(pbuf_cdg[CDG_CCT]);
    if ( cct < 9 || cct > 11 ) {     /* use only CCT = 09, 10 or 11 */
        if ( !*pbuf_cdg[CDG_CCT] ) {   /* CCT is Blank */
            fprintf(glb_Errfp, "[DET] %s|Field|CCT_Blank\n", glb_Eindex);
            glb_ErrCtr++;
            return FAILURE;
        }
        else {
            fputs(raw_input, glb_RCdrfp); /* reject the CDG record */
            fprintf(glb_Ignfp, "[DET] %s|Non_Charge|CCT %s\n", glb_Eindex, pbuf_cdg[CDG_CCT]);
            glb_IgnCtr++;
            return FAILURE;
        }
    }
    else {
        if ( cct == 9 )
            iCategories |= CAT_VAS_SUBS;
        else if ( cct == 10 )
            iCategories |= CAT_VAS_RECUR;
        else
            iCategories |= CAT_VAS_ONETIME;
    }

    if ( !*pbuf_cdg[CDG_CATID] ) {  /* CATID is Blank */
        fprintf(glb_Errfp, "[DET] %s|Field|CAT_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_cdg[CDG_CPID] ) {   /* CPID is Blank */
        fprintf(glb_Errfp, "[DET] %s|Field|CP_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_cdg[CDG_SID] ) {    /* SID is Blank */
        fprintf(glb_Errfp, "[DET] %s|Field|SID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_cdg[CDG_SGWID ]) {  /* SGWID is Blank */
        fprintf(glb_Errfp, "[DET] %s|Field|SGW_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    glb_EventId = VAS_EVENT_TYPE;

    /* Service Number */
    if ( Conv_Ano(pbuf_cdg[CDG_MSISDN], cdg_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strlen(cdg_event.mobile_num) < SIZE_PHONENO ) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, cdg_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* From Mobile Number */
    strcpy(cdg_event.from_number, cdg_event.mobile_num);
    strncpy(cdg_event.app_id, pbuf_cdg[CDG_APPID], sizeof(cdg_event.app_id)-1);

    if ( !IsValid_YYYYMMDDHHMMSS (pbuf_cdg[CDG_START]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| dcb_start_date_time(%s)\n",
                glb_Eindex, pbuf_cdg[CDG_START]);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strncmp(pbuf_cdg[CDG_START], glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fputs(raw_input, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
                glb_Eindex, pbuf_cdg[CDG_START], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    /* Seize Time & Date */
    //Seize_time = Calc_SeizeTime(pbuf_cdg[CDG_START], pbuf_cdg[CDG_START]+SIZE_YYYYMMDD);
    //sprintf(cdg_event.time_key, "%010ld", Seize_time);
    sprintf(cdg_event.time_key, "%s", pbuf_cdg[CDG_START]);

    /* Total Message Size (Kbytes) */
    sprintf(sVolume, "%010.0lf", ceil(atol(pbuf_cdg[CDG_SIZE]) / 1024.0));  /* Convert to Kbytes */
    strncpy(cdg_event.data_volume, sVolume+strlen(sVolume)-10 , 10);    /* Copy only Last 10 Chars */

    /* Content Contained Type */
    strcpy(cdg_event.content_type, pbuf_cdg[CDG_CCT]);

    /* Sub-Service ID */
    strcpy(cdg_event.service_id, pbuf_cdg[CDG_SID]);

    /* Service Category ID */
    strcpy(cdg_event.service_cat, pbuf_cdg[CDG_CATID]);

    /* Content Provider ID */
    strcpy(cdg_event.content_id, pbuf_cdg[CDG_CPID]);

    /* Service Gateway ID */
    strcpy(cdg_event.sgw_id, pbuf_cdg[CDG_SGWID]);

    strcpy(cdg_event.remarks, pbuf_cdg[CDG_MKTYPE]);        // service_name(3) from ori DCB file

    strcpy(cdg_event.charging_id, pbuf_cdg[CDG_SERF]);      // purchase_id(17) from ori DCB file

    /* Bearer Code */
    if ( Get_Bearer(pbuf_cdg[CDG_SGWID], bearer_code) ) {    /* Failure */
        fputs(raw_input, glb_RCdrfp);   /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Field|SGW_ID| sgwid(%s)\n", glb_Eindex, pbuf_cdg[CDG_SGWID]);
        glb_ErrCtr++;
        return FAILURE;
    }
    *cdg_event.bearer_code = *bearer_code;

    /* CDR Categories */
    if ( glb_MtxInd == DCBCT_TYPE ) {   // DCB as a ctudr cdr file
        iCategories |= CAT_TOTAL|CAT_VAS|CAT_LOCAL;
        Get_VasGroupCodeByGrpName(pbuf_cdg[CDG_MKTYPE], cdg_event.vas_grp);
    }
    else {
        iCategories |= CAT_TOTAL|CAT_APP_PURCHASE|CAT_LOCAL;
        strcpy(cdg_event.vas_grp, "8");     // google play;
    }
    sprintf(cdg_event.categories, "%08d", iCategories);

    // Directrion
    strcpy(cdg_event.direction, OUTGOING);   // Outgoing

    /* Detection Skip Parameters */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        /* Always skip collision check for cdg */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         /* Always skip velocity check for cdg */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        /* Always skip duplicate event check for CDR from VSCP */
    strcpy(cdg_event.detect_params, szDetParams);

    lCharge  = atol(pbuf_cdg[CDG_PFEE]);
    if ( strlen(pbuf_cdg[CDG_PDISC]) >= 6 ) {   // work around
        lPreDisc = 0;
    }
    else {
        lPreDisc = atol(pbuf_cdg[CDG_PDISC]);
    }
    if ( lPreDisc > 0 ) {
        lCharge = 0;
        strcpy(cdg_event.vas_name, "Case Refund");
    }
    else {
        strncpy(szTmpVasName, pbuf_cdg[CDG_PRODNO], 54);
        sprintf(cdg_event.vas_name, "%s", szTmpVasName);
    }
    sprintf(cdg_event.charge,   "%010ld", lCharge);
    sprintf(cdg_event.pre_disc, "%010ld", lPreDisc);

    return (CommonVas_To_Vas_Event(glb_MtxInd, (void *)&cdg_event));

}

/*------------------------------------------------------------------------------------*/
/* Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007 */
int DpcGsm_To_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> DpcGsm_To_Event");
    _p_ = 0;
#endif
    /* Feed This CDR only included DPC Installation - Kawee on 29-Dec-2005 */
    if ( !glb_DpcInstFlag) {     /* Not Included DPC Installation */
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp);    /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp(dpcgsm_buf.record_type, "10") ) {   /* Header Record */
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp); /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, dpcgsm_buf.record_type);
        //glb_IgnCtr++;
        return FAILURE;
    }
    else if ( !strcmp(dpcgsm_buf.record_type, "90") ) {  /* Trailer Record */
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp); /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|Format|Header_Trailer| header/trailer(%s)\n", glb_MtxType, dpcgsm_buf.record_type);
        //glb_IgnCtr++;
        return FAILURE;
    }
    else if ( !strcmp(dpcgsm_buf.record_type, "20") || !strcmp(dpcgsm_buf.record_type, "40") ||    /* Voice Call */
              !strcmp(dpcgsm_buf.record_type, "24") || !strcmp(dpcgsm_buf.record_type, "25") ||    /* mobile originate call */
              !strcmp(dpcgsm_buf.record_type, "43") || !strcmp(dpcgsm_buf.record_type, "44") ) {    /* call forward */
        return (DpcGsm_To_Voice_Event());
    }
    /* // removed by Thanakorn on 04-Sep-2013, because they will only use of FDA and SMSC
    else if ( !strcmp (dpcgsm_buf.record_type, "99") || !strcmp (dpcgsm_buf.record_type, "96") ||
             !strcmp (dpcgsm_buf.record_type, "71") || // Dropped Record Type
             !strcmp (dpcgsm_buf.record_type, "75") || !strcmp (dpcgsm_buf.record_type, "76") ) {
    */
    else if ( !strcmp(dpcgsm_buf.record_type, "99") ||
              !strcmp(dpcgsm_buf.record_type, "96") ||
              !strcmp(dpcgsm_buf.record_type, "71") ) {
        return (DpcGsm_To_Sms_Event() );
    }
    else {
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp); /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, dpcgsm_buf.record_type);
        glb_IgnCtr++;
        return FAILURE;
    }
}

/* ---------------------------------------------------------------------------------------------- */

/* Added Cdg_To_Cdg_Event function - by Jetsada on 09-Aug-2005 */
int Cdg_To_Cdg_Event ()
{
    /* initialize Common Structure buffer for each CDR */
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&cdg_event, 0x00, sizeof (cdg_event));

    /* Add Check as below by Kawee on 29-Dec-2005, modified by thanakorn on 17-Jun-2013 */
    if ( strcmp(pbuf_cdg[CDG_COS], "51") &&           /* GSM */
         strcmp(pbuf_cdg[CDG_COS], "31") &&           /* DPC */
         strcmp(pbuf_cdg[CDG_COS], "600001") &&       /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "600002") &&       /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "600003") &&       /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "600004") &&       /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "600005") &&       /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "600007") &&       /* AWN MVPN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "906") &&          /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "909") &&          /* AWN Postpaid */
         strcmp(pbuf_cdg[CDG_COS], "214") ) {          /* AWN Postpaid */
        fputs (raw_input, glb_RCdrfp); /* reject the CDG record */
        fprintf(glb_Ignfp, "[DET] %s|COS|COS %s\n", glb_Eindex, pbuf_cdg[CDG_COS]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp(pbuf_cdg[CDG_REC_TYPE], "ctudr") ) {
        return (Cdg_To_Cdg_Event_Ctudr());
    }
    else {
        fputs (raw_input, glb_RCdrfp);  /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, pbuf_cdg[CDG_REC_TYPE]);
        glb_IgnCtr++;
        return FAILURE;
    }
}

/*------------------------------------------------------------------------------------*/
/* Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007 */
int DpcGsm_To_Voice_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> DpcGsm_To_Voice_Event");
    _p_ = 0;
#endif
    int i;
    VOICE_RECORD voice_buf;

    memset(&voice_buf, 0x00, sizeof (voice_buf));

    strcpy(voice_buf.record_type, dpcgsm_buf.record_type);
    strcpy(voice_buf.imsi_no, dpcgsm_buf.imsi_no);
    strcpy(voice_buf.b_no, dpcgsm_buf.b_no);
    strcpy(voice_buf.a_no, dpcgsm_buf.a_no);
    strcpy(voice_buf.service_type, dpcgsm_buf.service_type);
    strcpy(voice_buf.service_id, dpcgsm_buf.service_id);
    strcpy(voice_buf.msc_id, dpcgsm_buf.msc_id);
    strcpy(voice_buf.cell_id_a, dpcgsm_buf.cell_id_a);
    strcpy(voice_buf.cell_id_b, dpcgsm_buf.cell_id_b);
    voice_buf.ms_class_mark = dpcgsm_buf.ms_class_mark;
    strcpy(voice_buf.start_date, dpcgsm_buf.start_date);
    strcpy(voice_buf.start_time, dpcgsm_buf.start_time);
    strcpy(voice_buf.duration, dpcgsm_buf.duration);
    strcpy(voice_buf.data_vol, dpcgsm_buf.data_vol);
    strcpy(voice_buf.data_vol_ref, dpcgsm_buf.data_vol_ref);
    strcpy(voice_buf.tariff_class, dpcgsm_buf.tariff_class);
    strcpy(voice_buf.ms_roaming_num, dpcgsm_buf.ms_roaming_num);
    voice_buf.charging_indicator = dpcgsm_buf.charging_indicator;
    strcpy(voice_buf.charging_origin, dpcgsm_buf.charging_origin);
    strcpy(voice_buf.originate_a_no, dpcgsm_buf.originate_a_no);
    strcpy(voice_buf.supplementary_code, dpcgsm_buf.supplementary_code);
    voice_buf.imei_a_b_c = dpcgsm_buf.imei_a_b_c;
    strcpy(voice_buf.imei, dpcgsm_buf.imei);
    strcpy(voice_buf.out_tgrp, dpcgsm_buf.out_tgrp);
    strcpy(voice_buf.in_tgrp, dpcgsm_buf.in_tgrp);
    strcpy(voice_buf.cause_termination, dpcgsm_buf.cause_termination);
    voice_buf.dual_serv_type = dpcgsm_buf.dual_serv_type;
    strcpy(voice_buf.dual_serv_code, dpcgsm_buf.dual_serv_code);
    voice_buf.channel_req = dpcgsm_buf.channel_req;
    voice_buf.channel_used = dpcgsm_buf.channel_used;
    voice_buf.transperancy_ind = dpcgsm_buf.transperancy_ind;
    for (i = 0; i < 5; i++) {   /* Table occurs 5 times */
        voice_buf.ss_event[i].action_code = dpcgsm_buf.ss_event[i].action_code;
        strcpy(voice_buf.ss_event[i].ss_code, dpcgsm_buf.ss_event[i].ss_code);
    }
    strcpy(voice_buf.service_key, "");
    strcpy(voice_buf.fci, "");

    return (CommonVoice_To_Voice_Event ("DPCGSM", &voice_buf, SIZE_DPCGSMRAW, raw_dpcgsm));
}

/*------------------------------------------------------------------------------------*/

int DpcGsm_To_Sms_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> DpcGsm_To_Sms_Event");
    _p_ = 0;
#endif
    //int             Ano_len = strlen(dpcgsm_buf.a_no);
    double          Charge = 0.0;
    //unsigned int    Duration = 0;   // Duration
    //time_t          Seize_time = 0; // Seize Time in Seconds
    double          Rate_Pm = 0.0;  // Rate Per Minute

    int iCategories = 0;
    //int iFeature = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    char net_orig[SIZE_NET+1];
    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    char costcode_name[SIZE_COSTCODE_NAME+1];
    char costgroup_id1[SIZE_COSTGROUP_ID+1];
    char costgroup_id2[SIZE_COSTGROUP_ID+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char rating_catalogue_id[SIZE_RATING_CATALOGUE_ID+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    char actual_rec_type[SIZE_ACTUAL_REC_TYPE+1];

    memset(net_orig, 0x00, sizeof(net_orig));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(costcode_name, 0x00, sizeof(costcode_name));
    memset(costgroup_id1, 0x00, sizeof(costgroup_id1));
    memset(costgroup_id2, 0x00, sizeof(costgroup_id2));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(rating_tariff_id, 0x00, sizeof(rating_tariff_id));
    memset(rating_catalogue_id, 0x00, sizeof(rating_catalogue_id));
    memset(fix_charge_mny, 0x00, sizeof(fix_charge_mny));
    memset(charge_rate, 0x00, sizeof(charge_rate));
    memset(actual_rec_type, 0x00, sizeof(actual_rec_type));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    // initialize Common Structure buffer for each CDR
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&sms_event, 0x00, sizeof (sms_event));

    if ( !strncmp(dpcgsm_buf.service_id, "12", 2) ) {       // Free of Charge
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp); // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Non_Charge|Service_ID %s| b_no(%s)\n", glb_Eindex, dpcgsm_buf.service_id, dpcgsm_buf.b_no);
        glb_IgnCtr++;
        return FAILURE;
    }
    // Event Type
    glb_EventId = SMS_EVENT_TYPE;   // SMS Event Type
    sprintf(sms_event.event_type, "%02d", glb_EventId);

    // Service Number
    // map a_no
    if ( Conv_DpcGsm_Ano() ) {
        return FAILURE;
    }

    strncpy(sms_event.mobile_num, com_buf.a_no, 16);
#ifdef DEBUG_ANO    // Use this for debug only
printf ("DPCGSM ano=%-30s => %s\n", dpcgsm_buf.a_no, sms_event.mobile_num);
#endif

    // From Mobile Number
    strncpy(sms_event.from_number, com_buf.a_no, 18);

    // To Mobile Number
    // map b_no
    if ( Conv_DpcGsm_Bno() ) {
        return FAILURE;
    }

    strncpy(sms_event.to_number, com_buf.b_no, 18);
    Conv_RealBno(sms_event.to_number, sms_event.bno);   // get exact bno (without any access code)
#ifdef DEBUG_BNO    // Use this for debug only
printf ("DPCGSM bno=%-30s => %s\n", dpcgsm_buf.b_no, sms_event.to_number);
#endif

    // Introduced AIN - Added below by Kawee on 04-Jan-2007
    if ( !strncmp(sms_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||    // AIN 3rd Product Intl - Added by Kawee on 11-Nov-2009
         !strncmp(sms_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||    // AIN 2nd Product Intl - Added by Kawee on 25-Aug-2008
         !strncmp(sms_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||    // AIN Intl
         !strncmp(sms_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
         !strncmp(sms_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
         !strncmp(sms_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {   // AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp);     // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Send_SMS_AIN_Number|AIN_Number %s\n", glb_Eindex, dpcgsm_buf.b_no);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
    if ( !IsValid_YYYYMMDD_HHMMSS (dpcgsm_buf.start_date, dpcgsm_buf.start_time) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date(%s) start_time(%s)\n",
            glb_Eindex, dpcgsm_buf.start_date, dpcgsm_buf.start_time);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008
    if ( strncmp(dpcgsm_buf.start_date, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp);     // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n",
            glb_Eindex, dpcgsm_buf.start_date, dpcgsm_buf.start_time, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // Seize Time & Date
    //Seize_time = Calc_SeizeTime(dpcgsm_buf.start_date, dpcgsm_buf.start_time);
    //sprintf(sms_event.time_key, "%010ld", Seize_time);
    sprintf(sms_event.time_key, "%s%s", dpcgsm_buf.start_date, dpcgsm_buf.start_time);

    // Direction
    strcpy(sms_event.direction, OUTGOING);      // Outgoing Call

    // Country Code Called
    strcpy(sms_event.country_code, "66");   // default for Thailand

    if ( !strcmp(dpcgsm_buf.record_type, "99") &&
        (!strncmp(sms_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
         !strncmp(sms_event.to_number, EPHACC_CODE, EPHACC_LEN) ||
         !strncmp(sms_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
         !strncmp(sms_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
         !strncmp(sms_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN)) ) {
        switch ( Parse_Country(sms_event.to_number, sms_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, sms_event.to_number);
                glb_ErrCtr++;
                return FAILURE;
        }
    }

    // SMS Type
    // strcpy(sms_event.sms_type, dpcgsm_buf.record_type);

    // CDR Categories
    if ( strcmp(sms_event.country_code, "66") == 0 ) {
        iCategories |= CAT_TOTAL|CAT_SMS|CAT_LOCAL;
    }
    else {
        iCategories |= CAT_TOTAL|CAT_SMS|CAT_IDD;
    }
    sprintf(sms_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        // skip collision
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         // skip velocity
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        // skip duplication check for non voice events
    strcpy(sms_event.detect_params, szDetParams);

    // Charge in Satang
    Rate_Pm = 0.0;
    Charge = 0.0;
    strcpy(banding_model_id, "3");

    strcpy(costcode, "DPC");
    if ( Get_RmCostGroupId(banding_model_id, costcode, costgroup_id2) ) {
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp);     // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| cell_ida(%s)\n", glb_Eindex, costcode);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !strcmp(dpcgsm_buf.record_type, "71") ) {
        strcpy(costcode, "SMS");
        strcpy(event_class_id, "21");
    }
    else if ( !strcmp(dpcgsm_buf.record_type, "96") ) {
        strcpy(costcode, "DEL_R");
        strcpy(event_class_id, "24");
    }
    else if ( !strcmp(dpcgsm_buf.record_type, "99") ) {
        if ( (!strncmp(sms_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
              !strncmp(sms_event.to_number, EPHACC_CODE, EPHACC_LEN) ||
              !strncmp(sms_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
              !strncmp(sms_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
              !strncmp(sms_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN)) &&
              strncmp(sms_event.to_number+3, "66", 2) ) {   // Intl' SMS
            sprintf(costcode, "001%s", sms_event.to_number+3);
        }
        else {  // Domestic SMS
            strcpy(costcode, "SMS");
        }
        strcpy(event_class_id, "26");
    }

    if ( Get_RmCostGroupId(banding_model_id, costcode, costgroup_id1) ) {
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp);     // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( Get_XfCostBandId (banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp);     // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| costgroup_id1(%s) costgroup_id2(%s)\n",
        glb_Eindex, costgroup_id1, costgroup_id2);
        glb_ErrCtr++;
        return FAILURE;
    }

    strcpy(rating_tariff_id, "6");      // Rating Tariff Id for DPC Sms is 6

    if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
        fwrite(&raw_dpcgsm, SIZE_DPCGSMRAW, 1, glb_RCdrfp);     // reject the record
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
            glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
        glb_ErrCtr++;
        Charge = 0.0;
        return FAILURE;
    }
    else {
        Charge = atof(fix_charge_mny) / 10;     // Convert to Satang
    }

        // Service_id
    strcpy(sms_event.service_id, dpcgsm_buf.service_id);   // Just copy

    // ------------------------------------------------
    // cell_id_a is 15 digit
    //
    // position: 1 2 3 4 5  6 7 8 9 10  11 12 13 14 15
    // eg valu   2 3 4 5 6  3 4 5 6  8   5  7  9  3  1
    // ------------------------------------------------
    // CI  = 11 - 15 => Cell        -> 57931
    // LAC =  6 - 10 => Cell Set    -> 34568
    //     =  8 -  9 => Cell Area   -> 00056
    // ------------------------------------------------
#if 0
    strncpy(sms_event.cell, dpcgsm_buf.cell_id_a+10, 5);
    strncpy(sms_event.cell_set, dpcgsm_buf.cell_id_a+5, 5);
    strcpy(sms_event.cell_area, "000");
    strncpy(sms_event.cell_area+3, dpcgsm_buf.cell_id_a+7, 2);
#endif

    if ( Get_GeoData(dpcgsm_buf.cell_id_a, sms_event.cell, sms_event.cell_set, sms_event.cell_area) != SUCCESS ) {
        fprintf(glb_Errfp, "[DET] %s|GeoMapp|Cell_IDA| cell_id_a(%s) but not skip\n", glb_Eindex, dpcgsm_buf.cell_id_a);
        strcpy(sms_event.cell_area, DEF_CELL_AREA);
    }

    // ----- not yet mapping fields -----
    // sms_event.remarks
    // sms_event.business_code
    // sms_event.pre_disc
    // sms_event.payment_type
    // sms_event.fee_charge
    // ----- not yet mapping fields -----

    strcpy(sms_event.partition_id, AWN_PARTITION);
    sprintf(sms_event.charge, "%010.0lf", Charge);
    strcpy(sms_event.original_bno, glb_OriginalBno);
    strcpy(sms_event.event_src, glb_EventSource);

    return SUCCESS;
}


int Read_OcsVpn_Cdr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_OcsVpn_Cdr");
    _p_ = 0;
#endif
    memset(pbuf_ocsvpn, 0x00, sizeof(pbuf_ocsvpn));
    memset(&gsm_buf, 0x00, sizeof(gsm_buf));

    if ( Read_Delimiter_Cdr('|', NOF_FLD_OCS, pbuf_ocsvpn) != SUCCESS ) {
        return FAILURE;
    }
    else {
        /* Do field mapping to be a type of GSM, so that this data can go through Awn_To_Event function */
        strcpy(gsm_buf.record_type, "54");                           // GSM Mobile Terminated Call
        strcpy(gsm_buf.a_no, pbuf_ocsvpn[OCS_CALLED_NO]);
        strcpy(gsm_buf.b_no, pbuf_ocsvpn[OCS_CALLER_NO]);
        strcpy(gsm_buf.service_type, "01");
        strcpy(gsm_buf.msc_id, "6692301050");                        // indicates Maritime
        strcpy(gsm_buf.cell_id_a, pbuf_ocsvpn[OCS_CALLED_LAC]);
        strcpy(gsm_buf.data_vol_ref, "OCSVPN");                      // mark this field to indicate Maritime MT
                                                                    // for internal use only

        strncpy(gsm_buf.start_date, pbuf_ocsvpn[OCS_START_DT], 8);   // cut first 8 characters of OCS_START_DT
        strcpy(gsm_buf.start_time,  pbuf_ocsvpn[OCS_START_DT] + 8);  // cut from 9th character of OCS_START_DT
        strcpy(gsm_buf.duration, pbuf_ocsvpn[OCS_DURATION]);

        if ( strncmp(pbuf_ocsvpn[OCS_IMSI], "520", 3) == 0 ) {      // if this field is IMSI do copy otherwise NULL`
            strcpy(gsm_buf.imsi_no, pbuf_ocsvpn[OCS_IMSI]);
        }

        if ( strcmp(pbuf_ocsvpn[OCS_BEARER_CAP], "8") == 0 ) {      // video call
            strcpy(gsm_buf.service_id, "37");
        }
        return SUCCESS;
    }
}

/*------------------------------------------------------------------------------------*/

int Read_Amf_Cdr()
{
    memset(pbuf_amf, 0x00, sizeof (pbuf_amf));
    return (Read_Delimiter_Cdr (',', NOF_FLD_AMF, pbuf_amf));
}

int Amf_To_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Amf_To_Event");
    _p_ = 0;
#endif
    char    sNetOrig[SIZE_NET+1];
    char    sCostgroupId[SIZE_COSTGROUP_ID+1];
    char    sCostbandId[SIZE_COSTBAND_ID+1];
    char    sBandingModelId[1+1];
    char    sRatingTariffId[SIZE_RATING_TARIFF_ID+1];
    char    sEventClassId[SIZE_EVENT_CLASS_ID+1];
    char    sFixChargeMny[SIZE_FIXED_CHARGE+1];
    char    sChargeRate[SIZE_CHARGE_RATE+1];
    char    szCostcode[SIZE_COSTCODE+1];
    char    szDetParams[SKIP_DET_STR_SIZE];

    char    sServiceId[10];
    char    sDate[9];
    char    sTime[7];
    char    szTemp[10];
    char    company_name[50+1];
    char    service_name[50+1];

    int     iCategories = 0;
    //time_t  Seize_time = 0; // Seize Time in Seconds

    // initialize Common Structure buffer for each CDR
    memset(&amf_event, 0x00, sizeof(amf_event));

    memset(sNetOrig, 0x00, sizeof(sNetOrig));
    memset(sCostgroupId, 0x00, sizeof(sCostgroupId));
    memset(sCostbandId, 0x00, sizeof(sCostbandId));
    memset(sBandingModelId, 0x00, sizeof(sBandingModelId));
    memset(szCostcode, 0x00, sizeof(szCostcode));
    memset(sRatingTariffId, 0x00, sizeof(sRatingTariffId));
    memset(sEventClassId, 0x00, sizeof(sEventClassId));
    memset(sFixChargeMny, 0x00, sizeof(sFixChargeMny));
    memset(sChargeRate, 0x00, sizeof(sChargeRate));
    memset(sServiceId, 0x00, sizeof(sServiceId));
    memset(szTemp, 0x00, sizeof(szTemp));
    memset(company_name, 0x00, sizeof(company_name));
    memset(service_name, 0x00, sizeof(service_name));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    strncpy(sDate, pbuf_amf[AMF_TIMESTAMP], 8);
    sDate[8] = 0;
    strcpy(sTime, pbuf_amf[AMF_TIMESTAMP] + 9);
    sTime[6] = 0;

    if ( strcmp(pbuf_amf[AMF_PARTNER_CODE], "MIGR") == 0 ) {
        fputs (raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Invalid|Partner_Code %s\n", glb_Eindex, pbuf_amf[AMF_PARTNER_CODE]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_amf[AMF_SSS_TYPE], "B") != 0 ) {
        fputs (raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Invalid|SSS_Type %s\n", glb_Eindex, pbuf_amf[AMF_SSS_TYPE]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !*pbuf_amf[AMF_SVC_ID] ) {     // Service Id is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|SERV_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    // Service Number
    if ( Conv_Ano(pbuf_amf[AMF_MSISDN], amf_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strlen(amf_event.mobile_num) < SIZE_PHONENO) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, amf_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_amf[AMF_ORG_ACC_TYPE], "pos") == 0 ) {
        if ( strcmp(pbuf_amf[AMF_COS], "31") == 0 ) {       // DPC
            // skip first character for DPC, which is '8'
            strcpy(sServiceId, pbuf_amf[AMF_SVC_ID] + 1);
        }
        else {      // AIS
            strcpy(sServiceId, pbuf_amf[AMF_SVC_ID]);
        }
    }
    else if ( strcmp(pbuf_amf[AMF_ORG_ACC_TYPE], "pps") == 0) {
        strcpy(sServiceId, pbuf_amf[AMF_SVC_ID]);
    }
    else {
        fputs (raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Acc_Type|Acc_Type %s\n", glb_Eindex, pbuf_amf[AMF_ORG_ACC_TYPE]);
        glb_IgnCtr++;
        return FAILURE;
    }
    glb_EventId = VAS_EVENT_TYPE;

    if ( !glb_AisInstFlag &&                            // Not Included AIS Installation
         !strcmp(pbuf_amf[AMF_ORG_ACC_TYPE], "pos") &&  // AIS CDR
         strcmp(pbuf_amf[AMF_COS], "31") ) {            // Not 31 is AIS
        fputs (raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS) org_acc_type(%s) cos(%s)\n",
                 glb_Eindex, pbuf_amf[AMF_ORG_ACC_TYPE], pbuf_amf[AMF_COS]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !glb_DpcInstFlag &&                            // Not Included AIS Installation
         !strcmp(pbuf_amf[AMF_ORG_ACC_TYPE], "pos") &&  // AIS CDR
         !strcmp(pbuf_amf[AMF_COS], "31") ) {           // 31 is DPC
        fputs (raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC) org_acc_type(%s) cos(%s)\n",
                 glb_Eindex, pbuf_amf[AMF_ORG_ACC_TYPE], pbuf_amf[AMF_COS]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !glb_12cInstFlag && !strcmp(pbuf_amf[AMF_ORG_ACC_TYPE], "pps") ) { // Not Included 12C Installation
        fputs (raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|12C| not included(12c) org_acc_type(%s) cos(%s)\n",
                 glb_Eindex, pbuf_amf[AMF_ORG_ACC_TYPE], pbuf_amf[AMF_COS]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !glb_AisInstFlag && !strcmp(sNetOrig, "GSM") ) {   // Not Included AIS Installation
        fputs (raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS) network(%s)\n", glb_Eindex, sNetOrig);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !glb_DpcInstFlag && !strcmp(sNetOrig, "DPC") ) {   // Not Included DPC Installation
        fputs (raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC) network(%s)\n", glb_Eindex, sNetOrig);
        glb_IgnCtr++;
        return FAILURE;
    }

    // From Number
    strncpy(amf_event.from_number, pbuf_amf[AMF_MSISDN], 18);
    amf_event.from_number[18] = 0;

    if ( !IsValid_YYYYMMDD_HHMMSS(sDate, sTime) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date_time(%s)\n", glb_Eindex, pbuf_amf[AMF_TIMESTAMP]);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strncmp(pbuf_amf[AMF_TIMESTAMP], glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fputs (raw_input, glb_RCdrfp);  // reject the record
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
            glb_Eindex, pbuf_amf[AMF_TIMESTAMP], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // Time Key
    //Seize_time = Calc_SeizeTime (sDate, sTime);
    //sprintf(amf_event.time_key, "%010ld", Seize_time);
    sprintf(amf_event.time_key, "%s%s", sDate, sTime);

    // Service Id
    strcpy(amf_event.service_id, sServiceId);

    if ( !*pbuf_amf[AMF_CAT_ID] ) {     // Category Id is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|CAT_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_amf[AMF_CON_ID] ) {     // Con Id is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|Content_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_amf[AMF_BEARER] ) {     // Bearer is Blank
        fprintf(glb_Errfp, "[DET] %s|Rating|Bearer_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_amf[AMF_CCT] ) {        // CCT is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|CCT_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_amf[AMF_PACK_ID] ) {    // Pack Id is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|PACK_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    // Charge
    sprintf(szCostcode, "%s%s%06d%s%s%s", pbuf_amf[AMF_CAT_ID], pbuf_amf[AMF_CON_ID], atoi(sServiceId), pbuf_amf[AMF_BEARER], pbuf_amf[AMF_CCT], pbuf_amf[AMF_PACK_ID]);

    strcpy(sBandingModelId, "4");
    if ( !strcmp(pbuf_amf[AMF_COS], "31"))      // DPC
        strcpy(sRatingTariffId, "56");
    else
        strcpy(sRatingTariffId, "7");           // GSM, AWN

    strcpy(sEventClassId, "27");

    // Lookup Cost Code Table by using banding_model_id and costcode to get cost_band_id
    if ( Get_RmCostBandId2(sBandingModelId, szCostcode, sCostbandId, amf_event.vas_name) ) {  // FAILURE
        fputs (raw_input, glb_RCdrfp);  // reject the AMF record
        fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Code| banding_model_id(%s) costcode(%s)\n", glb_Eindex, sBandingModelId, szCostcode);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( Get_VasGroupCodeByGrpName(gszCostcode_Desc, amf_event.vas_grp) != SUCCESS ) {
        Get_VasGroupCodeByGrpName(gszCostcode_Name, amf_event.vas_grp);
    }

    //
    // Lookup Rating Element Table by using rate_tariff_id, cost_band_id, event_class_id
    // to get fix_charge_mny and charge_rate
    //
    if ( Parse_RatingElement3(sRatingTariffId, sCostbandId, sEventClassId, sFixChargeMny, sChargeRate) ) {
        fputs (raw_input, glb_RCdrfp);  // reject the AMF record
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
                 glb_Eindex, sRatingTariffId, sCostbandId, sEventClassId);
        glb_ErrCtr++;
        return FAILURE;
    }

    // Charge , Unit in Baht
    if ( *sFixChargeMny)
        sprintf(amf_event.charge, "%010ld", (atol(sFixChargeMny)/1000)*100);    // convert to Satang by x 100
    else if ( *sChargeRate)
        sprintf(amf_event.charge, "%010ld", (atol(sChargeRate)/100000)*100);    // convert to Satang by x 100
    else
    {
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
            glb_Eindex, sRatingTariffId, sCostbandId, sEventClassId);
        glb_ErrCtr++;
        return FAILURE;
    }

    //strcpy(amf_event.pack_id, pbuf_amf[AMF_PACK_ID]);
    strcpy(amf_event.cat_id, pbuf_amf[AMF_CAT_ID]);
    strcpy(amf_event.cpid, pbuf_amf[AMF_PARTNER_CODE]);
    strcpy(amf_event.con_id, pbuf_amf[AMF_CON_ID]);
    //strcpy(amf_event.cct, pbuf_amf[AMF_CCT]);
    //strcpy(amf_event.bearer_code, pbuf_amf[AMF_BEARER]);

    int cct = atoi(pbuf_amf[AMF_CCT]);
    if ( cct == 9 )
        iCategories |= CAT_VAS_SUBS;
    else if ( cct == 10 )
        iCategories |= CAT_VAS_RECUR;
    else if ( cct == 11 )
        iCategories |= CAT_VAS_ONETIME;

    // CDR Categories
    iCategories |= CAT_TOTAL|CAT_VAS|CAT_LOCAL;    // Set to Total, VAS Category
    sprintf(amf_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        // Always skip collision check for usc
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        // skip duplication check for non voice events
    strcpy(amf_event.detect_params, szDetParams);

    return (CommonVas_To_Vas_Event(glb_MtxInd, (void *)&amf_event));

}
// ------------------------------------------------------------------------------------

int Read_Sdg_Cdr()
{
    memset(pbuf_sdg, 0x00, sizeof (pbuf_sdg));
    return (Read_Delimiter_Cdr (',', NOF_FLD_SDG, pbuf_sdg));
}

int Sdg_To_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Sdg_To_Event");
    _p_ = 0;
#endif
    char sNetOrig[SIZE_NET+1];
    char sCostgroupId[SIZE_COSTGROUP_ID+1];
    char sCostbandId[SIZE_COSTBAND_ID+1];
    char sBandingModelId[2+1];
    char sRatingTariffId[SIZE_RATING_TARIFF_ID+1];
    char sEventClassId[SIZE_EVENT_CLASS_ID+1];
    char sFixChargeMny[SIZE_FIXED_CHARGE+1];
    char sChargeRate[SIZE_CHARGE_RATE+1];
    char szCostcode[SIZE_COSTCODE+1];
    char szTemp[10];
    char company_name[50+1];
    char service_name[50+1];

    char sDate[9];
    char sTime[7];

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];
    //time_t Seize_time = 0; // Seize Time in Seconds

    // initialize Common Structure buffer for each CDR
    // SDG uses the same event structure as AMF
    memset(&amf_event, 0x00, sizeof(amf_event));

    memset(sNetOrig, 0x00, sizeof(sNetOrig));
    memset(sCostgroupId, 0x00, sizeof(sCostgroupId));
    memset(sCostbandId, 0x00, sizeof(sCostbandId));
    memset(sBandingModelId, 0x00, sizeof(sBandingModelId));
    memset(szCostcode, 0x00, sizeof(szCostcode));
    memset(sRatingTariffId, 0x00, sizeof(sRatingTariffId));
    memset(sEventClassId, 0x00, sizeof(sEventClassId));
    memset(sFixChargeMny, 0x00, sizeof(sFixChargeMny));
    memset(sChargeRate, 0x00, sizeof(sChargeRate));
    memset(szTemp, 0x00, sizeof(szTemp));
    memset(company_name, 0x00, sizeof(company_name));
    memset(service_name, 0x00, sizeof(service_name));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    strncpy(sDate, pbuf_sdg[SDG_TIMESTAMP], 8);
    sDate[8] = 0;
    strcpy(sTime, pbuf_sdg[SDG_TIMESTAMP] + 8);
    sTime[6] = 0;


    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_SDG] == 0 ) {
        // Reject BOS online record, added by Thanakorn on 26-Aug-2013
        // ignore servpackid = 5 (5 - BOS� 2G,3G)
        if ( atoi(pbuf_sdg[SDG_SRVPKID]) == 5 ) {
            fputs(raw_input, glb_RCdrfp);  // reject the record
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| servpackid(%s)\n", glb_Eindex, pbuf_sdg[SDG_SRVPKID]);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    if ( !glb_AisInstFlag ) {       // Not Included AIS Installation
        fputs(raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_sdg[SDG_REC_TYPE], "20") != 0 ) {
        fputs(raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, pbuf_sdg[SDG_REC_TYPE]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !*pbuf_sdg[SDG_CCT] ) {        // CCT is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|CCT_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_sdg[SDG_CCT], "10") && strcmp(pbuf_sdg[SDG_CCT], "11") ) { // only 10,11 otherwise reject
        fputs(raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|CCT|CCT %s\n", glb_Eindex, pbuf_sdg[SDG_CCT]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_sdg[SDG_PPF], "0") )   {   // Reject when ppf != 0
        fputs(raw_input, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|PPF|Invalid| ppf(%s)\n", glb_Eindex, pbuf_sdg[SDG_PPF]);
        glb_IgnCtr++;
        return FAILURE;
    }

    // Service Number
    if ( Conv_Ano(pbuf_sdg[SDG_ANO], amf_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strlen(amf_event.mobile_num) < SIZE_PHONENO) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, amf_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }
    glb_EventId = VAS_EVENT_TYPE;

    // From Number
    strcpy(amf_event.from_number, amf_event.mobile_num);

    if ( !IsValid_YYYYMMDD_HHMMSS(sDate, sTime) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date_time(%s)\n", glb_Eindex, pbuf_sdg[SDG_TIMESTAMP]);
        glb_ErrCtr++;
        return FAILURE;
    }

    // Time Key
    //Seize_time = Calc_SeizeTime (sDate, sTime);
    //sprintf(amf_event.time_key, "%010ld", Seize_time);
    sprintf(amf_event.time_key, "%s%s", sDate, sTime);

    // Service Id
    strcpy(amf_event.service_id, pbuf_sdg[SDG_SERVID]);

    if ( !*pbuf_sdg[SDG_CATID] ) {      // Category Id is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|CAT_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_sdg[SDG_CONT_ID] ) {    // Con Id is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|Content_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_sdg[SDG_BEARER] ) {     // Bearer is Blank
        fprintf(glb_Errfp, "[DET] %s|Rating|Bearer_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !*pbuf_sdg[SDG_PACKID] ) {    // Pack Id is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|PACK_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    // Charge
    strcpy(sBandingModelId, "4");
    sprintf(szCostcode, "%s%s%06d%s%s%s", pbuf_sdg[SDG_CATID], pbuf_sdg[SDG_CONT_ID], atoi(pbuf_sdg[SDG_SERVID]), pbuf_sdg[SDG_BEARER], pbuf_sdg[SDG_CCT], pbuf_sdg[SDG_PACKID]);

    // Lookup Cost Code Table by using banding_model_id and costcode to get cost_band_id
    if ( Get_RmCostBandId2(sBandingModelId, szCostcode, sCostbandId, amf_event.vas_name) ) {        // FAILURE
        strcpy(sBandingModelId, "12");
        if ( Get_RmCostBandId2(sBandingModelId, szCostcode, sCostbandId, amf_event.vas_name) ) {    // FAILURE
            fputs(raw_input, glb_RCdrfp);  // reject the AMF record
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Code| banding_model_id(%s) costcode(%s)\n", glb_Eindex, sBandingModelId, szCostcode);
            glb_ErrCtr++;
            return FAILURE;
        }
    }
    if ( Get_VasGroupCodeByGrpName(gszCostcode_Desc, amf_event.vas_grp) != SUCCESS ) {
        Get_VasGroupCodeByGrpName(gszCostcode_Name, amf_event.vas_grp);
    }

    strcpy(sRatingTariffId, "7");
    strcpy(sEventClassId, "27");
    //
    // Lookup Rating Element Table by using rate_tariff_id, cost_band_id, event_class_id
    // to get fix_charge_mny and charge_rate
    //
    if ( Parse_RatingElement2(sRatingTariffId, sCostbandId, sFixChargeMny, sChargeRate) ) {
        fputs(raw_input, glb_RCdrfp);  // reject the AMF record
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s)\n",
                 glb_Eindex, sRatingTariffId, sCostbandId);
        glb_ErrCtr++;
        return FAILURE;
    }

    // Charge, Unit in Baht
    if ( *sFixChargeMny)
        sprintf(amf_event.charge, "%010ld", (atol(sFixChargeMny)/1000)*100);  // convert to Satang by x 100
    else if ( *sChargeRate)
        sprintf(amf_event.charge, "%010ld", (atol(sChargeRate)/100000)*100);  // convert to Satang by x 100
    else
    {
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
            glb_Eindex, sRatingTariffId, sCostbandId, sEventClassId);
        glb_ErrCtr++;
        return FAILURE;
    }

    // Direction
    strcpy(amf_event.direction, OUTGOING);   // Outgoing

    // Charging Id
    strcpy(amf_event.service_id, pbuf_sdg[SDG_CHGID]);
    strcpy(amf_event.cat_id, pbuf_sdg[SDG_CATID]);
    strcpy(amf_event.cpid, pbuf_sdg[SDG_CONT_ID]);
    strcpy(amf_event.app_id, pbuf_sdg[SDG_BNO]);
    //strcpy(amf_event.bearer_code, pbuf_sdg[SDG_BEARER]);
    //strcpy(amf_event.cct, pbuf_sdg[SDG_CCT]);
    //strcpy(amf_event.pack_id, pbuf_sdg[SDG_PACKID]);

    // Short Code
    strrcpy(szTemp, pbuf_sdg[SDG_SERVID], 5);
    sprintf(amf_event.short_code, "%s%s%s%s", szTemp, pbuf_sdg[SDG_CCT], pbuf_sdg[SDG_CATID], pbuf_sdg[SDG_CONT_ID]);

    // Vas Description
    Get_UsMapData(szTemp, pbuf_sdg[SDG_CATID], pbuf_sdg[SDG_CONT_ID], pbuf_sdg[SDG_CCT], company_name, service_name);
    sprintf(amf_event.vas_desc, "%s, %s", company_name, service_name);

    int cct = atoi(pbuf_sdg[SDG_CCT]);
    if ( cct == 9 )
        iCategories |= CAT_VAS_SUBS;
    else if ( cct == 10 )
        iCategories |= CAT_VAS_RECUR;
    else if ( cct == 11 )
        iCategories |= CAT_VAS_ONETIME;

    // CDR Categories
    iCategories |= CAT_TOTAL|CAT_VAS|CAT_LOCAL;    // Set to Total, VAS Category
    sprintf(amf_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        // Always skip collision check for usc
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        // skip duplication check for non voice events
    strcpy(amf_event.detect_params, szDetParams);

    return (CommonVas_To_Vas_Event(glb_MtxInd, (void *)&amf_event));

}
//------------------------------------------------------------------------------------

int Usc_To_Usc_Event ()
{
    //int Ano_len = 0;

    //time_t  Seize_time = 0; /* Seize Time in Seconds */

    char    sNetOrig[SIZE_NET+1];
    char    sCostgroupId[SIZE_COSTGROUP_ID+1];
    char    sCostbandId[SIZE_COSTBAND_ID+1];
    char    sBandingModelId[1+1];
    char    sCostcode[SIZE_COSTCODE+1];
    char    sRatingTariffId[SIZE_RATING_TARIFF_ID+1];
    char    sEventClassId[SIZE_EVENT_CLASS_ID+1];
    char    sFixChargeMny[SIZE_FIXED_CHARGE+1];
    char    sChargeRate[SIZE_CHARGE_RATE+1];

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    /* initialize Common Structure buffer for each CDR */
    memset(&com_buf, 0x00, sizeof (com_buf));
    memset(&usc_event, 0x00, sizeof(usc_event));

    memset(sNetOrig, 0x00, sizeof(sNetOrig));
    memset(sCostgroupId, 0x00, sizeof(sCostgroupId));
    memset(sCostbandId, 0x00, sizeof(sCostbandId));
    memset(sBandingModelId, 0x00, sizeof(sBandingModelId));
    memset(sCostcode, 0x00, sizeof(sCostcode));
    memset(sRatingTariffId, 0x00, sizeof(sRatingTariffId));
    memset(sEventClassId, 0x00, sizeof(sEventClassId));
    memset(sFixChargeMny, 0x00, sizeof(sFixChargeMny));
    memset(sChargeRate, 0x00, sizeof(sChargeRate));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_USC] == 0 ) {
        /* Reject BOS online record, added by Thanakorn on 26-Aug-2013 */
        /* ignore payment (cos_a) = 3, 4,5 and 6:
        //    3�-> BOS-2G Postpaid
        //    4 -> BOS-2G Prepaid
        //    5 -> BOS-3G Postpaid
        //    6 -> BOS-3G Prepaid
        */
        if ( atoi(usc_buf.payment_type) >= 3 && atoi(usc_buf.payment_type) <= 6 ) {
            fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* reject the record */
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| cos_a(%s)\n", glb_Eindex, usc_buf.payment_type);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    if ( strcmp(usc_buf.record_type, "20") && strcmp(usc_buf.record_type, "30") ) { /* Dropped Record Type */
        fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, usc_buf.record_type);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* Check if Non-Charge Call and Reject - Chamy 09-Jan-2002 */
    if ( usc_buf.charge_flag == '0') {       /* free of charge */
        fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Non_Charge|Charge_Flag %c\n", glb_Eindex, usc_buf.charge_flag);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* Check for the Category_Id should not blank. This field value use for calculate rating */
    if ( *usc_buf.category_id == '\0' ) {
        fprintf(glb_Errfp, "[DET] %s|Field|CAT_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    else {  /* Add ignore the following category_id by Thanakorn on 05-Nov-2013 */
        if ( strcmp(usc_buf.category_id, "903") == 0 ||
             strcmp(usc_buf.category_id, "910") == 0 ||
             strcmp(usc_buf.category_id, "911") == 0 ||
             strcmp(usc_buf.category_id, "912") == 0 ) {
                fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* reject the record */
                fprintf(glb_Ignfp, "[DET] %s|Bulk_Corp|Bulk_Corp %s\n", glb_Eindex, usc_buf.category_id);
                glb_IgnCtr++;
                return FAILURE;
        }
    }

    /* Check for the Content_Id should not blank. This field value use for calculate rating */
    if ( *usc_buf.content_id == '\0' ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Content_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Check for the Service_Id should not blank. This field value use for calculate rating */
    if ( *usc_buf.service_id == '\0' ) {
        fprintf(glb_Errfp, "[DET] %s|Field|SERV_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Check for the Bearer should not blank. This field value use for calculate rating */
    if ( usc_buf.bearer == ' ') {
        fprintf(glb_Errfp, "[DET] %s|Rating|Bearer_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    glb_EventId = VAS_EVENT_TYPE;

    /* Service Number */
    if ( Conv_Ano(usc_buf.a_no, usc_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( strlen(usc_event.mobile_num) < SIZE_PHONENO) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, usc_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }

    /*
    ** Changed concept of payment type to Prepaid/Postpaid Flag as below
    ** 0 = unknown
    ** 1 = GSM => Convert to 0 to map with IRB
    ** 2 = One2Call
    ** 3 = FR1
    ** 4 = Test
    ** 5 = FR2
    ** 6 = FR3
    ** 7 = AWN Post-paid*
    ** 8 = DPC
    ** 9 = AWN Pre-paid*
    ** 101 = VIP1
    ** - by Kawee on 11-Feb-2008
    */
    /* Don't Feed AIS CDR when not included AIS Installation - Kawee on 29-Dec-2005 */
    if ( !glb_AisInstFlag &&                     /* Not Included AIS Installation */
        (!strcmp(usc_buf.payment_type, "1") ||          /* AIS CDR */
         !strcmp(usc_buf.payment_type, "0")) ) {         /* Unknownn CDR */
        fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS) payment_type(%s)\n",
            glb_Eindex, usc_buf.payment_type);
        glb_IgnCtr++;
        return FAILURE;
    }
    if ( !glb_DpcInstFlag && !strcmp(usc_buf.payment_type, "8") ) {   /* Not Included DPC Installation */
        fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC) payment_type(%s)\n",
            glb_Eindex, usc_buf.payment_type);
        glb_IgnCtr++;
        return FAILURE;
    }
    if ( !glb_12cInstFlag && !strcmp(usc_buf.payment_type, "2") ) {   /* Not Included 12C Installation */
        fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|12C| not included(12c) payment_type(%s)\n",
            glb_Eindex, usc_buf.payment_type);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* From Number */
    strcpy(usc_event.from_number, usc_event.mobile_num);

    /* Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007 */
    if ( !IsValid_YYYYMMDD_HHMMSS (usc_buf.start_date, usc_buf.start_time) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date(%s) start_time(%s)\n",
            glb_Eindex, usc_buf.start_date, usc_buf.start_time);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008 */
    if ( strncmp(usc_buf.start_date, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n",
            glb_Eindex, usc_buf.start_date, usc_buf.start_time, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    /* Time Key */
    //Seize_time = Calc_SeizeTime (usc_buf.start_date, usc_buf.start_time);
    //sprintf(usc_event.time_key, "%010ld", Seize_time);
    sprintf(usc_event.time_key, "%s%s", usc_buf.start_date, usc_buf.start_time);


    /* Charge */
    sprintf(sCostcode, "%s%s%s%c0", usc_buf.category_id, usc_buf.content_id, usc_buf.service_id, usc_buf.bearer);
    /* -- Removed by N.Thanakorn on 5-Mar-2015
    if ( glb_UscNew ) {
        if ( !strcmp(usc_buf.payment_type, "1") ) {    // Added by Thanakorn on 28-Dec-2009, convert GSM from 1 => 0 to map with IRB
            sprintf(sCostcode, "%s%s%s%c0", usc_buf.category_id, usc_buf.content_id, usc_buf.service_id, usc_buf.bearer);
        }
        else {
            sprintf(sCostcode, "%s%s%s%c%s", usc_buf.category_id, usc_buf.content_id, usc_buf.service_id, usc_buf.bearer, usc_buf.payment_type);
        }
    }
    else {
        sprintf(sCostcode, "%s%s%s%c", usc_buf.category_id, usc_buf.content_id, usc_buf.service_id, usc_buf.bearer);
    }
    */

    strcpy(sBandingModelId, "4");
    strcpy(sRatingTariffId, "7");
    /* -- Removed by N.Thanakorn on 5-Mar-2015
    if ( strcmp(usc_buf.payment_type, "1") == 0 )       // GSM
        strcpy(sRatingTariffId, "7");
    else if ( strcmp(usc_buf.payment_type, "8") == 0 )  // DPC
        strcpy(sRatingTariffId, "56");
    else if ( strcmp(usc_buf.payment_type, "7") == 0 )  // AWN
        strcpy(sRatingTariffId, "152");
    */
    strcpy(sEventClassId, "27");

    /* Lookup Cost Code Table by using banding_model_id and costcode to get cost_band_id */
    if ( Get_RmCostBandId2(sBandingModelId, sCostcode, sCostbandId, usc_event.vas_name) ) {   /* FAILURE */
        fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Code| banding_model_id(%s) costcode(%s)\n", glb_Eindex, sBandingModelId, sCostcode);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( Get_VasGroupCodeByGrpName(gszCostcode_Desc, usc_event.vas_grp) != SUCCESS ) {
        Get_VasGroupCodeByGrpName(gszCostcode_Name, usc_event.vas_grp);
    }

    /*
    ** Lookup Rating Element Table by using rate_tariff_id, cost_band_id, event_class_id
    ** to get fix_charge_mny and charge_rate
    */
    if ( Parse_RatingElement3(sRatingTariffId, sCostbandId, sEventClassId, sFixChargeMny, sChargeRate) ) {
        fwrite(&raw_usc, glb_UscNew ? SIZE_USCRAW : SIZE_USCRAWOLD, 1, glb_RCdrfp); /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
            glb_Eindex, sRatingTariffId, sCostbandId, sEventClassId);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Charge , Unit in Bath */
    if ( *sFixChargeMny) {
        sprintf(usc_event.charge, "%010ld", (atol(sFixChargeMny)/1000)*100);  // convert to Satang by x 100
/*
        if ( strcmp(usc_event.mobile_num, "0843334748") == 0 )
        {
            printf("fix => '%s', '%ld', '%-10s', '%ld'\n", usc_event.charge, atol(sFixChargeMny)/1000, usc_event.charge, atol(sFixChargeMny));
        }
*/
    }
    else if ( *sChargeRate) {
        sprintf(usc_event.charge, "%010ld", (atol(sChargeRate)/100000)*100);  // convert to Satang by x 100
/*
        if ( strcmp(usc_event.mobile_num, "0843334748") == 0 )
        {
            printf("rate => '%s', '%ld', '%-10s', '%ld'\n", usc_event.charge, atol(sChargeRate)/100000, usc_event.charge, atol(sChargeRate));
        }
*/
    }
    else
    {
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
            glb_Eindex, sRatingTariffId, sCostbandId, sEventClassId);
        glb_ErrCtr++;
        return FAILURE;
    }


    /* Direction */
    if ( !strcmp(usc_buf.record_type, "20"))
        strcpy(usc_event.direction, OUTGOING);  /* Outgoing Call */
    else if ( !strcmp(usc_buf.record_type, "30"))
        strcpy(usc_event.direction, INCOMING);  /* Ingoing Call */
    else
        strcpy(usc_event.direction, _UNKNOWN);

    strcpy(usc_event.charging_id, usc_buf.change_event_id);

    /* Service Category ID */
    strcpy(usc_event.service_cat, usc_buf.category_id);

    /* Content Provider ID */
    strcpy(usc_event.content_id, usc_buf.content_id);

    /* Bearer Code */
    *usc_event.bearer_code = usc_buf.bearer;

    /* Sub-Service ID */
    strcpy(usc_event.service_id, usc_buf.service_id);

    /* Payment Type */
    strcpy(usc_event.payment_type, usc_buf.payment_type);

    /* Content Code (Special Field) */
    strcpy(usc_event.content_code, usc_buf.content_code);

    /* Product/Content Value (in satang) */
    strcpy(usc_event.content_value, usc_event.charge);

    /* CDR Categories */
    /* Added "VasOrPremium" Category - Changed as below by Kawee on 22-Mar-2007 */
    /* iCategories |= CAT_TOTAL|CAT_VAS; */ /* Set to Total Category and VAS Category */
    iCategories |= CAT_TOTAL|CAT_VAS|CAT_LOCAL;    /* Set to Total, VAS Category */
    sprintf(usc_event.categories, "%08d", iCategories);

    /* Detection Skip Parameters */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        /* Always skip collision check for usc */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        /* skip duplication check for non voice events */
    strcpy(usc_event.detect_params, szDetParams);

    /* Vas Name - Already Assigned Value, during get CostBandId. See Charge. */
    return (CommonVas_To_Vas_Event(glb_MtxInd, (void *)&usc_event));

}
/*
** Added Ccudr_To_Session_Event function - by Jetsada on 27-August-2007
*/
int Ccudr_To_Session_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Ccudr_To_Session_Event");
    _p_ = 0;
#endif
    //time_t      Seize_time = 0; /* Seize Time in Seconds */

    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];
    int fieldShift = 0;

    if ( glb_CcNewField > CCUDR_PKGID-3 )   /* new format */
    {
        fieldShift = 0;
    }
    else    /* old format */
    {
        fieldShift = -3;    /* shift back for 3 field since new format have 3 field inserted after CCUDR_CONTENT */
    }

    memset(&session_event, 0x00, sizeof (session_event));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    if ( glb_nFeedType == FD_MD && glb_AllowType[AL_VSCP] == 0 ) {
        /* Reject BOS online record, added by Thanakorn on 26-Aug-2013 */
        /* ignore servpackid = 5 (5 - BOS� 2G,3G) */
        if ( atoi(pbuf_ccudr[CCUDR_SRVPCKID+fieldShift]) == 5 ) {
            fputs (raw_input, glb_RCdrfp);  /* reject the CCUDR record */
            fprintf(glb_Ignfp, "[DET] %s|BOS|BOS_Record| servpackid(%s)\n", glb_Eindex, pbuf_ccudr[CCUDR_SRVPCKID+fieldShift]);
            glb_IgnCtr++;
            return FAILURE;
        }
    }

    if ( strcmp(pbuf_ccudr[CCUDR_REC_TYPE], "ccudr") ) {
        fputs (raw_input, glb_RCdrfp);  /* a new record type - reject */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, pbuf_ccudr[CCUDR_REC_TYPE]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !strcmp(pbuf_ccudr[CCUDR_TI+fieldShift], "1") ) {    /* Test CDR */
        fputs (raw_input, glb_RCdrfp);  /* reject the CCUDR record */
        fprintf(glb_Ignfp, "[DET] %s|TEST|TEST| ti(%s)\n", glb_Eindex, pbuf_ccudr[CCUDR_TI+fieldShift]);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* added by thanakorn on 24-Jun-2013 */
    if ( strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "51") &&              /* GSM */
         strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "31") &&              /* DPC */
         strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "600001") &&          /* AWN Postpaid */
         strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "600002") &&          /* AWN Postpaid */
         strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "600003") &&          /* AWN Postpaid */
         strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "600004") &&          /* AWN Postpaid */
         strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "600005") &&          /* AWN Postpaid */
         strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "600007") &&          /* AWN MVPN Postpaid */
         strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "906") &&             /* AWN Postpaid */
         strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "909") &&             /* AWN Postpaid */
         strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "214") ) {            /* AWN Postpaid */
        fputs (raw_input, glb_RCdrfp);      /* reject the CDG record */
        fprintf(glb_Ignfp, "[DET] %s|COS|COS %s\n", glb_Eindex, pbuf_ccudr[CCUDR_COS+fieldShift]);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* Don't Feed AIS CDR when not included AIS Installation */
    if ( !glb_AisInstFlag && !strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "51") ) {      /* Not Included AIS Installation */
        fputs (raw_input, glb_RCdrfp); /* reject the CCUDR record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS) cos(%s)\n", glb_Eindex, pbuf_ccudr[CCUDR_COS+fieldShift]);
        glb_IgnCtr++;
        return FAILURE;
    }

    /* Don't Feed DPC CDR when not included DPC Installation */
    if ( !glb_DpcInstFlag && !strcmp(pbuf_ccudr[CCUDR_COS+fieldShift], "31") ) {      /* Not Included AIS Installation */
        fputs (raw_input, glb_RCdrfp); /* reject the CCUDR record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC) cos(%s)\n", glb_Eindex, pbuf_ccudr[CCUDR_COS+fieldShift]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( !*pbuf_ccudr[CCUDR_CATID+fieldShift]) { /* CATID is Blank */
        fprintf(glb_Errfp, "[DET] %s|Field|CAT_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( !*pbuf_ccudr[CCUDR_CPID+fieldShift]) {  /* CPID is Blank */
        fprintf(glb_Errfp, "[DET] %s|Field|CP_ID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( !*pbuf_ccudr[CCUDR_SID+fieldShift]) {   /* SID is Blank */
        fprintf(glb_Errfp, "[DET] %s|Field|SID_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( !*pbuf_ccudr[CCUDR_OB+fieldShift]) {    /* OB is Blank */
        fprintf(glb_Errfp, "[DET] %s|Field|OB Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    glb_EventId = VAS_EVENT_TYPE;

    /* Service Number */
    if ( Conv_Ano(pbuf_ccudr[CCUDR_MSISDN], session_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strlen(session_event.mobile_num) < SIZE_PHONENO) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, session_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* From Mobile Number */
    strcpy(session_event.from_number, session_event.mobile_num);

    /* Service Session ID */
    strcpy(session_event.service_session_id, pbuf_ccudr[CCUDR_SSID]);

    if ( !IsValid_YYYYMMDDHHMMSS (pbuf_ccudr[CCUDR_START+fieldShift]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date_time(%s)\n",
            glb_Eindex, pbuf_ccudr[CCUDR_START+fieldShift]);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008 */
    if ( strncmp(pbuf_ccudr[CCUDR_START+fieldShift], glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fputs (raw_input, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
            glb_Eindex, pbuf_ccudr[CCUDR_START+fieldShift], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    /* Seize Time & Date */
    //Seize_time = Calc_SeizeTime (pbuf_ccudr[CCUDR_START+fieldShift], pbuf_ccudr[CCUDR_START+fieldShift]+SIZE_YYYYMMDD);
    //sprintf(session_event.time_key, "%010ld", Seize_time);
    sprintf(session_event.time_key, "%s", pbuf_ccudr[CCUDR_START+fieldShift]);

    /* Charge (Satang) - Fixed Charge 10 Baht */
    strcpy(session_event.charge, "1000");

    /* Service ID */
    strcpy(session_event.service_id, pbuf_ccudr[CCUDR_SID+fieldShift]);

    /* Service Category ID */
    strcpy(session_event.service_cat, pbuf_ccudr[CCUDR_CATID+fieldShift]);

    /* Content Provider ID */
    strcpy(session_event.content_id, pbuf_ccudr[CCUDR_CPID+fieldShift]);

    /* Class of Service */
    strcpy(session_event.cos, pbuf_ccudr[CCUDR_COS+fieldShift]);

    /* IMSI */
    strcpy(session_event.imsi, pbuf_ccudr[CCUDR_IMSI+fieldShift]);

    /* Old Bearer */
    strcpy(session_event.ob, pbuf_ccudr[CCUDR_OB+fieldShift]);

    /* VAS Service Name */
    sprintf(costcode, "%s%s%s%s%s", pbuf_ccudr[CCUDR_CATID+fieldShift], pbuf_ccudr[CCUDR_CPID+fieldShift], pbuf_ccudr[CCUDR_SID+fieldShift], pbuf_ccudr[CCUDR_OB+fieldShift], pbuf_ccudr[CCUDR_PKGID+fieldShift]);
    strcpy(banding_model_id, "4");

    if ( Get_RmCostBandId2(banding_model_id, costcode, cost_band_id, session_event.vas_name) ) {  /* FAILURE */
        fputs (raw_input, glb_RCdrfp); /* reject the CCUDR record */
        fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Code| banding_model_id(%s) costcode(%s)\n", glb_Eindex, banding_model_id, costcode);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Categories */
    iCategories |= CAT_TOTAL|CAT_VAS|CAT_LOCAL;    /* Set to Total, VAS and Outgoing Category */
    sprintf(session_event.categories, "%08d", iCategories);

    /* Detection Skip Parameters */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        /* Always skip collision check for session */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         /* Always skip velocity check for session */
    /*
    ** Since CDR from VSCP can dup in event_type, time_key and duration
    ** Need more condition check for checkdup, this will be done in custom checkdup process
    ** - Added below by Kawee on 20-Mar-2008
    */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        /* Always skip duplicate event check for CDR from VSCP */
    strcpy(session_event.detect_params, szDetParams);

    return (CommonVas_To_Vas_Event(glb_MtxInd, (void *)&session_event));

}

//
// Added CommonVas_To_Vas_Event function - by Thanakorn Sep-2012 FMS V11
// make any vas events (USC, RBT, CDG, Session, AMF, SDG) to common vas event format
//
int CommonVas_To_Vas_Event (int iEvtType, void *event_buf)
{
    memset(&vas_event, 0x00, sizeof(vas_event));
    sprintf(vas_event.event_type, "%02d", VAS_EVENT_TYPE);
    strcpy(vas_event.partition_id, AWN_PARTITION);
    strcpy(vas_event.event_src, glb_EventSource);

    if ( iEvtType == USC_TYPE ) {       // not yet mapping
        strcpy(vas_event.mobile_num,    ((USC_EVENT*)event_buf)->mobile_num);
        strcpy(vas_event.from_number,   ((USC_EVENT*)event_buf)->from_number);
        strcpy(vas_event.time_key,      ((USC_EVENT*)event_buf)->time_key);
        strcpy(vas_event.charge,        ((USC_EVENT*)event_buf)->charge);
        strcpy(vas_event.service_cat,   ((USC_EVENT*)event_buf)->service_cat);
        strcpy(vas_event.service_id,    ((USC_EVENT*)event_buf)->service_id);
        strcpy(vas_event.cpid,          ((USC_EVENT*)event_buf)->content_id);
        strcpy(vas_event.vas_name,      ((USC_EVENT*)event_buf)->vas_name);
        strcpy(vas_event.direction,     ((USC_EVENT*)event_buf)->direction);
        // strcpy(vas_event.app_id,       ((USC_EVENT*)event_buf)-> );
        // strcpy(vas_event.imsi,         ((USC_EVENT*)event_buf)-> );
        strcpy(vas_event.categories,    ((USC_EVENT*)event_buf)->categories);
        strcpy(vas_event.detect_params, ((USC_EVENT*)event_buf)->detect_params);
        // strcpy(vas_event.pre_disc,     ((USC_EVENT*)event_buf)-> );
        // strcpy(vas_event.vas_desc,     ((USC_EVENT*)event_buf)-> );
        // strcpy(vas_event.short_code,   ((USC_EVENT*)event_buf)-> );
        // strcpy(vas_event.fee_charge,   ((USC_EVENT*)event_buf)-> );
        // strcpy(vas_event.business_code,((USC_EVENT*)event_buf)-> );
        strcpy(vas_event.charging_id,   ((USC_EVENT*)event_buf)->charging_id);
        strcpy(vas_event.vas_grp,       ((USC_EVENT*)event_buf)->vas_grp);
    }
    else if ( iEvtType == RBT_TYPE ) {  // not yet mapping
        strcpy(vas_event.mobile_num,    ((RBT_EVENT*)event_buf)->mobile_num);
        strcpy(vas_event.from_number,   ((RBT_EVENT*)event_buf)->from_number);
        strcpy(vas_event.time_key,      ((RBT_EVENT*)event_buf)->time_key);
        strcpy(vas_event.charge,        ((RBT_EVENT*)event_buf)->charge);
        strcpy(vas_event.service_cat,   ((RBT_EVENT*)event_buf)->cos_id);
        // strcpy(vas_event.service_id,   ((RBT_EVENT*)event_buf)-> );
        // strcpy(vas_event.cpid,         ((RBT_EVENT*)event_buf)-> );
        // strcpy(vas_event.vas_name,     ((RBT_EVENT*)event_buf)-> );
        // strcpy(vas_event.direction,    ((RBT_EVENT*)event_buf)-> );
        // strcpy(vas_event.app_id,       ((RBT_EVENT*)event_buf)-> );
        // strcpy(vas_event.imsi,         ((RBT_EVENT*)event_buf)-> );
        strcpy(vas_event.categories,    ((RBT_EVENT*)event_buf)->categories);
        strcpy(vas_event.detect_params, ((RBT_EVENT*)event_buf)->detect_params);
        // strcpy(vas_event.pre_disc,     ((RBT_EVENT*)event_buf)-> );
        // strcpy(vas_event.vas_desc,     ((RBT_EVENT*)event_buf)-> );
        // strcpy(vas_event.short_code,   ((RBT_EVENT*)event_buf)-> );
        // strcpy(vas_event.fee_charge,   ((RBT_EVENT*)event_buf)-> );
        // strcpy(vas_event.business_code,((RBT_EVENT*)event_buf)-> );
        // strcpy(vas_event.charging_id,  ((RBT_EVENT*)event_buf)-> );
        strcpy(vas_event.bno,           ((RBT_EVENT*)event_buf)->ring_no);
        strcpy(vas_event.original_bno,  ((RBT_EVENT*)event_buf)->ring_no);
        strcpy(vas_event.to_number,     ((RBT_EVENT*)event_buf)->ring_no);
        strcpy(vas_event.vas_grp,       ((RBT_EVENT*)event_buf)->vas_grp);
    }
    else if ( iEvtType == GSMCT_TYPE || iEvtType == PPSCT_TYPE || iEvtType == DCB_TYPE || iEvtType == DCBCT_TYPE ) {  // CGD (CTUDR)
        strcpy(vas_event.mobile_num,    ((CDG_EVENT*)event_buf)->mobile_num);
        strcpy(vas_event.from_number,   ((CDG_EVENT*)event_buf)->from_number);
        strcpy(vas_event.time_key,      ((CDG_EVENT*)event_buf)->time_key);
        strcpy(vas_event.charge,        ((CDG_EVENT*)event_buf)->charge);
        strcpy(vas_event.service_cat,   ((CDG_EVENT*)event_buf)->service_cat);
        strcpy(vas_event.service_id,    ((CDG_EVENT*)event_buf)->service_id);
        strcpy(vas_event.cpid,          ((CDG_EVENT*)event_buf)->content_id);
        strcpy(vas_event.vas_name,      ((CDG_EVENT*)event_buf)->vas_name);
        strcpy(vas_event.direction,     ((CDG_EVENT*)event_buf)->direction);
        strcpy(vas_event.app_id,        ((CDG_EVENT*)event_buf)->app_id);
        strcpy(vas_event.imsi,          ((CDG_EVENT*)event_buf)->imsi);
        strcpy(vas_event.categories,    ((CDG_EVENT*)event_buf)->categories);
        strcpy(vas_event.detect_params, ((CDG_EVENT*)event_buf)->detect_params);
        // vas_event.pre_disc           -> NULL
        strcpy(vas_event.vas_desc,      ((CDG_EVENT*)event_buf)->vas_desc);
        strcpy(vas_event.short_code,    ((CDG_EVENT*)event_buf)->short_code);
        // vas_event.fee_charge         -> NULL
        // vas_event.business_code      -> NULL
        strcpy(vas_event.charging_id,   ((CDG_EVENT*)event_buf)->charging_id);
        strcpy(vas_event.bno,           ((CDG_EVENT*)event_buf)->app_id);
        strcpy(vas_event.original_bno,  ((CDG_EVENT*)event_buf)->app_id);
        strcpy(vas_event.to_number,     ((CDG_EVENT*)event_buf)->app_id);
        strcpy(vas_event.remarks,       ((CDG_EVENT*)event_buf)->remarks);
        strcpy(vas_event.vas_grp,       ((CDG_EVENT*)event_buf)->vas_grp);
    }
    else if ( iEvtType == CCUDR_TYPE ) {    // Session - not yet mapping
        strcpy(vas_event.mobile_num,    ((SESSION_EVENT*)event_buf)->mobile_num);
        strcpy(vas_event.from_number,   ((SESSION_EVENT*)event_buf)->from_number);
        strcpy(vas_event.time_key,      ((SESSION_EVENT*)event_buf)->time_key);
        strcpy(vas_event.charge,        ((SESSION_EVENT*)event_buf)->charge);
        //strcpy(vas_event.service_cat,  ((SESSION_EVENT*)event_buf)->service_cat);
        strcpy(vas_event.service_id,    ((SESSION_EVENT*)event_buf)->service_id);
        // strcpy(vas_event.cpid,         ((SESSION_EVENT*)event_buf)-> );
        strcpy(vas_event.vas_name,      ((SESSION_EVENT*)event_buf)->vas_name);
        // strcpy(vas_event.direction,    ((SESSION_EVENT*)event_buf)-> );
        // strcpy(vas_event.app_id,       ((SESSION_EVENT*)event_buf)-> );
        strcpy(vas_event.imsi,          ((SESSION_EVENT*)event_buf)->imsi);
        strcpy(vas_event.categories,    ((SESSION_EVENT*)event_buf)->categories);
        strcpy(vas_event.detect_params, ((SESSION_EVENT*)event_buf)->detect_params);
        // strcpy(vas_event.pre_disc,     ((SESSION_EVENT*)event_buf)-> );
        // strcpy(vas_event.vas_desc,     ((SESSION_EVENT*)event_buf)-> );
        // strcpy(vas_event.short_code,   ((SESSION_EVENT*)event_buf)-> );
        // strcpy(vas_event.fee_charge,   ((SESSION_EVENT*)event_buf)-> );
        // strcpy(vas_event.business_code,((SESSION_EVENT*)event_buf)-> );
        // strcpy(vas_event.charging_id,  ((SESSION_EVENT*)event_buf)-> );
        strcpy(vas_event.vas_grp,       ((SESSION_EVENT*)event_buf)->vas_grp);
    }
    else if ( iEvtType == AMF_TYPE || iEvtType == SDG_TYPE ) {  // AMF and SDG have the same output format // not yet mapping for amf
        strcpy(vas_event.mobile_num,    ((AMF_EVENT*)event_buf)->mobile_num);
        strcpy(vas_event.from_number,   ((AMF_EVENT*)event_buf)->from_number);
        strcpy(vas_event.time_key,      ((AMF_EVENT*)event_buf)->time_key);
        strcpy(vas_event.charge,        ((AMF_EVENT*)event_buf)->charge);
        strcpy(vas_event.service_cat,   ((AMF_EVENT*)event_buf)->cat_id);
        strcpy(vas_event.service_id,    ((AMF_EVENT*)event_buf)->service_id);
        strcpy(vas_event.cpid,          ((AMF_EVENT*)event_buf)->cpid);
        strcpy(vas_event.vas_name,      ((AMF_EVENT*)event_buf)->vas_name);
        strcpy(vas_event.direction,     ((AMF_EVENT*)event_buf)->direction);
        strcpy(vas_event.app_id,        ((AMF_EVENT*)event_buf)->con_id);
        // vas_event.imsi               -> NULL
        strcpy(vas_event.categories,    ((AMF_EVENT*)event_buf)->categories);
        strcpy(vas_event.detect_params, ((AMF_EVENT*)event_buf)->detect_params);
        // vas_event.pre_disc           -> NULL
        strcpy(vas_event.vas_desc,      ((AMF_EVENT*)event_buf)->vas_desc);
        strcpy(vas_event.short_code,    ((AMF_EVENT*)event_buf)->short_code);
        // vas_event.fee_charge         -> NULL
        // vas_event.business_code      -> NULL
        strcpy(vas_event.charging_id,   ((AMF_EVENT*)event_buf)->charging_id);
        strcpy(vas_event.bno,           ((AMF_EVENT*)event_buf)->app_id);
        strcpy(vas_event.original_bno,  ((AMF_EVENT*)event_buf)->app_id);
        strcpy(vas_event.to_number,     ((AMF_EVENT*)event_buf)->app_id);
        strcpy(vas_event.vas_grp,       ((AMF_EVENT*)event_buf)->vas_grp);
    }
    else if ( iEvtType == GSMTOP_TYPE ) {   // not yet mapping
        strcpy(vas_event.mobile_num,    ((USC_EVENT*)event_buf)->mobile_num);
        strcpy(vas_event.from_number,   ((USC_EVENT*)event_buf)->from_number);
        strcpy(vas_event.time_key,      ((USC_EVENT*)event_buf)->time_key);
        strcpy(vas_event.charge,        ((USC_EVENT*)event_buf)->charge);
        strcpy(vas_event.service_cat,   ((USC_EVENT*)event_buf)->service_cat);
        strcpy(vas_event.service_id,    ((USC_EVENT*)event_buf)->service_id);
        // strcpy(vas_event.cpid,         ((USC_EVENT*)event_buf)-> );
        strcpy(vas_event.vas_name,      ((USC_EVENT*)event_buf)->vas_name);
        strcpy(vas_event.direction,     OUTGOING);
        strcpy(vas_event.app_id,        ((USC_EVENT*)event_buf)->content_id);
        // strcpy(vas_event.imsi,         ((USC_EVENT*)event_buf)-> );
        strcpy(vas_event.categories,    ((USC_EVENT*)event_buf)->categories);
        strcpy(vas_event.detect_params, ((USC_EVENT*)event_buf)->detect_params);
        // strcpy(vas_event.pre_disc,     ((USC_EVENT*)event_buf)-> );
        // strcpy(vas_event.vas_desc,     ((USC_EVENT*)event_buf)-> );
        // strcpy(vas_event.short_code,   ((USC_EVENT*)event_buf)-> );
        // strcpy(vas_event.fee_charge,   ((USC_EVENT*)event_buf)-> );
        // strcpy(vas_event.business_code,((USC_EVENT*)event_buf)-> );
        // strcpy(vas_event.charging_id,  ((USC_EVENT*)event_buf)-> );
        strcpy(vas_event.bno,           ((USC_EVENT*)event_buf)->content_code);
        strcpy(vas_event.original_bno,  ((USC_EVENT*)event_buf)->content_code);
        strcpy(vas_event.to_number,     ((USC_EVENT*)event_buf)->content_code);
        strcpy(vas_event.vas_grp,       ((USC_EVENT*)event_buf)->vas_grp);
    }

#ifdef _PRINT_DEBUG_VAS_EVENT_
printf("vas type = %d\n", iEvtType);
printf("%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
    vas_event.event_type, vas_event.partition_id, vas_event.mobile_num, vas_event.from_number,
    vas_event.time_key, vas_event.charge, vas_event.service_cat, vas_event.service_id,
    vas_event.vas_name, vas_event.direction, vas_event.app_id, vas_event.imsi, vas_event.categories,
    vas_event.detect_params, vas_event.event_src, vas_event.pre_disc, vas_event.vas_desc,
    vas_event.short_code, vas_event.fee_charge, vas_event.business_code, vas_event.charging_id);
#endif
    return SUCCESS;

}

int Nrtrde_To_IR_Event ()
{
#ifdef _PRNT_FUNC_CALL_     // using verification done
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Nrtrde_To_IR_Event");
    _p_ = 0;
#endif
    //time_t  Seize_time1 = 0;
    //time_t  Seize_time2 = 0;

    char sVolume[21+1];
    char szTemp1[IDDACC_LEN+32+1];
    char szTemp2[IDDACC_LEN+32+1];
    char szCountryCode[5];

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];
    int iFeature = 0;
    //int iPrice_type = 0;
    double dwTotalVolume = 0.0;
    double  Rate_Pm = 0.0;
    unsigned int Duration = 0;

    memset(&ir_event, 0x00, sizeof (ir_event));
    memset(szCountryCode, 0x00, sizeof(szCountryCode));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    // Don't Feed NRTRDE CDR when not included NRTRDE Installation
    if ( !glb_NrtInstFlag ) {           // Not Included NRTRDE Installation
        fputs(raw_input, glb_RCdrfp);   // reject the NRTRDE record
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|NRTRDE| not included(NRT)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( glb_MtxInd == NRTRDE_TYPE && !*pbuf_nrtrde[CMNIR_IMSI] ) {  // IMSI is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|IMSI_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( !*pbuf_nrtrde[CMNIR_START_DT] ) { // Start Time is Blank
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time Blank| start_time is blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    glb_EventId = IR_EVENT_TYPE;        // IR Event Type
    sprintf(ir_event.event_type, "%02d", glb_EventId);

    if ( strlen(pbuf_nrtrde[CMNIR_IMSI]) < SIZE_IMSI-2 ) {
        fprintf(glb_Errfp, "[DET] %s|Field|IMSI| imsi(%s) length(%d) is invalid\n", glb_Eindex, pbuf_nrtrde[CMNIR_IMSI], (int)strlen(pbuf_nrtrde[CMNIR_IMSI]));
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( strncmp(pbuf_nrtrde[CMNIR_IMSI], "52001", 5) &&  // AIS900
         strncmp(pbuf_nrtrde[CMNIR_IMSI], "52023", 5) &&  // GSM1800
         strncmp(pbuf_nrtrde[CMNIR_IMSI], "52003", 5) ) { // AWN
        fputs(raw_input, glb_RCdrfp);  // reject the NRTRDE record
        fprintf(glb_Ignfp, "[DET] %s|Non_Home_IMSI|IMSI %s\n", glb_Eindex, pbuf_nrtrde[CMNIR_IMSI]);
        glb_IgnCtr++;
        return FAILURE;
    }
    strcpy(ir_event.mobile_num, pbuf_nrtrde[CMNIR_MOBILE_NUM]);

    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno)); // Added by Thanakorn on 09-Sep-2012, FMS V11
    if ( !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "30") ||    // Voice MT
         !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "31") ||    // SMS MT
         !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "20") ||    // Voice MO
         !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "21") ||    // SMS MO
         !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "25") ||    // Voice MO Camel
         !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "18") ) {   // GPRS
        strncpy(ir_event.from_number, ir_event.mobile_num, 18);
        strncpy(ir_event.to_number, pbuf_nrtrde[CMNIR_CALL_NUM], 18);
        strncpy(glb_OriginalBno, pbuf_nrtrde[CMNIR_CALL_NUM], 100);
    }
    else {  // Unknown CallType
        fputs(raw_input, glb_RCdrfp);  // reject the record
        fprintf(glb_Errfp, "[DET] %s|Field|Call_Type| call_type(%s)\n", glb_Eindex, pbuf_nrtrde[CMNIR_REC_TYPE]); // need_to_check
        glb_ErrCtr++;
        return FAILURE;
    }

    // Country Code (get country code only non GPRS, non MTC and non SMST
    if ( strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "18") || 	// GPRS
		 strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "30") ||  	// MTC
		 strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "31") ) {	// SMST
        memset(szTemp1, 0x00, sizeof (szTemp1));
        strcpy(szTemp1, IDDACC_CODE);
        strncat (szTemp1, pbuf_nrtrde[CMNIR_CALL_NUM], 32);
        Parse_Country(szTemp1, ir_event.country_code, &Rate_Pm);
    }

    if ( strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "31") == 0 ) {   // SMS Terminate
        strcpy(ir_event.country_code, "66");    // does not require foreign country code since FMS will take into account if it in a alarm list
    }

    // Home time (Thailand Time)                        // Local Time (Outbound Time)
    memset(szTemp1, sizeof(szTemp1), 0x00);             memset(szTemp2, sizeof(szTemp2), 0x00);
    strcpy(szTemp1, pbuf_nrtrde[CMNIR_TH_TIME]);       strcpy(szTemp2, pbuf_nrtrde[CMNIR_START_DT]);
    RemoveChar(szTemp1, strlen(szTemp1), '-');          RemoveChar(szTemp2, strlen(szTemp2), '-');
    RemoveChar(szTemp1, strlen(szTemp1), ':');          RemoveChar(szTemp2, strlen(szTemp2), ':');
    RemoveChar(szTemp1, strlen(szTemp1), ' ');          RemoveChar(szTemp2, strlen(szTemp2), ' ');

    // Call time at Thailand time (Home time)
    strcpy(ir_event.startdate_gmt7, szTemp1);
    //Seize_time1 = Calc_SeizeTime(szTemp1, szTemp1+SIZE_YYYYMMDD);   // Home DateTime
    //Seize_time2 = Calc_SeizeTime(szTemp2, szTemp2+SIZE_YYYYMMDD);   // Local DateTime
    strncpy(glb_CurCDRDate, ir_event.startdate_gmt7, SIZE_YYYYMMDD);
    strcpy(glb_CurCDRTime,  ir_event.startdate_gmt7+SIZE_YYYYMMDD);

    // Call time at Local time
    //sprintf(ir_event.time_key, "%010ld", Seize_time2);
    sprintf(ir_event.time_key, "%s", szTemp2);
    strcpy(ir_event.call_start_time, szTemp2);

    // GMT Offset
    if ( pbuf_nrtrde[CMNIR_UTC_TIME][0] == '\0') {      // UTC Offset is blank
        //strcpy(ir_event.utc_offset, "700");           // +0700
        strcpy(ir_event.utc_offset, "+0700");           // set time minute => +7.00 => 420 minutes
    }
    else {
        sprintf(ir_event.utc_offset, "%+05d", atoi(pbuf_nrtrde[CMNIR_UTC_TIME]));
    }

    // Duration and Pre-Duration
    Duration = atoi(pbuf_nrtrde[CMNIR_DURATION]);
    sprintf(ir_event.duration, "%06d", Duration);   // real duration

    Duration = atoi(pbuf_nrtrde[CMNIR_ORI_DUR]);
    sprintf(ir_event.pre_dura, "%06d", Duration);   // original duration


    // Direction
    if ( !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "30") ||    // MTC
         !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "31") ) {   // SMS Terminate
        strcpy(ir_event.direction, INCOMING);        // Incoming
    }
    else {
        strcpy(ir_event.direction, OUTGOING);        // Outgoing
    }

    // IMSI
    //if ( strlen(pbuf_nrtrde[CMNIR_IMSI]) == SIZE_IMSI) {
        strcpy(ir_event.imsi, pbuf_nrtrde[CMNIR_IMSI]);
    //}

    // Total Volume
    dwTotalVolume = ceil((atof(pbuf_nrtrde[CMNIR_VOLUME]))/1024.0);   // Calculate Total Volume in Kbyte
    sprintf(sVolume, "%010.0lf", dwTotalVolume);
    strncpy(ir_event.vol_total, sVolume+strlen(sVolume)-10 , 10);       // Copy only last 10 Chars to TotalVolume (it's Volume1 in FRM)

    // Charge Type
    strcpy(ir_event.charge_type, pbuf_nrtrde[CMNIR_CHRG_TYPE]);       // Just copy

    // PLMN Code
    strncpy(ir_event.plmn_code, pbuf_nrtrde[CMNIR_PLMN], 10);         // Just copy

    // PLMN Name
    strcpy(ir_event.plmn_name, pbuf_nrtrde[CMNIR_PLMN_NAME]);         // Just copy

    // Convert to Satang, the unit from input file is 1000 = 1 bath
    sprintf(ir_event.charge  , "%010.0lf", atof(pbuf_nrtrde[CMNIR_ONE_CHARGE]));    // real charge
    sprintf(ir_event.pre_disc, "%010.0lf", atof(pbuf_nrtrde[CMNIR_ORI_CHG]));       // original charge

    // Remark
    strcpy(ir_event.remarks, pbuf_nrtrde[CMNIR_ORI_SRC]);               // Just copy

    // Risk Bno
    strcpy(ir_event.risk_bno, pbuf_nrtrde[CMNIR_RSK_NO_FLG]);          // Just copy

    // IMEI
    strcpy(ir_event.imei, pbuf_nrtrde[CMNIR_IMEI]);                   // Just copy

    // Roam Country
    strcpy(ir_event.roam_country, pbuf_nrtrde[CMNIR_ROAM_COUNTRY]);   // Just copy

    // Roam Region
    strcpy(ir_event.roam_region, pbuf_nrtrde[CMNIR_ROAM_REGION]);     // Just copy

    // Categories
    iCategories |= CAT_TOTAL|CAT_IR;    // Set to Total, Roaming, IR Category
#if 0
    if ( !strcmp(ir_event.direction, OUTGOING) ) {  // Outgoing
        iCategories |= CAT_OUTGOING;                // Set to Outgoing
    }
    else {
        iCategories |= CAT_INCOMING;                // Set to Outgoing
    }
#endif
    if ( !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "18") ) {           // 18 = GPRS
        iCategories |= CAT_DATA;                                    // Set to Data
    }
    else if ( !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "21") ||       // 21 = SMS Originate
              !strcmp(pbuf_nrtrde[CMNIR_REC_TYPE], "31") ) {      // 31 = SMS Terminate
        iCategories |= CAT_SMS;                                     // Set to SMS
    }
    else {
        iCategories |= CAT_VOICE;                                   // Set to Voice
    }
    sprintf(ir_event.categories, "%08d", iCategories);

    // Feature
    if ( strcasecmp(pbuf_nrtrde[CMNIR_CALLNO_TYPE], "IDD") == 0 ) {
        iFeature = FEAT_IDD;
    }
    else if ( strcasecmp(pbuf_nrtrde[CMNIR_CALLNO_TYPE], "Thai") == 0 ) {
        iFeature = FEAT_THAI;
    }
    else if ( strcasecmp(pbuf_nrtrde[CMNIR_CALLNO_TYPE], "Local") == 0 ) {
        iFeature = FEAT_LOCAL;
    }
    sprintf(ir_event.features, "%010d", iFeature);

    // Detection Skip Parameters
    if ( iFeature & FEAT_FORWARD ||                 // Call Forward
         iCategories & CAT_SMS   ||                 // SMS  Originate/Terminate (call type=21,31)
         iCategories & CAT_DATA  ||                 // DATA (call type=18), Added by Thanakorn on 16-Nov-2012
         !strcmp(ir_event.direction, INCOMING) ) {  // Incoming Call/SMS - Skip because cannot find information
         strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);           // Always skip collision check for nrtrde
         strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);            // Always skip velocity check for nrtrde
         strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);           // skip duplication check for non voice events
    }
    if ( strstr(glb_SkipDetIrType, "ALL") != NULL || strstr(glb_SkipDetIrType, pbuf_nrtrde[CMNIR_ORI_SRC]) != NULL ) {
        strcat(szDetParams, gaszFrmSkipDet[SKIP_THRESHOLD]);
    }
    strcpy(ir_event.detect_params, szDetParams);

    strcpy(ir_event.partition_id, AWN_PARTITION);
    strcpy(ir_event.original_bno, glb_OriginalBno);
    sprintf(ir_event.event_src, "%s-%s", glb_EventSource, pbuf_nrtrde[CMNIR_ORI_SRC]);


// <DEBUG> //
if ( atoi(pbuf_nrtrde[CMNIR_ONE_CHARGE]) > 0) {
time_t t = time(NULL);
writeLog(LOG_INF, "DBG-NRT chr(%s, %s) utc(%s=>%s) timekey(%s=>%s) gmt7date(%s=>%s) sysdate(%s) imsi(%s) no(%s) %s"
, pbuf_nrtrde[CMNIR_ONE_CHARGE], ir_event.charge, pbuf_nrtrde[CMNIR_UTC_TIME], ir_event.utc_offset
, pbuf_nrtrde[CMNIR_START_DT], ir_event.time_key, pbuf_nrtrde[CMNIR_TH_TIME], ir_event.startdate_gmt7
, localtime_YYYYMMDDHHMMSS(&t), pbuf_nrtrde[CMNIR_IMSI], pbuf_nrtrde[CMNIR_MOBILE_NUM], pbuf_nrtrde[CMNIR_ORI_SRC]);
}

    return SUCCESS;

}

/*
** Added IrScp_To_IR_Event function - by Thanakorn on 24-Sep-2012
*/
int IrScp_To_IR_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> IrScp_To_IR_Event");
    _p_ = 0;
#endif
    char tmp_mobile_no[SIZE_MOBILE_NUM+1];
    //char tmp_plmn[6+1];
    char tmp_country_code[5];

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];
    int iFeature = 0;
    int iPrice_type = 0;

    //time_t  Seize_time = 0;
    //char sVolume[21+1];
    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];
    //char szLocalTime[SIZE_YYYYMMDD+SIZE_HHMMSS+1];
    //char szGmt7Time[SIZE_YYYYMMDD+SIZE_HHMMSS+1];
    //char szGmTime[SIZE_YYYYMMDD+SIZE_HHMMSS+1];
    char szTemp[IDDACC_LEN+32+1];

    //double dwUplinkVolume = 0.0;
    //double dwDownlinkVolume = 0.0;
    //double  dwGmtOffset_Hour = 0.0;
    //double  dwGmtOffset_Minute = 0.0;
    double  Rate_Pm = 0.0;          /* Rate Per Minute - use as dummy for parse country */
    //int iGmtOffset = 0;
    //double  Charge = 0.0;
    unsigned int    Duration = 0;   /* Duration */

    memset(&ir_event, 0x00, sizeof (ir_event));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    /* Don't Feed NRTRDE CDR when not included NRTRDE Installation */
    if ( !glb_NrtInstFlag) {             /* Not Included NRTRDE Installation */
        fputs (raw_input, glb_RCdrfp);  /* reject the NRTRDE record */
        fprintf(glb_Ignfp, "[DET] %s|Not_Install|NRTRDE| not included(NRT)\n", glb_Eindex);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( *pbuf_nrtscp[NRTSCP_ROAM_FLAG] != '2') {
        fputs (raw_input, glb_RCdrfp); /* reject the NRTRDE record */
        fprintf(glb_Ignfp, "[DET] %s|Invalid|Roam_Flag %s| only (2) accepted\n", glb_Eindex, pbuf_nrtscp[NRTSCP_ROAM_FLAG]);
        glb_IgnCtr++;
        return FAILURE;
    }
    // strncpy(ir_event.roam_flg, pbuf_nrtscp[NRTSCP_ROAM_FLAG], 1);

    if ( !*pbuf_nrtscp[NRTSCP_CALL_BEGIN_TIME]) {    /* Start Time is Blank */
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time Blank| call_begin_time is blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
        /* Seize Time & Date */
    if ( !IsValid_YYYYMMDDHHMMSS (pbuf_nrtscp[NRTSCP_CALL_BEGIN_TIME]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date_time(%s)\n",
            glb_Eindex, pbuf_nrtscp[NRTSCP_CALL_BEGIN_TIME]);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008 */
    if ( strncmp(pbuf_nrtscp[NRTSCP_CALL_BEGIN_TIME], glb_OldCdrDate, SIZE_YYYYMMDD) <= 0) {
        fputs (raw_input, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
            glb_Eindex, pbuf_nrtscp[NRTSCP_CALL_BEGIN_TIME], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    //Seize_time = Calc_SeizeTime (pbuf_nrtscp[NRTSCP_CALL_BEGIN_TIME], pbuf_nrtscp[NRTSCP_CALL_BEGIN_TIME]+SIZE_YYYYMMDD);
    //sprintf(ir_event.time_key, "%ld", Seize_time);
    sprintf(ir_event.time_key, "%s", pbuf_nrtscp[NRTSCP_CALL_BEGIN_TIME]);
    strcpy(ir_event.call_start_time, pbuf_nrtscp[NRTSCP_CALL_BEGIN_TIME]);

    /* This CDR type have only voice cdr */
    iCategories = CAT_TOTAL|CAT_IR|CAT_VOICE;
    memset(tmp_mobile_no, 0x00, sizeof(tmp_mobile_no));

    if ( *pbuf_nrtscp[NRTSCP_CALL_TYPE] == '2' || *pbuf_nrtscp[NRTSCP_CALL_TYPE] == '4') {
        strcpy(ir_event.direction, INCOMING);   /* Incoming */
        //iCategories |= CAT_INCOMING;
        strncpy(tmp_mobile_no, pbuf_nrtscp[NRTSCP_CALLED_PARTY_NO], SIZE_MOBILE_NUM);
        strcpy(ir_event.to_number, pbuf_nrtscp[NRTSCP_CALLING_PARTY_NO]);
        // strcpy(ir_event.call_type, "30");     /* MTC */
        strcpy(tmp_country_code, pbuf_nrtscp[NRTSCP_CALLED_AREA_NO]);
    }
    else if ( *pbuf_nrtscp[NRTSCP_CALL_TYPE] == '0' || *pbuf_nrtscp[NRTSCP_CALL_TYPE] == '3') {
        strcpy(ir_event.direction, OUTGOING);   /* Outgoing */
        //iCategories |= CAT_OUTGOING;
        strncpy(tmp_mobile_no, pbuf_nrtscp[NRTSCP_CALLING_PARTY_NO], SIZE_MOBILE_NUM);
        strcpy(ir_event.to_number, pbuf_nrtscp[NRTSCP_CALLED_PARTY_NO]);
        if ( *pbuf_nrtscp[NRTSCP_CHRG_TYPE] == '5' ) {  /* MOC */
            // strcpy(ir_event.call_type, "26");     /* MFCC */
            iFeature |= FEAT_FORWARD;           /* Call forward */
        }
        else {
            // strcpy(ir_event.call_type, "25");     /* MOCC */
        }
        strcpy(tmp_country_code, pbuf_nrtscp[NRTSCP_CALLING_AREA_NO]);
    }
    else {
        fputs (raw_input, glb_RCdrfp); /* reject the NRTRDE record */
        fprintf(glb_Ignfp, "[DET] %s|Call_Type|Call_Type %s| only (0,2,3,4) accepted\n", glb_Eindex, pbuf_nrtscp[NRTSCP_CALL_TYPE]);
        glb_IgnCtr++;
        return FAILURE;
    }
    strcpy(ir_event.charge_type, pbuf_nrtscp[NRTSCP_CHRG_TYPE]);

    glb_EventId = IR_EVENT_TYPE;        /* NRTRDE Event Type */
    sprintf(ir_event.event_type, "%02d", glb_EventId);

    if ( Conv_Ano(tmp_mobile_no, ir_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    if ( strncmp(ir_event.mobile_num,"08", 2) && strncmp(ir_event.mobile_num,"09", 2) ) { /* Not start with "08" */
        fprintf(glb_Errfp, "[DET] %s|Field|Mobile_NO| mobile_no(%s)\n", glb_Eindex, pbuf_nrtscp[NRTRDE_MOBILE_NO]);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strlen(ir_event.mobile_num) < SIZE_PHONENO) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, ir_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }

    strcpy(ir_event.from_number, ir_event.mobile_num);
    strcpy(ir_event.utc_offset, "+700");   /* ir scp is recorded in Thailand local time */

    /* Country Code */
    memset(szTemp, 0x00, sizeof (szTemp));
    strcpy(szTemp, IDDACC_CODE);
    strncat (szTemp, ir_event.to_number, 32);
    switch ( Parse_Country(szTemp, ir_event.country_code, &Rate_Pm) ) {
        case SUCCESS :
        case PARSE_MUL_MATCH :
            break;
        case PARSE_NOT_MATCH :
        case FAILURE :
            fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, pbuf_nrtscp[NRTRDE_BNO]);
            //memset(ir_event.country_code, SPACE_CHAR, sizeof (ir_event.country_code)-1);   /* reset */
            glb_ErrCtr++;
            return FAILURE;
    }

    if ( strcmp(ir_event.direction, INCOMING) == 0 ) {  /* Incoming */
        iPrice_type = CHR_MTC;
    }
    else {
        if ( strcmp(ir_event.country_code, "66") == 0 )                     /* call to Thailand */
            iPrice_type = CHR_MOC_TO_TH;
        else if ( strcmp(ir_event.country_code, tmp_country_code) == 0 )    /* local call within that country */
            iPrice_type = CHR_MOC_LOCAL;
        else                                                                    /* international call */
            iPrice_type = CHR_MOC_INTER;
    }

    //Get_CarrierPrice(pbuf_nrtscp[NRTSCP_CALLING_AREA_NO], iPrice_type, &Rate_Pm);
    /* NRTSCP_CALLING_AREA_NO is country code */
    // Get_CountryCode(tmp_country_code, iPrice_type, &Rate_Pm, ir_event.plmn_code, ir_event.cell_area);
    // strcpy(ir_event.cell_set, "00000");
    // strcpy(ir_event.cell, "00000");

    /* Duration */
    /* Copy only last 6 characters */
    Duration = atoi(pbuf_nrtscp[NRTSCP_CALL_DUR]);
    if ( Duration > 999999)
        sprintf(ir_event.duration, "%06d", 999999);
    else
        sprintf(ir_event.duration, "%06d", Duration);

    // Charge = (double) Calc_NatlCharge (Duration, (Rate_Pm/1000.0));
    // Charge = (double) Charge * 100;     /* Convert to Satang */
    // sprintf(ir_event.charge, "%010.0lf", Charge);

    sprintf(ir_event.categories, "%08d", iCategories);

    /* Feature */
    sprintf(ir_event.features, "%010d", iFeature);

    /* Detection Skip Parameters */
    if ( iFeature & FEAT_FORWARD ||                  /* Call Forward (call type = 22,26) */
        !strcmp(ir_event.direction, INCOMING) ) {   /* Incoming Call/SMS - Skip because cannot find information */
        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        /* Always skip collision check for nrtrde */
        strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         /* Always skip velocity check for nrtrde */
    }
    strcpy(ir_event.detect_params, szDetParams);

    // strncpy(ir_event.charge_party_ind, pbuf_nrtscp[NRTSCP_CHRG_PARTY_IND], 1);

    // strncpy(ir_event.termination_reason, pbuf_nrtscp[NRTSCP_TERM_REASON], 1);

    strcpy(ir_event.original_bno, pbuf_nrtscp[NRTSCP_ORG_CALLED_PARTY]);

    // strncpy(ir_event.brand_id, pbuf_nrtscp[NRTSCP_BRAND_ID], 1);

    // strcpy(ir_event.call_cac, pbuf_nrtscp[NRTSCP_CALL_CAC]);

    // strcpy(ir_event.payment_type, pbuf_nrtscp[NRTSCP_PAYMENT_TYPE]);

    // strcpy(ir_event.called_roam_num, pbuf_nrtscp[NRTSCP_CALLED_ROAM_NO]);

    strcpy(ir_event.partition_id, AWN_PARTITION);

    strcpy(ir_event.event_src, glb_EventSource);

    return SUCCESS;
}


/* GSM Top Up added by N.Thanakorn on 5-Feb-2015 */
int Read_GsmTopUp_Cdr()
{
    memset(pbuf_gsmtop, 0x00, sizeof (pbuf_gsmtop));
    return (Read_Delimiter_Cdr ('|', NOF_FLD_TOP, pbuf_gsmtop));
}

int GsmTopUp_To_Event ()
{
    //time_t  Seize_time = 0; /* Seize Time in Seconds */

    int iCategories = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    memset(&usc_event, 0x00, sizeof(usc_event));
    memset(szDetParams, 0x00, sizeof(szDetParams));
    glb_EventId = VAS_EVENT_TYPE;


    if ( strcmp(pbuf_gsmtop[GTU_EVT_ATTR12], "GSM_TopUp") ) {
        fputs(raw_input, glb_RCdrfp);  /* unknown service type */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_Eindex, pbuf_cdg[GTU_EVT_ATTR12]);
        glb_IgnCtr++;
        return FAILURE;
    }

    strcpy(usc_event.mobile_num, pbuf_gsmtop[GTU_EVT_SRC]);
    if ( strlen(usc_event.mobile_num) < SIZE_PHONENO ) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, usc_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* From Mobile Number */
    strcpy(usc_event.from_number, usc_event.mobile_num);

    strcpy(usc_event.content_code, pbuf_gsmtop[GTU_EVT_ATTR18]);   // GTU_EVT_ATTR18 as B-Number

    if ( !IsValid_YYYYMMDDHHMMSS(pbuf_gsmtop[GTU_EVT_DTM]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| gsmtopup_event_date_time(%s)\n",
                glb_Eindex, pbuf_gsmtop[GTU_EVT_DTM]);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( strncmp(pbuf_gsmtop[GTU_EVT_DTM], glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fputs(raw_input, glb_RCdrfp);  /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
                glb_Eindex, pbuf_gsmtop[GTU_EVT_DTM], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    /* Seize Time & Date */
    //Seize_time = Calc_SeizeTime(pbuf_gsmtop[GTU_EVT_DTM], pbuf_gsmtop[GTU_EVT_DTM]+SIZE_YYYYMMDD);
    //sprintf(usc_event.time_key, "%010ld", Seize_time);
    sprintf(usc_event.time_key, "%s", pbuf_gsmtop[GTU_EVT_DTM]);

    /* CDR Categories */
    iCategories |= CAT_TOTAL|CAT_VAS|CAT_LOCAL;    /* Set to Total, VAS and Outgoing Category */
    sprintf(usc_event.categories, "%08d", iCategories);

    /* Detection Skip Parameters */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        /* Always skip collision check for cdg */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         /* Always skip velocity check for cdg */
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        /* Always skip duplicate event check for CDR from VSCP */
    strcpy(usc_event.detect_params, szDetParams);

    strcpy(usc_event.content_id, pbuf_gsmtop[GTU_EVT_ATTR3]);
    strcpy(usc_event.service_cat, pbuf_gsmtop[GTU_EVT_ATTR2]);
    strcpy(usc_event.service_id, pbuf_gsmtop[GTU_EVT_ATTR4]);

    strcpy(usc_event.vas_name, pbuf_gsmtop[GTU_EVT_ATTR20]);
    sprintf(usc_event.charge, "%010ld", ( atol(pbuf_gsmtop[GTU_EVT_COST_MNY])/10 ));

    strcpy(usc_event.vas_grp, "1");     // coded value = 1 => GSM Topup

    return (CommonVas_To_Vas_Event(glb_MtxInd, (void *)&usc_event));

}

int Read_Ims_Cdr()
{
    memset(pbuf_ims, 0x00, sizeof (pbuf_ims));
    return (Read_Delimiter_Cdr('|', NOF_FLD_IMS, pbuf_ims));
}

int Ims_To_Voice_Event ()
{
    double       Rate_Pm = 0.0;     /* Rate Per Minute */
    double       Charge = 0.0;
    unsigned int Duration = 0;      /* Duration */
    //time_t       Seize_time = 0;    /* Seize Time in Seconds */

    char cIsIodc;
    char banding_model_id[2+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char charge_segment_id[SIZE_CHARGE_SEGMENT_ID+1];   /* AIN */
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char costgroup_id1[SIZE_COSTGROUP_ID+1];
    char costgroup_id2[SIZE_COSTGROUP_ID+1];
    char costcode_name[SIZE_COSTCODE_NAME+1];
    char costcode[SIZE_COSTCODE+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    char unit_duration[SIZE_UNIT_DURATION+1];
    char szMap_Cell_Ida[SIZE_COSTCODE+1];
    char szMap_Cell_Idb[SIZE_COSTCODE+1];
    char szChargeNet[SIZE_NET+1];
    char szHex_TAC[4+1];
    char szeNodeBCi[10+1];

    int iCategories = 0;
    int iFeature = 0;
    char szDetParams[SKIP_DET_STR_SIZE];
    char szDate[8+1];
    char szTime[6+1];
    char net_orig[SIZE_NET+1];

    int i = 0;
    char szTmp[30];

    memset(szDate, 0x00, sizeof(szDate));
    memset(szTime, 0x00, sizeof(szTime));
    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno));
    memset(net_orig, 0x00, sizeof(net_orig));
    memset(&com_buf, 0x00, sizeof(com_buf));
    memset(&voice_event, 0x00, sizeof(voice_event));
    memset(szMap_Cell_Ida, 0x00, sizeof(szMap_Cell_Ida));
    memset(szMap_Cell_Idb, 0x00, sizeof(szMap_Cell_Idb));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    strncpy(glb_OriginalBno, pbuf_ims[IMS_REAL_BNO], 100);
/* -------------------------------------------- */
/* ----- Validation --------------------------- */
/* -------------------------------------------- */
    memset(szTmp, 0x00, sizeof(szTmp));
    StrToUpper(pbuf_ims[IMS_USR_TYPE], strlen(pbuf_ims[IMS_USR_TYPE]), szTmp);
    if ( strcmp(szTmp, "POST_CAMEL") &&
         strcmp(szTmp, "POST_PAID") ) {
        fprintf(glb_Ignfp, "[DET] %s|User_Type|User_Type %s\n", glb_Eindex, pbuf_ims[IMS_USR_TYPE]);
        fputs(raw_input, glb_RCdrfp);    /* reject the record */
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( strcmp(pbuf_ims[IMS_REC_TYPE], "01") &&     /* VoLTE MOC */
         strcmp(pbuf_ims[IMS_REC_TYPE], "03") &&     /* VoLTE MFC */
         strcmp(pbuf_ims[IMS_REC_TYPE], "11") &&     /* VoWIFI MOC */
         strcmp(pbuf_ims[IMS_REC_TYPE], "13") &&     /* VoWIFI MFC */
         strcmp(pbuf_ims[IMS_REC_TYPE], "21") &&     /* VoFBB */
         strcmp(pbuf_ims[IMS_REC_TYPE], "31") &&     /* MOC Unknown */
         strcmp(pbuf_ims[IMS_REC_TYPE], "33") ) {    /* MFC Unknown */
        fprintf(glb_Ignfp, "[DET] %s|REC_Type|REC_Number %s\n", glb_MtxType, pbuf_ims[IMS_REC_TYPE]);
        fputs(raw_input, glb_RCdrfp);     /* reject the record */
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( Get_Service("GSMCDR", pbuf_ims[IMS_SVC_KEY], pbuf_ims[IMS_FCI], net_orig) &&
         Get_Service("GSMCDR", pbuf_ims[IMS_SVC_KEY], "*", net_orig) ) {
        fputs(raw_input, glb_RCdrfp);    /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Field|FCI| cdr_type(gsmcdr) service_key(%s) fci(%s)\n", glb_Eindex, pbuf_ims[IMS_SVC_KEY], pbuf_ims[IMS_FCI]);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( (glb_AisInstFlag == FALSE && glb_DpcInstFlag == FALSE) && !strcmp(net_orig, "GSM") ) {
        fputs(raw_input, glb_RCdrfp); /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|ORG_Call|GSM| service_key(%s) fci(%s)\n", glb_Eindex, pbuf_ims[IMS_SVC_KEY], pbuf_ims[IMS_FCI]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( glb_12cInstFlag == FALSE && !strcmp(net_orig, "PPS") ) {
        fputs(raw_input, glb_RCdrfp); /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|ORG_Call|PPS| service_key(%s) fci(%s)\n", glb_Eindex, pbuf_ims[IMS_SVC_KEY], pbuf_ims[IMS_FCI]);
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( strcmp(net_orig, "GSM") && strcmp(net_orig, "PPS") &&   /* Net is not Postpaid (GSM) and is not Prepaid (PPS) */
         strcmp(net_orig, "BOS") ) {
        fputs(raw_input, glb_RCdrfp); /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Field|Network| network_origin(%s) service_key(%s) fci(%s)\n", glb_Eindex, net_orig, pbuf_ims[IMS_SVC_KEY], pbuf_ims[IMS_FCI]);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Validate Network */
    if ( !strcmp(net_orig, "GSM") ) {
        /* Feed This AIS CDR only included AIS Installation */
        if ( !glb_AisInstFlag && !strcmp(net_orig, "GSM") ) {   /* Not Included AIS Installation */
            fputs(raw_input, glb_RCdrfp); /* reject the record */
            fprintf(glb_Ignfp, "[DET] %s|Not_Install|AIS| not included(AIS) network(%s)\n", glb_Eindex, net_orig);
            glb_IgnCtr++;
            return FAILURE;
        }
        /* Feed This DPC CDR only included DPC Installation */
        if ( !glb_DpcInstFlag && !strcmp(net_orig, "DPC") ) {     /* Not Included DPC Installation */
            fputs(raw_input, glb_RCdrfp); /* reject the record */
            fprintf(glb_Ignfp, "[DET] %s|Not_Install|DPC| not included(DPC) network(%s)\n", glb_Eindex, net_orig);
            glb_IgnCtr++;
            return FAILURE;
        }
        glb_PartId = AWN_SVC_PARTITION;
    }
    else if ( !strcmp(net_orig, "PPS") ) {
        Split_Pps_Cdr(raw_input);    /* write pps awn record to another file */
        /* Feed This 12C CDR only included 12C Installation */
        if ( !glb_12cInstFlag && !strcmp(net_orig, "PPS") ) {     /* Not Included 12c Installation */
            fputs(raw_input, glb_RCdrfp);    /* reject the record */
            fprintf(glb_Ignfp, "[DET] %s|Not_Install|12C| not included(12c) network(%s)\n", glb_Eindex, net_orig);
            glb_IgnCtr++;
            return FAILURE;
        }
        glb_PartId = PREPAID_SVC_PARTITION;
    }

    if ( glb_PartId == AWN_SVC_PARTITION || glb_PartId == PREPAID_SVC_PARTITION )
        strcpy(voice_event.partition_id, AWN_PARTITION);   /* Postpaid Partition */
    else {
        fprintf(glb_Errfp, "[DET] %s|Field|Partition| partition_id(%d)\n", glb_Eindex, glb_PartId);
        glb_ErrCtr++;
        return FAILURE;
    }

    strncpy(szDate, pbuf_ims[IMS_START_DT], 8);
    strncpy(szTime, pbuf_ims[IMS_START_DT]+8, 6);
#ifdef DEBUG_NO    /* Use this for debug only */
printf ("%s DT=%-14s => %s, %s\n", szCdrType, pbuf_ims[IMS_START_DT], szDate, szTime);
#endif
    if ( !IsValid_YYYYMMDD_HHMMSS(szDate, szTime) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date(%s) start_time(%s)\n",
                glb_Eindex, szDate, szTime);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Added Check for reject CDR that older than glb_OldCdrDay */
    if ( strncmp(szDate, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fputs(raw_input, glb_RCdrfp);    /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n",
                glb_Eindex, szDate, szTime, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    /* Seize Time & Date */
    //Seize_time = Calc_SeizeTime(szDate, szTime);
    //sprintf(voice_event.time_key, "%010ld", Seize_time);
    sprintf(voice_event.time_key, "%s%s", szDate, szTime);
    strcpy(glb_CurCDRDate, szDate);
    strcpy(glb_CurCDRTime, szTime);

    /* Duration in Seconds */
    if ( !Is_Number(pbuf_ims[IMS_TOTAL_DUR]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Duration| duration(%s)\n", glb_Eindex, pbuf_ims[IMS_TOTAL_DUR]);
        glb_ErrCtr++;
        return FAILURE;
    }

    Duration = atoi(pbuf_ims[IMS_TOTAL_DUR]);
    strcpy(voice_event.duration, pbuf_ims[IMS_TOTAL_DUR]);

    /* map a_no */
    if ( Conv_Ano(pbuf_ims[IMS_ANO], com_buf.a_no) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    strncpy(voice_event.mobile_num, com_buf.a_no, 16);
    strncpy(voice_event.from_number, com_buf.a_no, 18);

    /* map b_no */
    if ( !strlen(pbuf_ims[IMS_BNO]) ) { /* b_no blank */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( Conv_CommonVoice_Bno(pbuf_ims[IMS_BNO], com_buf.b_no) ) {   /* Invalid b_no */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO| invalid b_no(%s)\n", glb_Eindex, pbuf_ims[IMS_BNO]);
        glb_ErrCtr++;
        return FAILURE;
    }
    strcpy(voice_event.to_number, com_buf.b_no);
    Conv_RealBno(voice_event.to_number, voice_event.bno);
#ifdef DEBUG_NO    /* Use this for debug only */
printf ("%s Ano=%-30s => %s\n", szCdrType, pbuf_ims[IMS_ANO], voice_event.mobile_num);
printf ("\t Bno=%-30s => %s\n", pbuf_ims[IMS_BNO], voice_event.to_number);
#endif
/* -------------------------------------------- */
/* ----- Value Assignment for Rating ---------- */
/* ----- and Record Preparation --------------- */
/* -------------------------------------------- */
    cIsIodc = Is_IodcNumber(voice_event.to_number); /* Introduced IODC Mapping Table */
    strcpy(voice_event.country_code, "66");                             /* default for Thailand */

    iCategories = CAT_VOICE|CAT_TOTAL;

    if ( (!strncmp(voice_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
         !strncmp(voice_event.to_number, EPHACC_CODE, EPHACC_LEN)) &&   /* CAT Intl' Call */
         !cIsIodc ) {                                                   /* But not Operator Assisted Call */

        iCategories |= CAT_IDD;
        switch ( Parse_Country(voice_event.to_number, voice_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                glb_ErrCtr++;
                return FAILURE;
        }
    }
    else if ( !strncmp(voice_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||     /* 007 */
              !strncmp(voice_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||   /* 008 - TOT VOIP Intl' Calls */
              !strncmp(voice_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN) || /* 002 - TOT VOIP Malay Intl' Calls*/
              !strncmp(voice_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||     /* AIN 3rd Product Intl */
              !strncmp(voice_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||     /* AIN 2nd Product Intl */
              !strncmp(voice_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||     /* AIN Intl */
              !strncmp(voice_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {    /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */

        iCategories |= CAT_IDD;
        switch ( Parse_Country (voice_event.to_number, voice_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                glb_ErrCtr++;
                return FAILURE;
        }
    }
    else if ( !cIsIodc && *voice_event.to_number == '0' ) {

        iCategories |= CAT_LOCAL;
        /* Area Code Called (within Thailand) */
        switch ( Parse_Area(voice_event.to_number, voice_event.area_code) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
                break;
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Area| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                break;
        }
    }

    if ( !strncmp(voice_event.to_number, LDDACC1_CODE, LDDACC1_LEN) ||      /* LDD Calls C0xxxxxxx */
         !strncmp(voice_event.to_number, LDDACC2_CODE, LDDACC2_LEN) ||      /* LDD Calls #0xxxxxxx */
         !strncmp(voice_event.to_number, "1900", 4) ||
         !strncmp(voice_event.to_number, "900909", 6) ||
         !strncmp(voice_event.to_number, "B909", 4) ||
         !strncmp(voice_event.to_number, "*909", 4) ) {
        iCategories |= CAT_PREMIUM;
    }
    else if ( !strncmp(voice_event.to_number, "900", 3) ||      /* IVR Service */
              !strncmp(voice_event.to_number, "*", 1) ||        /* IVR Service */
              !strncmp(voice_event.to_number, "B", 1) ) {       /* IVR Service */
        iCategories |= CAT_VAS|CAT_LOCAL;
    }

    strcpy(banding_model_id, "1");
    strcpy(event_class_id, "16");
    strcpy(rating_tariff_id, "1");
    if ( iCategories & CAT_IDD ) {
        strcpy(rating_tariff_id, "284");
    }

    if ( !strncmp(pbuf_ims[IMS_CF], "1", 1) ||
         !strcmp(pbuf_ims[IMS_REC_TYPE], "03") ||       /* MFC */
         !strcmp(pbuf_ims[IMS_REC_TYPE], "13") ||       /* MFC */
         !strcmp(pbuf_ims[IMS_REC_TYPE], "33") ) {      /* MFC */
        iFeature = FEAT_FORWARD;
        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);
        strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);
        strcpy(event_class_id, "12");
    }
    if ( strncmp(pbuf_ims[IMS_CALL_WAIT], "1", 1) == 0 ) {
        iFeature = FEAT_WAIT;
        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);
    }
    if ( strncmp(pbuf_ims[IMS_CALL_HOLD], "1", 1) == 0 ) {
        iFeature = FEAT_HOLD;
        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);
    }
    if ( strncmp(pbuf_ims[IMS_CALL_CONF], "1", 1) == 0 ) {
        iFeature = FEAT_CONFERENCE;
        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);
    }

    memset(szTmp, 0x00, sizeof(szTmp));
    StrToUpper(pbuf_ims[IMS_WIFI_COUNTRY_INFO], strlen(pbuf_ims[IMS_WIFI_COUNTRY_INFO]), szTmp);
    /* ----- VoWIFI ----- */
    if ( !strcmp(pbuf_ims[IMS_REC_TYPE], "11") ||   /* VoWIFI */
         !strcmp(pbuf_ims[IMS_REC_TYPE], "13") ) {

        if ( !strcmp(szTmp, "OTHER") ||     /* Domestic */
             !strcmp(szTmp, "NULL") ||
             !strcmp(szTmp, "TH") ||
             !strlen(szTmp) ) {
            strcpy(voice_event.remarks, "VoWIFI");
            strcpy(voice_event.cell, "C0001");
            strcpy(voice_event.cell_set, "W0001");
            strcpy(voice_event.cell_area, DEF_CELL_AREA);
            strcpy(szMap_Cell_Ida, "WIFICALL");
        }
        else {  /* IR-WIFI */
            strcpy(voice_event.remarks, "VoWIFI-IR");
            strcpy(voice_event.cell, "C0002");
            strcpy(voice_event.cell_set, "W0002");
            strcpy(voice_event.cell_area, DEF_CELL_AREA);
            strcpy(szMap_Cell_Ida, "IWIFICALL");
        }
    }
    /* ----- VoLTE ----- */
    else if ( !strcmp(pbuf_ims[IMS_REC_TYPE], "01") ||      /* MOC VoLTE */
              !strcmp(pbuf_ims[IMS_REC_TYPE], "03") ||      /* MFC VoLTE */
              !strcmp(pbuf_ims[IMS_REC_TYPE], "31") ||      /* MOC Voice4G */
              !strcmp(pbuf_ims[IMS_REC_TYPE], "33") ) {     /* MFC Voice4G */

        if ( !strcmp(pbuf_ims[IMS_REC_TYPE], "01") || !strcmp(pbuf_ims[IMS_REC_TYPE], "03") ) {
            strcpy(voice_event.remarks, "VoLTE");
        }
        else {
            strcpy(voice_event.remarks, "Voice4G");
        }
#if 0
        if ( strlen(pbuf_ims[IMS_CALLER_TAC]) ) {   // use 4G info.
            sprintf(szHex_TAC, "%04x", atoi(pbuf_ims[IMS_CALLER_TAC]));     /* convert input decimal TAC to hex TAC */
            sprintf(szeNodeBCi, "%d%d", atoi(pbuf_ims[IMS_CALLER_ENODEB_ID]), atoi(pbuf_ims[IMS_CALLER_CI]));
            sprintf(voice_event.cell, "%05s", decTo64(szeNodeBCi));
            sprintf(voice_event.cell_set, "%05d", atoi(pbuf_ims[IMS_CALLER_TAC]));
            sprintf(voice_event.cell_area, "4G0%c%c", szHex_TAC[0], szHex_TAC[1]);
            //sprintf(szMap_Cell_Ida, "T%s", szHex_TAC);
            sprintf(szMap_Cell_Ida, "T%s", pbuf_ims[IMS_CALLER_TAC]);
        }
        else {  // if there is no 4G cell info use 3G cell info.
            strcpy(szeNodeBCi, pbuf_ims[IMS_CALLER_IC_3G]);
            sprintf(voice_event.cell, "%05s", pbuf_ims[IMS_CALLER_IC_3G]);
            sprintf(voice_event.cell_set, "%05s", pbuf_ims[IMS_CALLER_LAC_3G]);
            strcpy(voice_event.cell_area, "000");
            strncpy(voice_event.cell_area+3, pbuf_ims[IMS_CALLER_LAC_3G]+2, 2);
            sprintf(szMap_Cell_Ida, "M%s", pbuf_ims[IMS_CALLER_LAC_3G]);
        }
#endif
        if ( strlen(pbuf_ims[IMS_CALLER_TAC]) ) {   // use 4G info.
            sprintf(szeNodeBCi, "%d%d", atoi(pbuf_ims[IMS_CALLER_ENODEB_ID]), atoi(pbuf_ims[IMS_CALLER_CI]));
        }
        else {  // if there is no 4G cell info use 3G cell info.
            strcpy(szeNodeBCi, pbuf_ims[IMS_CALLER_IC_3G]);
        }
        if ( voice_event.cell_area[0] == '\0' ) {
            if ( Get_GeoData(szeNodeBCi, voice_event.cell, voice_event.cell_set, voice_event.cell_area) != SUCCESS ) {
                fprintf(glb_Errfp, "[DET] %s|GeoMapp|Cell_IDA| cell_id_a(%s) but not skip\n", glb_Eindex, szeNodeBCi);
                strcpy(voice_event.cell_area, UNK_CELL_AREA);
            }
        }
    }
    else {  /* RecType 21 => VoFBB */
//printf("VOBB\n");
        strcpy(voice_event.remarks, "VOBB");
        return (Ims_To_Fix_Event(iCategories, iFeature, szDetParams));
//printf("exit\n");
    }
    strcpy(voice_event.imei, pbuf_ims[IMS_CALLER_IMEI]);
/* -------------------------------------------- */
/* ----- Rating (Charge calculation) ---------- */
/* -------------------------------------------- */
    /* Check for feed PPS CDR on SSP/GSM/DPCGSM type */
    if ( !strcmp(net_orig, "PPS") ) {          /* PPS Service */
        /* Do not Calculate Charge rate for PPS CDR, we check only velocity */
        Rate_Pm = 0.0;          /* No Charge */
        Charge = 0.0;
    }
    else if ( !strncmp(voice_event.to_number, "000", 3) ) { /* AIS Extension Call */
        Rate_Pm = 0.0;          /* No Charge */
        Charge = 0.0;
    }
    else if ( cIsIodc ) {       /* Operator Assisted */
        Rate_Pm = 0.0;
        Charge = 0.0;
    }
    else if ( !strncmp(voice_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
              !strncmp(voice_event.to_number, EPHACC_CODE, EPHACC_LEN) ) {

        /* CAT International call */
        if ( Get_CostcodeBno(pbuf_ims[IMS_BNO], costcode) != SUCCESS ) {
            // cost code as got from the mapping table ELSE
            // cost code as first 10 digits Bno
            strncpy(costcode, voice_event.to_number, 10);
        }
        strcpy(charge_segment_id, "37");

        if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) {     /* FAILURE */
            fputs(raw_input, glb_RCdrfp);    /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTCODE| null cost_band_id of banding_model_id(%s) costcode(%s)\n", glb_Eindex, banding_model_id, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }

        if ( Parse_RatingElement4(rating_tariff_id, cost_band_id, event_class_id, charge_segment_id, fix_charge_mny, charge_rate, unit_duration)    ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s) charge_segment_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id, charge_segment_id);
            fputs(raw_input, glb_RCdrfp); /* reject the record */
            glb_ErrCtr++;
            return FAILURE;
        }
        else {
            /* Get Rate in Baht Unit */
            if ( *charge_rate )
                Rate_Pm = (double)atol(charge_rate) / 100000.0;
            else
                Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

            Charge = (double)Calc_IntlCharge(Duration, Rate_Pm);
            Charge = (double)Charge * 100;     /* Convert to Satang */
        }
    }
    else if ( !strncmp(voice_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
              !strncmp(voice_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ) {

        /* TOT International call Except 002 */
        if ( Get_CostcodeBno(pbuf_ims[IMS_BNO], costcode) != SUCCESS ) {
            // cost code as got from the mapping table ELSE
            // cost code as first 10 digits Bno
            strncpy(costcode, voice_event.to_number, 10);
        }
        if ( Lookup_Costcode(banding_model_id, costcode, costgroup_id1, cost_band_id, costcode_name) ) {
            fputs(raw_input, glb_RCdrfp); /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !*costgroup_id1 && !*cost_band_id ) {  /* Both Cost_Group_Id and Cost_Band_Id are NULL */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_Blank_After_COSTCODE| costgroup_id1 and cost_band_id are null of banding_model_id(%s) costcode(%s)\n",
                    glb_Eindex, banding_model_id, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        else if ( *costgroup_id1 ) {    /* Cost_Group_Id is Not NULL */
            strcpy(costcode, szTmp);
            if ( Get_RmCostGroupId(banding_model_id, costcode, costgroup_id2) ) {
                fputs(raw_input, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*costgroup_id2 ) {    /* Cost_Group_Id1 is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_ID2_Blank_After_COSTCODE| costgroup_id2 is null of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( Get_XfCostBandId(banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
                fputs(raw_input, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| costgroup_id1(%s) costgroup_id2(%s)\n",
                        glb_Eindex, costgroup_id1, costgroup_id2);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTGROUP| null cost_band_id of banding_model_id(%s) costgroup_id1(%s) costgroup_id2(%s)\n",
                    glb_Eindex, banding_model_id, costgroup_id1, costgroup_id2);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                fputs(raw_input, glb_RCdrfp); /* reject the record */
                glb_ErrCtr++;
                return FAILURE;
            }
            else {
                /* Get Rate in Baht Unit */
                if ( *charge_rate )
                    Rate_Pm = (double)atol(charge_rate) / 100000.0;
                else
                    Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

                Charge = (double)Calc_IntlCharge (Duration, Rate_Pm);
                Charge = (double)Charge * 100;     /* Convert to Satang */
            }
        }
        else {  /* Cost_Group_Id is NULL */
            if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                fputs(raw_input, glb_RCdrfp);    /* reject the record */
                glb_ErrCtr++;
                return FAILURE;
            }
            else {
                /* Get Rate in Baht Unit */
                if ( *charge_rate )
                    Rate_Pm = (double)atol(charge_rate) / 100000.0;
                else
                    Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

                Charge = (double)Calc_IntlCharge(Duration, Rate_Pm);
                Charge = (double)Charge * 100;     /* Convert to Satang */
            }
        }
    }
    else if ( !strncmp(voice_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||     /* AIN 3rd Product Intl */
              !strncmp(voice_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||     /* AIN 2nd Product Intl */
              !strncmp(voice_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||     /* AIN Intl */
              !strncmp(voice_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {

        strncpy(costcode, voice_event.to_number, 10);
        strcpy(charge_segment_id, "37");

        if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) {     /* FAILURE */
            fputs(raw_input, glb_RCdrfp); /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTCODE| null cost_band_id of banding_model_id(%s) costcode(%s)\n", glb_Eindex, banding_model_id, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( Parse_RatingElement4(rating_tariff_id, cost_band_id, event_class_id, charge_segment_id, fix_charge_mny, charge_rate, unit_duration) ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s) charge_segment_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id, charge_segment_id);
            fputs(raw_input, glb_RCdrfp);    /* reject the record */
            glb_ErrCtr++;
            return FAILURE;
        }
        else {
            /* Get Rate in Baht Unit */
            Rate_Pm = ((double)atol(charge_rate) / 100000.0) / (atol(unit_duration) / 100.0) * 60.0;
            Charge = (double)Calc_AinIntlCharge(Duration, Rate_Pm);
            Charge = (double)Charge * 100;     /* Convert to Satang */
        }
    }
    else if ( !strncmp(voice_event.to_number, "1900", 4) ||    /* Audio Text */
              !strncmp(voice_event.to_number, "900", 3) ||     /* IVR Service */
              !strncmp(voice_event.to_number, "*", 1) ||       /* IVR Service */
              !strncmp(voice_event.to_number, "B", 1) ) {      /* IVR Service */

        if ( !strncmp(voice_event.to_number, "1900", 4) ) {     /* Audio Text */

            strcpy(costcode, "1900");
            strncpy(costcode+4, voice_event.to_number+4, 10);
            if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) { /* FAILURE */
                fputs(raw_input, glb_RCdrfp); /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*cost_band_id ) { /* Cost_Band_Id is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTCODE| null cost_band_id of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
        }
        else {

            strcpy(costcode, voice_event.to_number);

            if ( Get_RmCostBandId2(banding_model_id, costcode, cost_band_id, voice_event.remarks) ) {  /* FAILURE */

                memset(szTmp, 0x00, sizeof(szTmp));
                if ( !strncmp(voice_event.to_number, "900", 3) ) {  /* IVR Service */
                    strcpy(szTmp, voice_event.to_number+3);
                }
                else {  /* Bno started with '*' or 'B' */
                    strcpy(szTmp, voice_event.to_number+1);
                }

                for ( i=0; i<3; i++ ) {
                    strcpy(costcode, ivracc_tab[i]);
                    strcat(costcode, szTmp);
                    memset(voice_event.remarks, 0x00, sizeof(voice_event.remarks));
                    if ( Get_RmCostBandId2(banding_model_id, costcode, cost_band_id, voice_event.remarks) ) {  /* FAILURE */
                        continue;
                    }
                    if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
                        continue;
                    }
                    break;
                }
                if ( i >= 3 ) {
                    fputs(raw_input, glb_RCdrfp);    /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, voice_event.to_number);
                    glb_ErrCtr++;
                    return FAILURE;
                }
            }

        }
        if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
            fputs(raw_input, glb_RCdrfp); /* reject the record */
            glb_ErrCtr++;
            return FAILURE;
        }
        else {
            /* Get Rate in Baht Unit */
            if ( *charge_rate )
                Rate_Pm = (double)atol(charge_rate) / 100000.0;
            else
                Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

            if ( !strncmp(voice_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN) ) {
                /* TOT Intl' 002 */
                Charge = (double)Calc_IntlCharge(Duration, Rate_Pm);
                Charge = (double)Charge * 100;     /* Convert to Satang */
            }
            else {
                /*
                ** Changed Voice Charge Concept by don't use duration
                ** for calculate in case that use fix_charge_mny
                */
                if ( *charge_rate ) {
                    Charge = (double)Calc_NatlCharge(Duration, Rate_Pm);
                    Charge = (double)Charge * 100;     /* Convert to Satang */
                }
                else {
                    Charge = (double)Rate_Pm * 100;    /* Convert to Satang */
                }
            }
        }
    }
    else {  /* Normal Call */
        if ( !strcmp(pbuf_ims[IMS_REC_TYPE], "03") || !strcmp(pbuf_ims[IMS_REC_TYPE], "13") || !strcmp(pbuf_ims[IMS_REC_TYPE], "33") ) {
            /* MFC */

            strcpy(szMap_Cell_Idb, "MF6803");

            if ( !szMap_Cell_Ida[0] ) {     /* if szMap_Cell_Ida is not assigned */
                if ( strncmp(pbuf_ims[IMS_CALLER_MCC], "901", 3) == 0 ) {   /* maritime */
                    strcpy(szMap_Cell_Ida, "MO");
                    strcat(szMap_Cell_Ida, szHex_TAC);
                    szMap_Cell_Ida[7] = 0;
                }
                else if ( *pbuf_ims[IMS_CALLER_IMSI] ) {
                    sprintf(szMap_Cell_Ida, "AWN%c%c", pbuf_ims[IMS_CALLER_IMSI][5], pbuf_ims[IMS_CALLER_IMSI][6]);     // using position of 6 and 7 of IMSI
                }
                else {
                    fputs(raw_input, glb_RCdrfp); /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| imsi(%s)\n", glb_Eindex, pbuf_ims[IMS_CALLER_IMSI]);
                    glb_ErrCtr++;
                    return FAILURE;
                }
            }
        }
        else {
            /* MOC */
            strncpy(szMap_Cell_Idb, voice_event.to_number, 10);
            szMap_Cell_Idb[10] = 0;

            if ( !szMap_Cell_Ida[0] ) {     /* if szMap_Cell_Ida is not assigned */
                if ( *pbuf_ims[IMS_CALLER_IMSI] ) {
                    sprintf(szMap_Cell_Ida, "T%s", szHex_TAC);
                    szMap_Cell_Ida[6] = 0;
                }
                else {
                    fputs(raw_input, glb_RCdrfp); /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| cell_ida(%s)\n", glb_Eindex, pbuf_ims[IMS_CALLER_TAC]);
                    glb_ErrCtr++;
                    return FAILURE;
                }
            }
        }

        memset(costcode_name, 0x00, sizeof(costcode_name));
        /* check if costgroup_id1 exist, otherwise cost_band_id will be used as mapping field for rating  */
        if ( Lookup_Costcode(banding_model_id, szMap_Cell_Idb, costgroup_id1, cost_band_id, costcode_name) ) {  /* FAILURE */
            fputs(raw_input, glb_RCdrfp);    /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, szMap_Cell_Idb);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !strncmp(costcode_name, "AIS", 3) || !strncmp(costcode_name, "AWN", 3) ) {
            /* strcpy(szChargeNet, costcode_name); */
            strncpy(szChargeNet, costcode_name, SIZE_NET);
            //iCategories |= CAT_ONNET;
        }
        else {
            /* strcpy(szChargeNet, "OTH"); */
            strncpy(szChargeNet, "OTH", SIZE_NET);
            //iCategories |= CAT_OFFNET;
        }

        if ( strcmp(voice_event.area_code, "") ) { /* Area Code not Blank */
            strcpy(voice_event.oper_name, "FIX");
        }
        else {
            strncpy(voice_event.oper_name, costcode_name, SIZE_OPER);
        }

        /* --- Rating Section --- */
        if ( glb_UseFixRateFlag == 'Y' &&
             Get_FixRate(szChargeNet, charge_rate) == SUCCESS &&
             !(iCategories & CAT_MARITIME) ) {
            /* Get Rate in Satang Unit */
            /*
            ** Changed Voice Charge Concept to fix rate and calculate with duration
            */
            Rate_Pm = (double)atol(charge_rate) / 100.0;
            Charge = (double)Calc_NatlCharge (Duration, Rate_Pm);
            Charge = (double)Charge * 100;     /* Convert to Satang */
        }
        else {
            if ( !*costgroup_id1 && !*cost_band_id ) {  /* Both Cost_Group_Id and Cost_Band_Id are NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_Blank_After_COSTCODE| costgroup_id1 and cost_band_id are null of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, szMap_Cell_Idb);
                glb_ErrCtr++;
                return FAILURE;
            }
            else if ( *costgroup_id1 ) {    /* Cost_Group_Id is Not NULL */
                if ( Get_RmCostGroupId(banding_model_id, szMap_Cell_Ida, costgroup_id2) ) {
                    fputs(raw_input, glb_RCdrfp);    /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| cell_ida(%s)\n", glb_Eindex, szMap_Cell_Ida);
                    glb_ErrCtr++;
                    return FAILURE;
                }
                if ( !*costgroup_id2 ) {    /* Cost_Group_Id1 is NULL */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_ID2_Blank_After_COSTCODE| costgroup_id2 is null of banding_model_id(%s) costcode(%s)\n",
                            glb_Eindex, banding_model_id, szMap_Cell_Ida);
                    glb_ErrCtr++;
                    return FAILURE;
                }
                if ( Get_XfCostBandId(banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
                    fputs(raw_input, glb_RCdrfp); /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| costgroup_id1(%s) costgroup_id2(%s)\n",
                        glb_Eindex, costgroup_id1, costgroup_id2);
                    glb_ErrCtr++;
                    return FAILURE;
                }
                if ( !*cost_band_id ) {   /* Cost_Band_Id is NULL */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTGROUP| null cost_band_id of banding_model_id(%s) costgroup_id1(%s) costgroup_id2(%s)\n",
                            glb_Eindex, banding_model_id, costgroup_id1, costgroup_id2);
                    glb_ErrCtr++;
                    return FAILURE;
                }
            }

            /* costgroup_id1 is NULL or cost_band_id is set */
            if ( Parse_RatingElement3Avg(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fputs(raw_input, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
                        glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                glb_ErrCtr++;
                return FAILURE;
            }
            else {
                /* Get Rate in Baht Unit */
                /*
                ** Changed Voice Charge Concept by don't use duration
                ** for calculate in case that use fix_charge_mny
                */
                if ( *charge_rate ) {
                    Rate_Pm = (double)atol(charge_rate) / 100000.0;
                    Charge = (double)Calc_NatlCharge(Duration, Rate_Pm);
                    Charge = (double)Charge * 100;      /* Convert to Satang */
                }
                else {
                    Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;
                    Charge = (double)Rate_Pm * 100;     /* Convert to Satang */
                }
            }
        }
    }   // End of normal voice call section

    if ( !(iCategories & CAT_MARITIME) ) {  /* if category is not maritime then further check for onelove and tollfree */
        if ( Is_OneLoveNum(voice_event.from_number, voice_event.to_number) == SUCCESS ) {  /* Added by Thanakorn on Sep-2013 */
            Charge = 0;     /* set charge = zero when call to one love number */
        }
        else if ( Is_TollFree(voice_event.to_number, szTmp) == SUCCESS ) {   /* Added by Thanakorn on Aug-2015 */
            Charge = 0;
        }
    }
/* -------------------------------------------- */
/* ----- Event Record Preparation ------------- */
/* -------------------------------------------- */
    glb_EventId = VOICE_EVENT_TYPE;
    sprintf(voice_event.event_type, "%02d", glb_EventId);
    //voice_event.service_type = ST_HOME;
    strcpy(voice_event.service_type, ST_HOME);

    // Features and Detection Parameters
    if ( strcmp(net_orig, "GSM") == 0 )
        iFeature = FEAT_POSTPAID_CALL;
    else
        iFeature = FEAT_PREPAID_CALL;

    sprintf(voice_event.fee_charge, "%010.0lf", 0.0f);
    if ( iCategories & CAT_MARITIME ) {
        iCategories &= ~CAT_LOCAL;      // remove CAT_LOCAL out, so that maritime will not sum to Voice Local dimension.
        //iCategories &= ~CAT_ONNET;
        //iCategories &= ~CAT_OFFNET;
        iCategories &= ~CAT_VAS;
        iCategories &= ~CAT_PREMIUM;
        if ( iCategories & CAT_IDD ) {
            sprintf(voice_event.charge, "%010.0lf", (Charge+(25*100)));     // adds extra charge for maritime idd 25 THB
            sprintf(voice_event.fee_charge, "%010d", (25*100));
        }
    }

    if ( glb_UseRatedCdr == 1 ) {
        if ( (iCategories & CAT_VOICE || iCategories & CAT_VAS) && iCategories & CAT_LOCAL ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Use_RBM|\n", glb_Eindex);
            glb_ErrCtr++;
            return FAILURE; // if RBM cdr is used, only voice local or voice vas from other cdr type is rejected.
        }
    }

    sprintf(voice_event.charge, "%010.0lf", Charge);
    sprintf(voice_event.features, "%010d", iFeature);
    strcpy(voice_event.detect_params, szDetParams);
    sprintf(voice_event.categories, "%08d", iCategories);
    strcpy(voice_event.original_bno, glb_OriginalBno);
    strcpy(voice_event.event_src, glb_EventSource);

    if ( iCategories & CAT_IDD ) {  // Added by Thanakorn
        glb_EventId = VOICE_EVENT_TYPE_IDD; // Actually it's voice event but just for categorize Priority Tube by IUM)
    }

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

int Ims_To_Fix_Event (int cat, int feat, char *detect)
{
    int iCategories = cat;
    int iFeature = feat;
    char szDetParams[SKIP_DET_STR_SIZE];
    unsigned int Duration = 0;
    double Charge;
    double Rate_Pm = 0.0;     /* Rate Per Minute */
    char banding_model_id[2+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char szMap_Cell_Ida[SIZE_COSTCODE+1];
    char szMap_Cell_Idb[SIZE_COSTCODE+1];

    //char charge_segment_id[SIZE_CHARGE_SEGMENT_ID+1];   /* AIN */
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char costgroup_id1[SIZE_COSTGROUP_ID+1];
    char costgroup_id2[SIZE_COSTGROUP_ID+1];
    char costcode_name[SIZE_COSTCODE_NAME+1];
    //char costcode[SIZE_COSTCODE+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    //char unit_duration[SIZE_UNIT_DURATION+1];
    //char szChargeNet[SIZE_NET+1];

    memset(szMap_Cell_Ida, 0x00, sizeof(szMap_Cell_Ida));
    memset(szMap_Cell_Idb, 0x00, sizeof(szMap_Cell_Idb));
    memset(com_buf.a_no, 0x00, sizeof(com_buf.a_no));
    memset(szDetParams, 0x00, sizeof(szDetParams));
    // --- the following fields have been set from prior function ---
    // voice_event.parition
    // voice_event.time_key
    // voice_event.duration
    // voice_event.to_number
    // voice_event.country_code
    // voice_event.area_code
    // voice_event.remarks
    // --------------------------

    // simple mapping A_no
    if ( *pbuf_ims[IMS_ANO] == '0' ) {
        strcpy(com_buf.a_no, pbuf_ims[IMS_ANO]);
    }
    else if ( strncmp(pbuf_ims[IMS_ANO], "66", 2) == 0 ) {
        sprintf(com_buf.a_no, "0%s", pbuf_ims[IMS_ANO]+2);
    }
    else {
        sprintf(com_buf.a_no, "0%s", pbuf_ims[IMS_ANO]);
    }
    strncpy(voice_event.mobile_num, com_buf.a_no, 16);
    strncpy(voice_event.from_number, com_buf.a_no, 18);

    // --- the following fields have not been set ---
    // cell, cell_set, cell_area, oper_name, charge,
    // feature, detect_params, categories
    // ---------------------------

    // --- Set Categoriees ----
    //iCategories |= CAT_OUTGOING|CAT_ONNET;
    strcpy(voice_event.direction, OUTGOING);

    // --- Set Detection parameters ---
    sprintf(szDetParams, "%s%s%s", gaszFrmSkipDet[SKIP_VELOCITY], gaszFrmSkipDet[SKIP_COLLISION], gaszFrmSkipDet[SKIP_DUPEVENT]);

    // --- Set Feature ---
    // ... go here ...

    // --- Rating ---
    strcpy(banding_model_id, "1");
    strcpy(event_class_id, "16");
    strcpy(rating_tariff_id, "638");
    strncpy(szMap_Cell_Ida, pbuf_ims[IMS_ANO], 6);
    strncpy(szMap_Cell_Idb, pbuf_ims[IMS_BNO], 6);

    if ( Get_RmCostGroupId2(banding_model_id, szMap_Cell_Ida, costgroup_id2, costcode_name) ) {
        fputs(raw_input, glb_RCdrfp);   /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| cell_ida(%s)\n", glb_Eindex, szMap_Cell_Ida);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( Get_RmCostGroupId2(banding_model_id, szMap_Cell_Idb, costgroup_id1, costcode_name) ) {
        fputs(raw_input, glb_RCdrfp);   /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, szMap_Cell_Idb);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( Get_XfCostBandId(banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
        fputs(raw_input, glb_RCdrfp);   /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| costgroup_id1(%s) costgroup_id2(%s)\n",
            glb_Eindex, costgroup_id1, costgroup_id2);
        glb_ErrCtr++;
        return FAILURE;
    }

    Duration = atoi(voice_event.duration);
    if ( strlen(voice_event.area_code) > 0 && strncmp(voice_event.from_number, voice_event.area_code, strlen(voice_event.area_code)) == 0 ) {
        // call to the same area code -> fix rate
        Duration = 1;
    }

    if ( Parse_RatingElement3Avg(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
        fputs(raw_input, glb_RCdrfp);   /* reject the record */
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
                glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
        glb_ErrCtr++;
        return FAILURE;
    }
    else {
        /* Get Rate in Baht Unit */
        /*
        ** Changed Voice Charge Concept by don't use duration
        ** for calculate in case that use fix_charge_mny
        ** - by Kawee on 04-Jul-2007
        */
        if ( *charge_rate ) {
            Rate_Pm = (double)atol(charge_rate) / 100000.0;
            Charge = (double)Calc_NatlCharge(Duration, Rate_Pm);
            Charge = (double)Charge * 100;      /* Convert to Satang */
        }
        else {
            Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;
            Charge = (double)Rate_Pm * 100;     /* Convert to Satang */
        }
    }

    // --- Set event fields value ---
    glb_EventId = FIXED_EVENT_TYPE;
    sprintf(voice_event.event_type, "%02d", glb_EventId);
    //voice_event.service_type = ST_HOME;
    strcpy(voice_event.service_type, ST_HOME);
    strcpy(voice_event.original_bno, glb_OriginalBno);
    strcpy(voice_event.event_src, glb_EventSource);
    sprintf(voice_event.charge, "%010.0lf", Charge);
    sprintf(voice_event.fee_charge, "%010.0lf", 0.0f);
    sprintf(voice_event.features, "%010d", iFeature);
    strcpy(voice_event.detect_params, szDetParams);
    sprintf(voice_event.categories, "%08d", iCategories);

    return SUCCESS;

}

int Read_Rdc_Cdr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_Rdc_Cdr");
    _p_ = 0;
#endif
    memset(pbuf_rdc, 0x00, sizeof (pbuf_rdc));
    return (Read_Delimiter_Cdr('|', NOF_FLD_RDC, pbuf_rdc));
}

int Rdc_To_Voice_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Rdc_To_Voice_Event");
    _p_ = 0;
#endif
    double       Rate_Pm = 0.0;     /* Rate Per Minute */
    double       Charge = 0.0;
    unsigned int Duration = 0;      /* Duration */
    //time_t       Seize_time = 0;    /* Seize Time in Seconds */

    char cIsIodc;
    char banding_model_id[2+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char charge_segment_id[SIZE_CHARGE_SEGMENT_ID+1];   /* AIN */
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char costgroup_id1[SIZE_COSTGROUP_ID+1];
    char costgroup_id2[SIZE_COSTGROUP_ID+1];
    char costcode_name[SIZE_COSTCODE_NAME+1];
    char costcode[SIZE_COSTCODE+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    char unit_duration[SIZE_UNIT_DURATION+1];
    char szMap_Cell_Ida[SIZE_COSTCODE+1];
    char szMap_Cell_Idb[SIZE_COSTCODE+1];
    char szChargeNet[SIZE_NET+1];

    int iCategories = 0;
    int iFeature = 0;
    char szDetParams[SKIP_DET_STR_SIZE];
    char szDate[8+1];
    char szTime[6+1];

    int i = 0;
    char szTmp[30];

    memset(szDate, 0x00, sizeof(szDate));
    memset(szTime, 0x00, sizeof(szTime));
    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno));
    memset(&com_buf, 0x00, sizeof(com_buf));
    memset(&voice_event, 0x00, sizeof(voice_event));
    memset(szMap_Cell_Ida, 0x00, sizeof(szMap_Cell_Ida));
    memset(szMap_Cell_Idb, 0x00, sizeof(szMap_Cell_Idb));
    memset(szDetParams, 0x00, sizeof(szDetParams));

/* -------------------------------------------- */
/* ----- Validation --------------------------- */
/* -------------------------------------------- */
    memset(szTmp, 0x00, sizeof(szTmp));
    StrToUpper(pbuf_rdc[RDC_USR_TYPE], strlen(pbuf_rdc[RDC_USR_TYPE]), szTmp);

    if ( strcmp(szTmp, "POSTPAID") && strcmp(szTmp, "POST_VPN") && strcmp(szTmp, "POST_CAMEL") ) {
        fprintf(glb_Ignfp, "[DET] %s|User_Type|User_Type %s\n", glb_Eindex, pbuf_rdc[RDC_USR_TYPE]);
        fputs(raw_input, glb_RCdrfp);    /* reject the record */
        glb_IgnCtr++;
        return FAILURE;
    }

    if ( *pbuf_rdc[RDC_VISITED_NW] != '6' ) {
        fprintf(glb_Ignfp, "[DET] %s|Visit_NW|NW %s\n", glb_Eindex, pbuf_rdc[RDC_VISITED_NW]);
        fputs(raw_gsm, glb_RCdrfp);     /* reject the record */
        glb_IgnCtr++;
        return FAILURE;
    }

    strncpy(szDate, pbuf_rdc[RDC_CALL_ST_TIME], 8);
    strncpy(szTime, pbuf_rdc[RDC_CALL_ST_TIME]+8, 6);
#ifdef DEBUG_NO    /* Use this for debug only */
printf ("%s DT=%-14s => %s, %s\n", szCdrType, pbuf_rdc[IMS_START_DT], szDate, szTime);
#endif
    if ( !IsValid_YYYYMMDD_HHMMSS(szDate, szTime) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date(%s) start_time(%s)\n",
                glb_Eindex, szDate, szTime);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Added Check for reject CDR that older than glb_OldCdrDay */
    if ( strncmp(szDate, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fputs(raw_input, glb_RCdrfp);    /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n",
                glb_Eindex, szDate, szTime, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    /* Seize Time & Date */
    //Seize_time = Calc_SeizeTime(szDate, szTime);
    //sprintf(voice_event.time_key, "%010ld", Seize_time);
    sprintf(voice_event.time_key, "%s%s", szDate, szTime);
    strcpy(glb_CurCDRDate, szDate);
    strcpy(glb_CurCDRTime, szTime);

    /* Duration in Seconds */
    if ( !Is_Number(pbuf_rdc[RDC_CALL_DUR]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Duration| duration(%s)\n", glb_Eindex, pbuf_rdc[RDC_CALL_DUR]);
        glb_ErrCtr++;
        return FAILURE;
    }

    Duration = atoi(pbuf_rdc[RDC_CALL_DUR]);
    strcpy(voice_event.duration, pbuf_rdc[RDC_CALL_DUR]);

    /* map a_no */
    if ( Conv_Ano(pbuf_rdc[RDC_MOBILE_NO], com_buf.a_no) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    strncpy(voice_event.mobile_num, com_buf.a_no, 16);
    strncpy(voice_event.from_number, com_buf.a_no, 18);

    /* map b_no */
    if ( !strlen(pbuf_rdc[RDC_CALLED_B_NO]) ) { /* b_no blank */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( Conv_CommonVoice_Bno(pbuf_rdc[RDC_CALLED_B_NO], com_buf.b_no) ) {   /* Invalid b_no */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO| invalid b_no(%s)\n", glb_Eindex, pbuf_rdc[RDC_CALLED_B_NO]);
        glb_ErrCtr++;
        return FAILURE;
    }
    strcpy(voice_event.to_number, com_buf.b_no);
#ifdef DEBUG_NO    /* Use this for debug only */
printf ("%s Ano=%-30s => %s\n", szCdrType, pbuf_rdc[RDC_MOBILE_NO], voice_event.mobile_num);
printf ("\t Bno=%-30s => %s\n", pbuf_rdc[RDC_CALLED_B_NO], voice_event.to_number);
#endif
/* -------------------------------------------- */
/* ----- Value Assignment for Rating ---------- */
/* ----- and Record Preparation --------------- */
/* -------------------------------------------- */
    cIsIodc = Is_IodcNumber(voice_event.to_number); /* Introduced IODC Mapping Table */
    strcpy(voice_event.country_code, "66");                             /* default for Thailand */

    if ( (!strncmp(voice_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
         !strncmp(voice_event.to_number, EPHACC_CODE, EPHACC_LEN)) &&   /* CAT Intl' Call */
         !cIsIodc ) {                                                   /* But not Operator Assisted Call */

        iCategories |= CAT_IDD;
        switch ( Parse_Country(voice_event.to_number, voice_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                glb_ErrCtr++;
                return FAILURE;
        }
    }
    else if ( !strncmp(voice_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||     /* 007 */
              !strncmp(voice_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||   /* 008 - TOT VOIP Intl' Calls */
              !strncmp(voice_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN) || /* 002 - TOT VOIP Malay Intl' Calls*/
              !strncmp(voice_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||     /* AIN 3rd Product Intl */
              !strncmp(voice_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||     /* AIN 2nd Product Intl */
              !strncmp(voice_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||     /* AIN Intl */
              !strncmp(voice_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {    /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */

        iCategories |= CAT_IDD;
        switch ( Parse_Country (voice_event.to_number, voice_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                glb_ErrCtr++;
                return FAILURE;
        }
    }
    else if ( !cIsIodc && *voice_event.to_number == '0' ) {

        iCategories |= CAT_LOCAL;
        /* Area Code Called (within Thailand) */
        switch ( Parse_Area(voice_event.to_number, voice_event.area_code) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Area| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                break;
        }
    }

    if ( !strncmp(voice_event.to_number, LDDACC1_CODE, LDDACC1_LEN) ||      /* LDD Calls C0xxxxxxx */
         !strncmp(voice_event.to_number, LDDACC2_CODE, LDDACC2_LEN) ||      /* LDD Calls #0xxxxxxx */
         !strncmp(voice_event.to_number, "1900", 4) ||
         !strncmp(voice_event.to_number, "900909", 6) ||
         !strncmp(voice_event.to_number, "B909", 4) ||
         !strncmp(voice_event.to_number, "*909", 4) ) {
        iCategories |= CAT_PREMIUM;
    }
    else if ( !strncmp(voice_event.to_number, "900", 3) ||      /* IVR Service */
              !strncmp(voice_event.to_number, "*", 1) ||        /* IVR Service */
              !strncmp(voice_event.to_number, "B", 1) ) {       /* IVR Service */
        iCategories |= CAT_VAS|CAT_LOCAL;
    }

    strcpy(banding_model_id, "1");
    strcpy(event_class_id, "16");
    strcpy(rating_tariff_id, "1");
    if ( iCategories & CAT_IDD ) {
        strcpy(rating_tariff_id, "284");
    }

    if ( !strncmp(pbuf_rdc[RDC_CALL_FWD], "1", 1) ) {
        iFeature = FEAT_FORWARD;
        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);
        strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);
        strcpy(event_class_id, "12");
    }
    if ( strncmp(pbuf_rdc[RDC_CALL_WAIT], "1", 1) == 0 ) {
        iFeature = FEAT_WAIT;
        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);
    }
    if ( strncmp(pbuf_rdc[RDC_CALL_HOLD], "1", 1) == 0 ) {
        iFeature = FEAT_HOLD;
        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);
    }
    if ( strncmp(pbuf_rdc[RDC_CALL_CONF], "1", 1) == 0 ) {
        iFeature = FEAT_CONFERENCE;
        strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);
    }

    strcpy(voice_event.partition_id, AWN_PARTITION);   /* Postpaid Partition */
    strncpy(glb_OriginalBno, pbuf_rdc[RDC_REAL_B], 100);
    strcpy(voice_event.remarks, "DTAC Roaming");

    strcpy(voice_event.cell, "00000");
    strcpy(voice_event.cell_set, pbuf_rdc[RDC_CELL_ID]);
    strcpy(voice_event.cell_area, "DT001");
    sprintf(szMap_Cell_Ida, "D%s", pbuf_rdc[RDC_CELL_ID]);


/* -------------------------------------------- */
/* ----- Rating (Charge calculation) ---------- */
/* -------------------------------------------- */
    if ( !strncmp(voice_event.to_number, "000", 3) ) { /* AIS Extension Call */
        Rate_Pm = 0.0;          /* No Charge */
        Charge = 0.0;
    }
    else if ( cIsIodc ) {       /* Operator Assisted */
        Rate_Pm = 0.0;
        Charge = 0.0;
    }
    else if ( !strncmp(voice_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
              !strncmp(voice_event.to_number, EPHACC_CODE, EPHACC_LEN) ) {

        /* CAT International call */
        if ( Get_CostcodeBno(pbuf_rdc[RDC_CALLED_B_NO], costcode) != SUCCESS ) {
            // cost code as got from the mapping table ELSE
            // cost code as first 10 digits Bno
            strncpy(costcode, voice_event.to_number, 10);
        }
        strcpy(charge_segment_id, "37");

        if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) {     /* FAILURE */
            fputs(raw_input, glb_RCdrfp);    /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTCODE| null cost_band_id of banding_model_id(%s) costcode(%s)\n", glb_Eindex, banding_model_id, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }

        if ( Parse_RatingElement4(rating_tariff_id, cost_band_id, event_class_id, charge_segment_id, fix_charge_mny, charge_rate, unit_duration)    ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s) charge_segment_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id, charge_segment_id);
            fputs(raw_input, glb_RCdrfp); /* reject the record */
            glb_ErrCtr++;
            return FAILURE;
        }
        else {
            /* Get Rate in Baht Unit */
            if ( *charge_rate )
                Rate_Pm = (double)atol(charge_rate) / 100000.0;
            else
                Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

            Charge = (double)Calc_IntlCharge(Duration, Rate_Pm);
            Charge = (double)Charge * 100;     /* Convert to Satang */
        }
    }
    else if ( !strncmp(voice_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
              !strncmp(voice_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ) {

        /* TOT International call Except 002 */
        if ( Get_CostcodeBno(pbuf_rdc[RDC_CALLED_B_NO], costcode) != SUCCESS ) {
            // cost code as got from the mapping table ELSE
            // cost code as first 10 digits Bno
            strncpy(costcode, voice_event.to_number, 10);
        }
        if ( Lookup_Costcode(banding_model_id, costcode, costgroup_id1, cost_band_id, costcode_name) ) {
            fputs(raw_input, glb_RCdrfp); /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !*costgroup_id1 && !*cost_band_id ) {  /* Both Cost_Group_Id and Cost_Band_Id are NULL */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_Blank_After_COSTCODE| costgroup_id1 and cost_band_id are null of banding_model_id(%s) costcode(%s)\n",
                    glb_Eindex, banding_model_id, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        else if ( *costgroup_id1 ) {    /* Cost_Group_Id is Not NULL */
            strcpy(costcode, szTmp);
            if ( Get_RmCostGroupId(banding_model_id, costcode, costgroup_id2) ) {
                fputs(raw_input, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| cell_idb(%s)\n", glb_Eindex, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*costgroup_id2 ) {    /* Cost_Group_Id1 is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_ID2_Blank_After_COSTCODE| costgroup_id2 is null of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( Get_XfCostBandId(banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
                fputs(raw_input, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| costgroup_id1(%s) costgroup_id2(%s)\n",
                        glb_Eindex, costgroup_id1, costgroup_id2);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTGROUP| null cost_band_id of banding_model_id(%s) costgroup_id1(%s) costgroup_id2(%s)\n",
                    glb_Eindex, banding_model_id, costgroup_id1, costgroup_id2);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                fputs(raw_input, glb_RCdrfp); /* reject the record */
                glb_ErrCtr++;
                return FAILURE;
            }
            else {
                /* Get Rate in Baht Unit */
                if ( *charge_rate )
                    Rate_Pm = (double)atol(charge_rate) / 100000.0;
                else
                    Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

                Charge = (double)Calc_IntlCharge (Duration, Rate_Pm);
                Charge = (double)Charge * 100;     /* Convert to Satang */
            }
        }
        else {  /* Cost_Group_Id is NULL */
            if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                fputs(raw_input, glb_RCdrfp);    /* reject the record */
                glb_ErrCtr++;
                return FAILURE;
            }
            else {
                /* Get Rate in Baht Unit */
                if ( *charge_rate )
                    Rate_Pm = (double)atol(charge_rate) / 100000.0;
                else
                    Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

                Charge = (double)Calc_IntlCharge(Duration, Rate_Pm);
                Charge = (double)Charge * 100;     /* Convert to Satang */
            }
        }
    }
    else if ( !strncmp(voice_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||     /* AIN 3rd Product Intl */
              !strncmp(voice_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||     /* AIN 2nd Product Intl */
              !strncmp(voice_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||     /* AIN Intl */
              !strncmp(voice_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {

        strncpy(costcode, voice_event.to_number, 10);
        strcpy(charge_segment_id, "37");

        if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) {     /* FAILURE */
            fputs(raw_input, glb_RCdrfp); /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTCODE| null cost_band_id of banding_model_id(%s) costcode(%s)\n", glb_Eindex, banding_model_id, costcode);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( Parse_RatingElement4(rating_tariff_id, cost_band_id, event_class_id, charge_segment_id, fix_charge_mny, charge_rate, unit_duration) ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s) charge_segment_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id, charge_segment_id);
            fputs(raw_input, glb_RCdrfp);    /* reject the record */
            glb_ErrCtr++;
            return FAILURE;
        }
        else {
            /* Get Rate in Baht Unit */
            Rate_Pm = ((double)atol(charge_rate) / 100000.0) / (atol(unit_duration) / 100.0) * 60.0;
            Charge = (double)Calc_AinIntlCharge(Duration, Rate_Pm);
            Charge = (double)Charge * 100;     /* Convert to Satang */
        }
    }
    else if ( !strncmp(voice_event.to_number, "1900", 4) ||    /* Audio Text */
              !strncmp(voice_event.to_number, "900", 3) ||     /* IVR Service */
              !strncmp(voice_event.to_number, "*", 1) ||       /* IVR Service */
              !strncmp(voice_event.to_number, "B", 1) ) {      /* IVR Service */

        if ( !strncmp(voice_event.to_number, "1900", 4) ) {     /* Audio Text */

            strcpy(costcode, "1900");
            strncpy(costcode+4, voice_event.to_number+4, 10);
            if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) { /* FAILURE */
                fputs(raw_input, glb_RCdrfp); /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
            if ( !*cost_band_id ) { /* Cost_Band_Id is NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTCODE| null cost_band_id of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, costcode);
                glb_ErrCtr++;
                return FAILURE;
            }
        }
        else {

            strcpy(costcode, voice_event.to_number);

            if ( Get_RmCostBandId2(banding_model_id, costcode, cost_band_id, voice_event.remarks) ) {  /* FAILURE */

                memset(szTmp, 0x00, sizeof(szTmp));
                if ( !strncmp(voice_event.to_number, "900", 3) ) {  /* IVR Service */
                    /* strncpy(szTmp, voice_event.to_number+3, 4); */
                    strcpy(szTmp, voice_event.to_number+3);
                }
                else {  /* Bno started with '*' or 'B' */
                    /* strncpy(szTmp, voice_event.to_number+1, 4); */
                    strcpy(szTmp, voice_event.to_number+1);
                }

                for ( i=0; i<3; i++ ) {
                    strcpy(costcode, ivracc_tab[i]);
                    strcat(costcode, szTmp);
                    memset(voice_event.remarks, 0x00, sizeof(voice_event.remarks));
                    if ( Get_RmCostBandId2(banding_model_id, costcode, cost_band_id, voice_event.remarks) ) {  /* FAILURE */
                        continue;
                    }
                    if ( !*cost_band_id ) {     /* Cost_Band_Id is NULL */
                        continue;
                    }
                    break;
                }
                if ( i >= 3 ) {
                    fputs(raw_input, glb_RCdrfp);    /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, voice_event.to_number);
                    glb_ErrCtr++;
                    return FAILURE;
                }
            }

        }
        if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n", glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
            fputs(raw_input, glb_RCdrfp); /* reject the record */
            glb_ErrCtr++;
            return FAILURE;
        }
        else {
            /* Get Rate in Baht Unit */
            if ( *charge_rate )
                Rate_Pm = (double)atol(charge_rate) / 100000.0;
            else
                Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;

            if ( !strncmp(voice_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN) ) {
                /* TOT Intl' 002 */
                Charge = (double)Calc_IntlCharge(Duration, Rate_Pm);
                Charge = (double)Charge * 100;     /* Convert to Satang */
            }
            else {
                /*
                ** Changed Voice Charge Concept by don't use duration
                ** for calculate in case that use fix_charge_mny
                */
                if ( *charge_rate ) {
                    Charge = (double)Calc_NatlCharge(Duration, Rate_Pm);
                    Charge = (double)Charge * 100;     /* Convert to Satang */
                }
                else {
                    Charge = (double)Rate_Pm * 100;    /* Convert to Satang */
                }
            }
        }
    }
    else {  /* Normal Call */

        if ( *pbuf_rdc[RDC_RN_CODE] ) {
            strcpy(szMap_Cell_Idb, pbuf_rdc[RDC_RN_CODE]);
        }
        else {
            strcpy(szMap_Cell_Idb, "68051");
        }

        memset(costcode_name, 0x00, sizeof(costcode_name));
        /* check if costgroup_id1 exist, otherwise cost_band_id will be used as mapping field for rating  */
        if ( Lookup_Costcode(banding_model_id, szMap_Cell_Idb, costgroup_id1, cost_band_id, costcode_name) ) {  /* FAILURE */
            fputs(raw_input, glb_RCdrfp);    /* reject the record */
            fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s)\n", glb_Eindex, szMap_Cell_Idb);
            glb_ErrCtr++;
            return FAILURE;
        }
        if ( !strncmp(costcode_name, "AIS", 3) || !strncmp(costcode_name, "AWN", 3) ) {
            strcpy(szChargeNet, costcode_name);
        }
        else {
            strcpy(szChargeNet, "OTH");
        }
#if 0
        if ( !(iCategories & CAT_ONNET) ) { /* if CAT_ONNET is not earlier assigned, set to OFFNET. Added by N.Thanakorn on 26-Aug-2014 */
            iCategories |= CAT_OFFNET;
        }
#endif
        if ( strcmp(voice_event.area_code, "") ) { /* Area Code not Blank */
            strcpy(voice_event.oper_name, "FIX");
        }
        else {
            strncpy(voice_event.oper_name, costcode_name, SIZE_OPER);
        }

        /* --- Rating Section --- */
        if ( glb_UseFixRateFlag == 'Y' &&
             Get_FixRate(szChargeNet, charge_rate) == SUCCESS &&
             !(iCategories & CAT_MARITIME) ) {
            /* Get Rate in Satang Unit */
            /*
            ** Changed Voice Charge Concept to fix rate and calculate with duration
            */
            Rate_Pm = (double)atol(charge_rate) / 100.0;
            Charge = (double)Calc_NatlCharge (Duration, Rate_Pm);
            Charge = (double)Charge * 100;     /* Convert to Satang */
        }
        else {
            if ( !*costgroup_id1 && !*cost_band_id ) {  /* Both Cost_Group_Id and Cost_Band_Id are NULL */
                fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_Blank_After_COSTCODE| costgroup_id1 and cost_band_id are null of banding_model_id(%s) costcode(%s)\n",
                        glb_Eindex, banding_model_id, szMap_Cell_Idb);
                glb_ErrCtr++;
                return FAILURE;
            }
            else if ( *costgroup_id1 ) {    /* Cost_Group_Id is Not NULL */
                if ( Get_RmCostGroupId(banding_model_id, szMap_Cell_Ida, costgroup_id2) ) {
                    fputs(raw_input, glb_RCdrfp);    /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDA| cell_ida(%s)\n", glb_Eindex, szMap_Cell_Ida);
                    glb_ErrCtr++;
                    return FAILURE;
                }
                if ( !*costgroup_id2 ) {    /* Cost_Group_Id1 is NULL */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group_ID2_Blank_After_COSTCODE| costgroup_id2 is null of banding_model_id(%s) costcode(%s)\n",
                            glb_Eindex, banding_model_id, szMap_Cell_Ida);
                    glb_ErrCtr++;
                    return FAILURE;
                }
                if ( Get_XfCostBandId(banding_model_id, costgroup_id1, costgroup_id2, cost_band_id) ) {
                    fputs(raw_input, glb_RCdrfp); /* reject the record */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Group| costgroup_id1(%s) costgroup_id2(%s)\n",
                        glb_Eindex, costgroup_id1, costgroup_id2);
                    glb_ErrCtr++;
                    return FAILURE;
                }
                if ( !*cost_band_id ) {   /* Cost_Band_Id is NULL */
                    fprintf(glb_Errfp, "[DET] %s|Rating|Cost_Band_Blank_After_COSTGROUP| null cost_band_id of banding_model_id(%s) costgroup_id1(%s) costgroup_id2(%s)\n",
                            glb_Eindex, banding_model_id, costgroup_id1, costgroup_id2);
                    glb_ErrCtr++;
                    return FAILURE;
                }
            }

            /* costgroup_id1 is NULL or cost_band_id is set */
            if ( Parse_RatingElement3Avg(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
                fputs(raw_input, glb_RCdrfp);    /* reject the record */
                fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
                        glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
                glb_ErrCtr++;
                return FAILURE;
            }
            else {
                /* Get Rate in Baht Unit */
                /*
                ** Changed Voice Charge Concept by don't use duration
                ** for calculate in case that use fix_charge_mny
                */
                if ( *charge_rate ) {
                    Rate_Pm = (double)atol(charge_rate) / 100000.0;
                    Charge = (double)Calc_NatlCharge(Duration, Rate_Pm);
                    Charge = (double)Charge * 100;      /* Convert to Satang */
                }
                else {
                    Rate_Pm = (double)atol(fix_charge_mny) / 1000.0;
                    Charge = (double)Rate_Pm * 100;     /* Convert to Satang */
                }
            }
        }
    }   // End of normal voice call section

    if ( !(iCategories & CAT_MARITIME) ) {  /* if category is not maritime then further check for onelove and tollfree */
        if ( Is_OneLoveNum(voice_event.from_number, voice_event.to_number) == SUCCESS ) {  /* Added by Thanakorn on Sep-2013 */
            Charge = 0;     /* set charge = zero when call to one love number */
        }
        else if ( Is_TollFree(voice_event.to_number, szTmp) == SUCCESS ) {   /* Added by Thanakorn on Aug-2015 */
            Charge = 0;
        }
    }
/* -------------------------------------------- */
/* ----- Event Record Preparation ------------- */
/* -------------------------------------------- */
    glb_EventId = VOICE_EVENT_TYPE;
    sprintf(voice_event.event_type, "%02d", glb_EventId);
    //voice_event.service_type = ST_HOME;
    strcpy(voice_event.service_type, ST_HOME);

    // Features and Detection Parameters
    iFeature = FEAT_POSTPAID_CALL;
    iCategories |= CAT_VOICE;

    sprintf(voice_event.fee_charge, "%010.0lf", 0.0f);
    if ( iCategories & CAT_MARITIME ) {
        iCategories &= ~CAT_LOCAL;      // remove CAT_LOCAL out, so that maritime will not sum to Voice Local dimension.
        //iCategories &= ~CAT_ONNET;
        //iCategories &= ~CAT_OFFNET;
        iCategories &= ~CAT_VAS;
        iCategories &= ~CAT_PREMIUM;
        if ( iCategories & CAT_IDD ) {
            sprintf(voice_event.charge, "%010.0lf", (Charge+(25*100)));     // adds extra charge for maritime idd 25 THB
            sprintf(voice_event.fee_charge, "%010d", (25*100));
        }
    }

    if ( iCategories & CAT_VAS ) {
        iCategories |= CAT_TOTAL;
    }

    sprintf(voice_event.charge, "%010.0lf", Charge);
    sprintf(voice_event.features, "%010d", iFeature);
    strcpy(voice_event.detect_params, szDetParams);
    sprintf(voice_event.categories, "%08d", iCategories);
    strcpy(voice_event.original_bno, glb_OriginalBno);
    strcpy(voice_event.event_src, glb_EventSource);

    if ( iCategories & CAT_IDD ) {  // Added by Thanakorn
        glb_EventId = VOICE_EVENT_TYPE_IDD; // Actually it's voice event but just for categorize Priority Tube by IUM)
    }

    if ( glb_UseRatedCdr == 1 ) {
        if ( (iCategories & CAT_VOICE || iCategories & CAT_VAS) && iCategories & CAT_LOCAL ) {
            fprintf(glb_Errfp, "[DET] %s|Rating|Use_RBM|\n", glb_Eindex);
            glb_ErrCtr++;
            return FAILURE; // if RBM cdr is used, only voice local or voice vas from other cdr type is rejected.
        }
    }

    return SUCCESS;
}


int Read_RdcSms_Cdr()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Read_RdcSms_Cdr");
    _p_ = 0;
#endif
    memset(pbuf_rdcsms, 0x00, sizeof (pbuf_rdcsms));
    return (Read_Delimiter_Cdr('|', NOF_FLD_RDCSMS, pbuf_rdcsms));
}

int Rdc_To_Sms_Event ()
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Rdc_To_Sms_Event");
    _p_ = 0;
#endif
    double          Charge = 0.0;
    //unsigned int    Duration = 0;       // Duration
    //time_t          Seize_time = 0;     // Seize Time in Seconds
    double          Rate_Pm = 0.0;      // Rate Per Minute

    int iCategories = 0;
    //int iFeature = 0;
    char szDetParams[SKIP_DET_STR_SIZE];

    char net_orig[SIZE_NET+1];
    char banding_model_id[2+1];
    char costcode[SIZE_COSTCODE+1];
    char costcode_name[SIZE_COSTCODE_NAME+1];
    char costgroup_id1[SIZE_COSTGROUP_ID+1];
    char costgroup_id2[SIZE_COSTGROUP_ID+1];
    char cost_band_id[SIZE_COSTBAND_ID+1];
    char rating_tariff_id[SIZE_RATING_TARIFF_ID+1];
    char event_class_id[SIZE_EVENT_CLASS_ID+1];
    char rating_catalogue_id[SIZE_RATING_CATALOGUE_ID+1];
    char fix_charge_mny[SIZE_FIXED_CHARGE+1];
    char charge_rate[SIZE_CHARGE_RATE+1];
    char actual_rec_type[SIZE_ACTUAL_REC_TYPE+1];

    char szDate[8+1];
    char szTime[6+1];

    memset(net_orig, 0x00, sizeof(net_orig));
    memset(banding_model_id, 0x00, sizeof(banding_model_id));
    memset(costcode, 0x00, sizeof(costcode));
    memset(costcode_name, 0x00, sizeof(costcode_name));
    memset(costgroup_id1, 0x00, sizeof(costgroup_id1));
    memset(costgroup_id2, 0x00, sizeof(costgroup_id2));
    memset(cost_band_id, 0x00, sizeof(cost_band_id));
    memset(rating_tariff_id, 0x00, sizeof(rating_tariff_id));
    memset(rating_catalogue_id, 0x00, sizeof(rating_catalogue_id));
    memset(fix_charge_mny, 0x00, sizeof(fix_charge_mny));
    memset(charge_rate, 0x00, sizeof(charge_rate));
    memset(actual_rec_type, 0x00, sizeof(actual_rec_type));
    memset(szDate, 0x00, sizeof(szDate));
    memset(szTime, 0x00, sizeof(szTime));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    // initialize Common Structure buffer for each CDR
    memset(&sms_buf, 0x00, sizeof (sms_buf));
    memset(&com_buf, 0x00, sizeof(com_buf));
    memset(&sms_event, 0x00, sizeof(sms_event));


    if ( *pbuf_rdcsms[RDSMS_VISITED_NW] != '6' ) {
        fprintf(glb_Ignfp, "[DET] %s|Visit_NW|NW %s\n", glb_Eindex, pbuf_rdcsms[RDSMS_VISITED_NW]);
        fputs(raw_gsm, glb_RCdrfp);     // reject the record
        glb_IgnCtr++;
        return FAILURE;
    }

    // Event Type
    glb_EventId = SMS_EVENT_TYPE;   // SMS Event Type
    sprintf(sms_event.event_type, "%02d", glb_EventId);
    strncpy(glb_OriginalBno, pbuf_rdcsms[RDSMS_REAL_B], 100);

    // Map Ano
    if ( Conv_Ano(pbuf_rdcsms[RDSMS_MOBILE_NO], sms_event.mobile_num) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
#ifdef DEBUG_ANO    // Use this for debug only
printf ("SMS ano=%-30s => %s\n", pbuf_rdcsms[RDSMS_MOBILE_NO], sms_event.mobile_num);
#endif
    if ( strlen(sms_event.mobile_num) < SIZE_PHONENO ) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, sms_event.mobile_num);
        glb_ErrCtr++;
        return FAILURE;
    }
    // From Mobile Number
    strncpy(sms_event.from_number, sms_event.mobile_num, 18);

    // To Mobile Number
    // map b_no
    if ( !strlen(pbuf_rdcsms[RDSMS_CALLED_B_NO]) ) {    // b_no blank
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }
    strcpy(sms_buf.b_no, pbuf_rdcsms[RDSMS_CALLED_B_NO]);
    Conv_Sms_Bno();
    strncpy(sms_event.to_number, com_buf.b_no, 18);
    Conv_RealBno(sms_event.to_number, sms_event.bno);   // get exact bno (without any access code)
#if 0
    // Added the following onnet/offnet by N.Thanakorn on 26-Aug-2014
    if ( strncmp(sms_event.to_number, "06", 2) == 0 ||
         strncmp(sms_event.to_number, "08", 2) == 0 ||
         strncmp(sms_event.to_number, "09", 2) == 0 ) {
        iCategories |= CAT_ONNET;
    }
#endif
#ifdef DEBUG_BNO    // Use this for debug only
printf ("SMS bno=%-30s => %s\n", pbuf_rdcsms[RDSMS_CALLED_B_NO], sms_event.to_number);
#endif

    // Introduced AIN - Added below by Kawee on 04-Jan-2007
    if ( !strncmp(sms_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||    // AIN 3rd Product Intl - Added by Kawee on 11-Nov-2009
         !strncmp(sms_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||    // AIN 2nd Product Intl - Added by Kawee on 25-Aug-2008
         !strncmp(sms_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||    // AIN Intl
         !strncmp(sms_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||    // AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013
         !strncmp(sms_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
         !strncmp(sms_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {
        fputs(raw_gsm, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Send_SMS_AIN_Number|AIN_Number %s\n", glb_Eindex, pbuf_rdcsms[RDSMS_CALLED_B_NO]);
        glb_IgnCtr++;
        return FAILURE;
    }

    strncpy(szDate, pbuf_rdcsms[RDSMS_CALL_ST_TIME], 8);
    strncpy(szTime, pbuf_rdcsms[RDSMS_CALL_ST_TIME]+8, 6);

    // Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
    if ( !IsValid_YYYYMMDD_HHMMSS(szDate, szTime) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date(%s) start_time(%s)\n", glb_Eindex, szDate, szTime);
        glb_ErrCtr++;
        return FAILURE;
    }
    // Added Check for reject CDR that older than glb_OldCdrDay - by Kawee on 29-Sep-2008
    if ( strncmp(szDate, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fputs(raw_gsm, glb_RCdrfp);
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s) older than(%ld)\n",
            glb_Eindex, pbuf_rdcsms[RDSMS_CALL_ST_TIME], glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    // Seize Time & Date
    //Seize_time = Calc_SeizeTime(szDate, szTime);
    //sprintf(sms_event.time_key, "%010ld", Seize_time);
    sprintf(sms_event.time_key, "%s%s", szDate, szTime);
    strcpy(glb_CurCDRDate, szDate);
    strcpy(glb_CurCDRTime, szTime);

    // Direction
    strcpy(sms_event.direction, OUTGOING);  // Outgoing Call

    // Country Code Called
    strcpy(sms_event.country_code, "66");   // default for Thailand

    if ( !strncmp(sms_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
         !strncmp(sms_event.to_number, EPHACC_CODE, EPHACC_LEN) ||
         !strncmp(sms_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
         !strncmp(sms_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
         !strncmp(sms_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN) ) {   // Intl' SMS
        switch ( Parse_Country(sms_event.to_number, sms_event.country_code, &Rate_Pm) ) {
            case SUCCESS:
            case PARSE_MUL_MATCH:
                break;
            case PARSE_NOT_MATCH:
            case FAILURE:
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, sms_event.to_number);
                glb_ErrCtr++;
                return FAILURE;
        }
    }

    // SMS Type
    // strcpy(sms_event.sms_type, "99");

    // CDR Categories
    if ( strncmp(pbuf_rdcsms[RDSMS_SMSC_ADDR], "3GTOT", 5) == 0 ) {
        if ( strcmp(sms_event.country_code, "66") == 0 ) {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_LOCAL;
        }
        else {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_IDD;
        }
    }
    else {
        if ( strncmp(pbuf_rdcsms[RDSMS_SMSC_ADDR], "879", 3) == 0 ) {     // Added by N.Thanakorn on 26-Jun-2014; Maritime CDR
            iCategories |= CAT_MARITIME;
            strcpy(voice_event.cell_area, DEF_CELL_AREA);
        }
        if ( strcmp(sms_event.country_code, "66") == 0 ) {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_LOCAL;
        }
        else {
            iCategories |= CAT_TOTAL|CAT_SMS|CAT_IDD;
        }
    }
#if 0
    if ( !(iCategories & CAT_ONNET) ) {     // if CAT_ONNET is not earlier assigned, set to OFFNET. Added by N.Thanakorn on 26-Aug-2014
        iCategories |= CAT_OFFNET;
    }
#endif
    if ( iCategories & CAT_TOTAL && iCategories & CAT_MARITIME ) {
        iCategories &= ~CAT_TOTAL;      // remove CAT_TOTAL out, so that maritime will not sum to Total dimension.
        iCategories &= ~CAT_LOCAL;      // remove CAT_LOCAL out, so that maritime will not sum to SMS dimension
        //iCategories &= ~CAT_ONNET;
        //iCategories &= ~CAT_OFFNET;
        iCategories &= ~CAT_IDD;
    }
    sprintf(sms_event.categories, "%08d", iCategories);

    // Detection Skip Parameters
    strcat(szDetParams, gaszFrmSkipDet[SKIP_COLLISION]);        // skip collision
    strcat(szDetParams, gaszFrmSkipDet[SKIP_VELOCITY]);         // skip velocity
    strcat(szDetParams, gaszFrmSkipDet[SKIP_DUPEVENT]);        // skip duplication check for non voice events
    strcpy(sms_event.detect_params, szDetParams);

    // Charge in Satang
    Charge = 0.0;
    strcpy(banding_model_id, "3");

    // Define costcode as cell_id_b for mapping ...
    if ( (!strncmp(sms_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
          !strncmp(sms_event.to_number, EPHACC_CODE, EPHACC_LEN) ||
          !strncmp(sms_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||
          !strncmp(sms_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||
          !strncmp(sms_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN)) &&     // Intl' SMS
          strncmp(sms_event.to_number+3, "66", 2) ) {
        strcpy(costcode, "001");    // ISMS
    }
    else if ( !strncmp(pbuf_rdcsms[RDSMS_SMSC_ADDR], "879", 3) ) {   // Added by N.Thanakorn on 26-Jun-2014; Maritime CDR
        costcode[0] = 'M';
        strncat(costcode, sms_event.to_number, 2);
        costcode[3] = 0;
    }
    // Added below by Kawee on 25-Apr-2006
    else if ( strncmp(sms_event.to_number, "080", 3) >= 0 && strncmp(sms_event.to_number, "089", 3) <= 0 ) {    // Normal Call B_no is 080xxxxxxx to 089xxxxxxx
        strncpy(costcode, sms_event.to_number, 3);
    }
    else if ( strncmp(sms_event.to_number, "090", 3) >= 0 && strncmp(sms_event.to_number, "099", 3) <= 0 ) {    // Normal Call B_no is 090xxxxxxx to 099xxxxxxx
        strncpy(costcode, sms_event.to_number, 3);
    }
    else if ( strncmp(sms_event.to_number, "01", 2) >= 0 && strncmp(sms_event.to_number, "09", 2) <= 0 ) {      // Normal Call B_no is 01xxxxxxx to 09xxxxxxx
        strncpy(costcode, sms_event.to_number, 2);
    }
    else {  // Special Call E.g. 900xxx
        strcpy(costcode, sms_event.to_number);
    }

    strcpy(event_class_id, "26");

    if ( Get_RmCostBandId(banding_model_id, costcode, cost_band_id) ) {     // FAILURE
        fputs(raw_gsm, glb_RCdrfp);
        fprintf(glb_Errfp, "[DET] %s|Rating|Cell_IDB| costcode(%s) b_no(%s)\n", glb_Eindex, costcode, sms_event.to_number);
        glb_ErrCtr++;
        return FAILURE;
    }

    strcpy(rating_tariff_id, "5");  // Net_Orig Always 'GSM' Network

    if ( Parse_RatingElement3(rating_tariff_id, cost_band_id, event_class_id, fix_charge_mny, charge_rate) ) {
        fputs(raw_gsm, glb_RCdrfp);
        fprintf(glb_Errfp, "[DET] %s|Rating|Rating_Element| rating_tariff_id(%s) cost_band_id(%s) event_class_id(%s)\n",
                glb_Eindex, rating_tariff_id, cost_band_id, event_class_id);
        glb_ErrCtr++;
        Charge = 0.0;
        return FAILURE;
    }
    else {
        Charge = atof(fix_charge_mny) / 10.0;       // Convert to Satang
    }

    sprintf(voice_event.cell, "%05s", pbuf_rdcsms[RDSMS_CALLER_CI]);
    sprintf(voice_event.cell_set, "%05s", pbuf_rdcsms[RDSMS_CALLER_LAC]);
    strcpy(voice_event.cell_area, "000");
    strncpy(voice_event.cell_area+3, pbuf_rdcsms[RDSMS_CALLER_LAC]+2, 2);

    // ----- not yet mapping fields -----
    // sms_event.service_id
    // sms_event.remarks
    // sms_event.business_code
    // sms_event.pre_disc
    // sms_event.payment_type
    // sms_event.fee_charge
    // ----- not yet mapping fields -----

    strcpy(sms_event.partition_id, AWN_PARTITION);
    sprintf(sms_event.charge, "%010.0lf", Charge);
    strcpy(sms_event.original_bno, glb_OriginalBno);
    strcpy(sms_event.event_src, glb_EventSource);

    return SUCCESS;
}

int Read_Rbm_Cdr()
{
    memset(pbuf_rbm, 0x00, sizeof(pbuf_rbm));
    return (Read_Delimiter_Cdr('|', NOF_FLD_RBM-1, pbuf_rbm));
}

int Rbm_To_Voice_Event()
{
    double       Rate_Pm = 0.0;     /* Rate Per Minute */
    double       Charge = 0.0;
    char cIsIodc;
    int iCategories = 0;
    int iFeature = 0;
    char szDetParams[SKIP_DET_STR_SIZE];
    char szDate[8+1];
    char szTime[6+1];
    char szTemp[256];

    memset(szDate, 0x00, sizeof(szDate));
    memset(szTime, 0x00, sizeof(szTime));
    memset(glb_OriginalBno, 0x00, sizeof(glb_OriginalBno));
    memset(&com_buf, 0x00, sizeof(com_buf));
    memset(&voice_event, 0x00, sizeof(voice_event));
    memset(szDetParams, 0x00, sizeof(szDetParams));

    iCategories = CAT_LOCAL;

/* -------------------------------------------- */
/* ----- Validation --------------------------- */
/* -------------------------------------------- */

    if ( strlen(pbuf_rbm[RBM_EVT_DTM]) < 14 ) { // YYYYMMDDhhmmss
        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_datetime(%s)\n", glb_Eindex, pbuf_rbm[RBM_EVT_DTM]);
        glb_ErrCtr++;
        return FAILURE;
    }
#if 0
    else {
        strncpy(szDate, pbuf_rbm[RBM_EVT_DTM],   4);
        strncat(szDate, pbuf_rbm[RBM_EVT_DTM]+5, 2);
        strncat(szDate, pbuf_rbm[RBM_EVT_DTM]+8, 2);

        strncat(szTime, pbuf_rbm[RBM_EVT_DTM]+11, 2);
        strncat(szTime, pbuf_rbm[RBM_EVT_DTM]+14, 2);
        strncat(szTime, pbuf_rbm[RBM_EVT_DTM]+17, 2);

        fprintf(glb_Errfp, "[DET] %s|Field|Date_Time| start_date(%s) start_time(%s)\n", glb_Eindex, szDate, szTime);
        glb_ErrCtr++;
        return FAILURE;
    }
#endif

    strncpy(szDate, pbuf_rbm[RBM_EVT_DTM], 8);
    strncpy(szTime, pbuf_rbm[RBM_EVT_DTM]+8, 6);
    /* Added Check for reject CDR that older than glb_OldCdrDay */
    if ( strncmp(szDate, glb_OldCdrDate, SIZE_YYYYMMDD) <= 0 ) {
        fputs(raw_input, glb_RCdrfp);    /* reject the record */
        fprintf(glb_Ignfp, "[DET] %s|Datetime|Old_Data| start_date_time(%s%s) older than(%ld)\n", glb_Eindex, szDate, szTime, glb_OldCdrDay);
        glb_OldCtr++;
        return FAILURE;
    }

    strcpy(voice_event.time_key, pbuf_rbm[RBM_EVT_DTM]);
    strcpy(glb_CurCDRDate, szDate);
    strcpy(glb_CurCDRTime, szTime);

    /* Duration in Seconds */
    if ( !Is_Number(pbuf_rbm[RBM_RL_DUR]) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|Duration| duration(%s)\n", glb_Eindex, pbuf_rbm[RBM_RL_DUR]);
        glb_ErrCtr++;
        return FAILURE;
    }

    strcpy(voice_event.duration, pbuf_rbm[RBM_RL_DUR]);
#if 0
    /* map a_no */
    if ( Conv_Ano(pbuf_rbm[RBM_EVT_SRC], com_buf.a_no) ) {
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    strncpy(voice_event.mobile_num, com_buf.a_no, 16);
    strncpy(voice_event.from_number, com_buf.a_no, 18);
#endif
    strncpy(voice_event.mobile_num, pbuf_rbm[RBM_EVT_SRC], 16);
    strncpy(voice_event.from_number, pbuf_rbm[RBM_EVT_SRC], 18);

    /* map b_no */
    if ( !strlen(pbuf_rbm[RBM_DIAL_NO]) ) { /* b_no blank */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( Conv_CommonVoice_Bno(pbuf_rbm[RBM_DIAL_NO], com_buf.b_no) ) {   /* Invalid b_no */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO| invalid b_no(%s)\n", glb_Eindex, pbuf_rbm[RBM_DIAL_NO]);
        glb_ErrCtr++;
        return FAILURE;
    }
    strcpy(voice_event.to_number, com_buf.b_no);
    Conv_RealBno(voice_event.to_number, voice_event.bno);

/* -------------------------------------------- */
/* ----- Value Assignment for Rating ---------- */
/* ----- and Record Preparation --------------- */
/* -------------------------------------------- */
    cIsIodc = Is_IodcNumber(voice_event.to_number); /* Introduced IODC Mapping Table */
    strcpy(voice_event.country_code, "66");                             /* default for Thailand */

    if ( (!strncmp(voice_event.to_number, IDDACC_CODE, IDDACC_LEN) ||
         !strncmp(voice_event.to_number, EPHACC_CODE, EPHACC_LEN)) &&   /* CAT Intl' Call */
         !cIsIodc ) {                                                   /* But not Operator Assisted Call */

        iCategories |= CAT_IDD;
        switch ( Parse_Country(voice_event.to_number, voice_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                glb_ErrCtr++;
                return FAILURE;
        }
    }
    else if ( !strncmp(voice_event.to_number, TOTIDDACC_CODE, TOTIDDACC_LEN) ||     /* 007 */
              !strncmp(voice_event.to_number, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||   /* 008 - TOT VOIP Intl' Calls */
              !strncmp(voice_event.to_number, TOTMALAYACC_CODE, TOTMALAYACC_LEN) || /* 002 - TOT VOIP Malay Intl' Calls*/
              !strncmp(voice_event.to_number, AIN3RDACC_CODE, AIN3RDACC_LEN) ||     /* AIN 3rd Product Intl */
              !strncmp(voice_event.to_number, AIN2NDACC_CODE, AIN2NDACC_LEN) ||     /* AIN 2nd Product Intl */
              !strncmp(voice_event.to_number, AINIDDACC_CODE, AINIDDACC_LEN) ||     /* AIN Intl */
              !strncmp(voice_event.to_number, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
              !strncmp(voice_event.to_number, AWNIDDACC_COD1, AINIDDACC_LEN) ) {    /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */

        iCategories |= CAT_IDD;
        switch ( Parse_Country (voice_event.to_number, voice_event.country_code, &Rate_Pm) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Country| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                glb_ErrCtr++;
                return FAILURE;
        }
    }
    else if ( !cIsIodc && *voice_event.to_number == '0' ) {

        //iCategories |= CAT_LOCAL;
        /* Area Code Called (within Thailand) */
        switch ( Parse_Area(voice_event.to_number, voice_event.area_code) ) {
            case SUCCESS :
            case PARSE_MUL_MATCH :
                break;
            case PARSE_NOT_MATCH :
                break;
            case FAILURE :
                fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Area| b_no(%s)\n", glb_Eindex, voice_event.to_number);
                break;
        }
    }

    if ( !strncmp(voice_event.to_number, LDDACC1_CODE, LDDACC1_LEN) ||      /* LDD Calls C0xxxxxxx */
         !strncmp(voice_event.to_number, LDDACC2_CODE, LDDACC2_LEN) ||      /* LDD Calls #0xxxxxxx */
         !strncmp(voice_event.to_number, "1900", 4) ||
         !strncmp(voice_event.to_number, "900909", 6) ||
         !strncmp(voice_event.to_number, "B909", 4) ||
         !strncmp(voice_event.to_number, "*909", 4) ) {
        iCategories |= CAT_PREMIUM;
    }
    else if ( !strncmp(voice_event.to_number, "900", 3) ||      /* IVR Service */
              !strncmp(voice_event.to_number, "*", 1) ||        /* IVR Service */
              !strncmp(voice_event.to_number, "B", 1) ) {       /* IVR Service */
        iCategories |= CAT_VAS; //|CAT_LOCAL;
    }

    if ( strlen(pbuf_rbm[RBM_PROV_NAME]) ) {
        memset(szTemp, 0x00, sizeof(szTemp));
        StrToUpper(pbuf_rbm[RBM_PROV_NAME], strlen(pbuf_rbm[RBM_PROV_NAME]),  szTemp);
        if ( !Get_CellAreaProv(szTemp, voice_event.cell_area) ) {
            fprintf(glb_Errfp, "[DET] %s|GeoMapp|Prov_Name| Province_Not_Found (%s) but not skip\n", glb_Eindex, szTemp);
        }
    }
    else {
        fprintf(glb_Errfp, "[DET] %s|GeoMapp|Prov_Name| Provine_Name(%s) but not skip\n", glb_Eindex, pbuf_rbm[RBM_PROV_NAME]);
    }

/* -------------------------------------------- */
/* ----- Rating (Charge calculation) ---------- */
/* -------------------------------------------- */
    Charge = atof(pbuf_rbm[RBM_EVT_COST]) / 10.0;
/* -------------------------------------------- */
/* ----- Event Record Preparation ------------- */
/* -------------------------------------------- */

    //pbuf_rbm[RBM_ADD_INF]
    memset(szTemp, 0x00, sizeof(szTemp));
    strcpy(szTemp, pbuf_rbm[RBM_ADD_INF]);
    char *pstr = NULL;
    int numfield = 7;
    char *subfield[numfield];
    int i = 0;

    // pbuf_rbm[RBM_ADD_INF] => Call_Mgnt_Flg ';' Data_Fax_Flg ';' IMEI ';' Correl_Fail_Flg ';' CallPrtyNo ';' TranslPrtyNo ';' bill_seq_in_msc
    for ( i = 0; i < numfield; i++ ) {
        if ( i == 0 ) {
            subfield[i] = Get_StrTok(szTemp, ';');
        }
        else {
            subfield[i] = Get_StrTok((char *)NULL, ';');
        }
    }
    if ( subfield[0] != NULL ) {
        switch ( *subfield[0] ) {
            case 'N':   // Normal Call
                break;
            case 'F':
                iFeature |= FEAT_FORWARD;
                break;
            case 'C':
                iFeature |= FEAT_CONFERENCE;
                break;
            case 'W':
                iFeature |= FEAT_WAIT;
                break;
            case 'H':
                iFeature |= FEAT_HOLD;
                break;
        }
    }

    strcpy(voice_event.imei, subfield[2]);
#if 0
    if ( subfield[2] != NULL ) {
        if ( strlen(subfield[2]) != 15 ) {
            fprintf(glb_Errfp, "[DET] %s|Field|Invalid_Add_Info| Imei (%s)\n", glb_Eindex, subfield[2]);
            glb_ErrCtr++;
            return FAILURE;
        }
        strcpy(voice_event.imei, subfield[2]);
    }
    else {
        fprintf(glb_Errfp, "[DET] %s|Field|Invalid_Add_Info| Add_Info (%s)\n", glb_Eindex, pbuf_rbm[RBM_ADD_INF]);
        glb_ErrCtr++;
        return FAILURE;
    }
#endif

    glb_PartId = AWN_SVC_PARTITION;
    glb_EventId = VOICE_EVENT_TYPE;
    strncpy(glb_OriginalBno, pbuf_rbm[RBM_DIAL_NO], 100);
    sprintf(voice_event.event_type, "%02d", glb_EventId);
    //voice_event.service_type = ST_HOME;
    strcpy(voice_event.service_type, ST_HOME);
    iFeature |= FEAT_POSTPAID_CALL;
    iCategories |= CAT_VOICE;

    sprintf(voice_event.fee_charge, "%010.0lf", 0.0f);
    if ( iCategories & CAT_MARITIME ) {
        //iCategories &= ~CAT_LOCAL;      // remove CAT_LOCAL out, so that maritime will not sum to Voice Local dimension.
        //iCategories &= ~CAT_ONNET;
        //iCategories &= ~CAT_OFFNET;
        iCategories &= ~CAT_VAS;
        iCategories &= ~CAT_PREMIUM;
        if ( iCategories & CAT_IDD ) {
            sprintf(voice_event.charge, "%010.0lf", (Charge+(25*100)));     // adds extra charge for maritime idd 25 THB
            sprintf(voice_event.fee_charge, "%010d", (25*100));
        }
    }
    else {
        iCategories |= CAT_TOTAL;
        sprintf(voice_event.fee_charge, "%010.0lf", atof(pbuf_rbm[RBM_PREDISC_COST]) / 10.0);
    }

    sprintf(voice_event.charge, "%010.0lf", Charge);
    sprintf(voice_event.features, "%010d", iFeature);
    strcpy(voice_event.detect_params, szDetParams);
    sprintf(voice_event.categories, "%08d", iCategories);
    strcpy(voice_event.original_bno, glb_OriginalBno);
    strcpy(voice_event.event_src, glb_EventSource);
    strcpy(voice_event.remarks, pbuf_rbm[RBM_COSTBAND_NAME]);

    if ( iCategories & CAT_IDD ) {  // Added by Thanakorn
        iCategories &= ~CAT_LOCAL;          // remove CAT_LOCAL out
        glb_EventId = VOICE_EVENT_TYPE_IDD; // Actually it's voice event but just for categorize Priority Tube by IUM)
    }

    return SUCCESS;
}


int Init_MapdStat()
{
    int Dummy=0;
    memset(glb_MapdStat, 0x00, sizeof(glb_MapdStat));

    /* Statistics for International Rate Table */
    sprintf(glb_MapdStat[IDX_IDD_TABLE].file_name, "%s/INTL_RATE.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_IDD_TABLE].load_func = Load_IntlRate;      /* function used to load */
    glb_MapdStat[IDX_IDD_TABLE].load_flag = TRUE;           /* load this table for ALL Installation */
    glb_MapdStat[IDX_IDD_TABLE].load_stat = FALSE;          /* to be loaded */
    glb_MapdStat[IDX_IDD_TABLE].pptable_head = (void **)&glb_IddHead;   /* pointer to Header pointer */

    /* Statistics for Number Port by Nature (Port 1-2-Call to GSM) Table */
    sprintf(glb_MapdStat[IDX_NPBN_TABLE].file_name, "%s/NPBN.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_NPBN_TABLE].load_func = Load_NpbnTable;    /* function used to load */
    /* load this table for AIS/DPC/12C (Postpaid/Prepaid) Installation */
    glb_MapdStat[IDX_NPBN_TABLE].load_flag = glb_AisInstFlag || glb_DpcInstFlag || glb_12cInstFlag;
    glb_MapdStat[IDX_NPBN_TABLE].load_stat = FALSE;         /* to be loaded */
    glb_MapdStat[IDX_NPBN_TABLE].pptable_head = (void **)&glb_NpbnHead; /* pointer to Header pointer */

    /* Statistics for Bill Register Table */    /* Introduced Adjacent Area - by Kawee on 18-Nov-2004 */
    sprintf(glb_MapdStat[IDX_BILLREG_TABLE].file_name, "%s/BILL_REG.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_BILLREG_TABLE].load_func = Load_BillRegTable;  /* function used to load */
    /* load this table for AIS/DPC/12C (Postpaid/Prepaid) Installation */
    glb_MapdStat[IDX_BILLREG_TABLE].load_flag = glb_AisInstFlag || glb_DpcInstFlag || glb_12cInstFlag;
    glb_MapdStat[IDX_BILLREG_TABLE].load_stat = FALSE;      /* to be loaded */
    glb_MapdStat[IDX_BILLREG_TABLE].pptable_head = (void **)&glb_BillRegHead;   /* pointer to Header pointer */

    /* Statistics for Adjacent Group Table */   /* Introduced Adjacent Area - by Kawee on 18-Nov-2004 */
    sprintf(glb_MapdStat[IDX_ADJGRP_TABLE].file_name, "%s/ADJ_GRP.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_ADJGRP_TABLE].load_func = Load_AdjGrpTable;    /* function used to load */
    /* load this table for AIS/DPC/12C (Postpaid/Prepaid) Installation */
    glb_MapdStat[IDX_ADJGRP_TABLE].load_flag = glb_AisInstFlag || glb_DpcInstFlag || glb_12cInstFlag;
    glb_MapdStat[IDX_ADJGRP_TABLE].load_stat = FALSE;       /* to be loaded */
    glb_MapdStat[IDX_ADJGRP_TABLE].pptable_head = (void **)&glb_AdjGrpHead; /* pointer to Header pointer */

    /* Statistics for Bill Area Table */        /* Introduced Adjacent Area - by Kawee on 18-Nov-2004 */
    sprintf(glb_MapdStat[IDX_BILLAREA_TABLE].file_name, "%s/BILL_AREA.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_BILLAREA_TABLE].load_func = Load_BillAreaTable;    /* function used to load */
    /* load this table for AIS/DPC/12C (Postpaid/Prepaid) Installation */
    glb_MapdStat[IDX_BILLAREA_TABLE].load_flag = glb_AisInstFlag || glb_DpcInstFlag || glb_12cInstFlag;
    glb_MapdStat[IDX_BILLAREA_TABLE].load_stat = FALSE;     /* to be loaded */
    glb_MapdStat[IDX_BILLAREA_TABLE].pptable_head = (void **)&glb_BillAreaHead; /* pointer to Header pointer */

    /* Statistics for Bearer Table */       /* Introduced CDG CDR Type - by Kawee on 02-Jun-2005 */
    sprintf(glb_MapdStat[IDX_BEARER_TABLE].file_name, "%s/BEARER.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_BEARER_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_BEARER_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_BEARER_TABLE].vl_info.iNofLoadFld = 2;
    glb_MapdStat[IDX_BEARER_TABLE].vl_info.aiLoadFldId[0] = 1;  /* Sgwid */
    glb_MapdStat[IDX_BEARER_TABLE].vl_info.aiLoadFldId[1] = 2;  /* Bearer */
    glb_MapdStat[IDX_BEARER_TABLE].load_func = Load_VariableLengthTable;    /* function used to load */
    glb_MapdStat[IDX_BEARER_TABLE].load_flag = glb_AisInstFlag || glb_DpcInstFlag;  /* load this table for AIS/DPC (Postpaid) Installation */
    glb_MapdStat[IDX_BEARER_TABLE].load_stat = FALSE;       /* to be loaded */
    glb_MapdStat[IDX_BEARER_TABLE].pptable_head = (void **)&glb_BearerHead; /* pointer to Header pointer */

    /* Statistics for Cost Code Table */        /* Introduced CDG CDR Type - by Kawee on 02-Jun-2005 */
    sprintf(glb_MapdStat[IDX_COSTCODE_TABLE].file_name, "%s/COSTCODE.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_COSTCODE_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_COSTCODE_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_COSTCODE_TABLE].vl_info.iNofLoadFld = 6;
    glb_MapdStat[IDX_COSTCODE_TABLE].vl_info.aiLoadFldId[0] = 2;    /* Banding Model Id */
    glb_MapdStat[IDX_COSTCODE_TABLE].vl_info.aiLoadFldId[1] = 3;    /* Cost Code */
    glb_MapdStat[IDX_COSTCODE_TABLE].vl_info.aiLoadFldId[2] = 7;    /* Cost Code Name */
    glb_MapdStat[IDX_COSTCODE_TABLE].vl_info.aiLoadFldId[3] = 8;    /* Cost Code Desc */    /* Add Vas_Name field for USC and CDG Event Type - by Kawee on 12-Mar-2007 */
    glb_MapdStat[IDX_COSTCODE_TABLE].vl_info.aiLoadFldId[4] = 9;    /* Cost Group Id */
    glb_MapdStat[IDX_COSTCODE_TABLE].vl_info.aiLoadFldId[5] = 10;   /* Cost Band Id */
    glb_MapdStat[IDX_COSTCODE_TABLE].load_func = Load_VariableLengthTable;          /* function used to load */
    /* load this table for AIS/DPC/12C (Postpaid/Prepaid) Installation */
    glb_MapdStat[IDX_COSTCODE_TABLE].load_flag = glb_AisInstFlag || glb_DpcInstFlag || glb_12cInstFlag;
    glb_MapdStat[IDX_COSTCODE_TABLE].load_stat = FALSE;                 /* to be loaded */
    glb_MapdStat[IDX_COSTCODE_TABLE].pptable_head = (void **)&glb_CostCodeHead;     /* pointer to Header pointer */

    /* Statistics for Rating Element Table */   /* Introduced CDG CDR Type - by Kawee on 02-Jun-2005 */
    sprintf(glb_MapdStat[IDX_RATING_ELEMENT_TABLE].file_name, "%s/RATINGELEMENT.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.iNofLoadFld = 10;
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.aiLoadFldId[0] = 2;          /* Rating Tariff Id */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.aiLoadFldId[1] = 3;          /* Cost Band Id */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.aiLoadFldId[2] = 4;          /* Event Class Id */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.aiLoadFldId[3] = 6;          /* Charge Segment Id */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.aiLoadFldId[4] = 8;          /* Rating Catalogue Id */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.aiLoadFldId[5] = 10;         /* Fixed Charge Money */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.aiLoadFldId[6] = 11;         /* Charging Rate */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.aiLoadFldId[7] = 12;         /* Unit Duration */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.aiLoadFldId[8] = 13;         /* Fixed Charge Average */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].vl_info.aiLoadFldId[9] = 14;         /* Rating Charge Average */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].load_func = Load_VariableLengthTable;        /* function used to load */
    /* load this table for AIS/DPC/12C (Postpaid/Prepaid) Installation */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].load_flag = glb_AisInstFlag || glb_DpcInstFlag || glb_12cInstFlag;
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].load_stat = FALSE;               /* to be loaded */
    glb_MapdStat[IDX_RATING_ELEMENT_TABLE].pptable_head = (void **)&glb_RatingElementHead;  /* pointer to Header pointer */

    /* Statistics for Costgroup Xref Table */       /* by Jetsada on 21-Jul-2005 */
    sprintf(glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].file_name, "%s/COSTGROUPXREF.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].vl_info.iNofLoadFld = 4;
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].vl_info.aiLoadFldId[0] = 2;          /* Banding Model Id */
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].vl_info.aiLoadFldId[1] = 3;          /* Costgroup 1 Id */
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].vl_info.aiLoadFldId[2] = 4;          /* Costgroup 2 Id */
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].vl_info.aiLoadFldId[3] = 8;          /* Cost Band Id */
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].load_func = Load_VariableLengthTable;        /* function used to load */
    /* load this table for AIS/DPC/12C (Postpaid/Prepaid) Installation */
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].load_flag = glb_AisInstFlag || glb_DpcInstFlag || glb_12cInstFlag;
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].load_stat = FALSE;               /* to be loaded */
    glb_MapdStat[IDX_COSTGROUP_XREF_TABLE].pptable_head = (void **)&glb_CostgroupXrefHead;  /* pointer to Header pointer */

    /* Statistics for Service Key Table */          /* by Jetsada on 21-Jul-2005 */
    sprintf(glb_MapdStat[IDX_SERVICE_KEY_TABLE].file_name, "%s/SERVICE_KEY.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].vl_info.iNofLoadFld = 4;
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].vl_info.aiLoadFldId[0] = 1;             /* CDR Type */
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].vl_info.aiLoadFldId[1] = 2;             /* Service Key */
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].vl_info.aiLoadFldId[2] = 3;             /* FCI */
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].vl_info.aiLoadFldId[3] = 4;             /* Service */
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].load_func = Load_VariableLengthTable;       /* function used to load */
    /* Modified by Jetsada on 21-Dec-2005 */
    /* load this table for AIS/DPC/12C (Postpaid/Prepaid) Installation */
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].load_flag = glb_AisInstFlag || glb_DpcInstFlag || glb_12cInstFlag;
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].load_stat = FALSE;                  /* to be loaded */
    glb_MapdStat[IDX_SERVICE_KEY_TABLE].pptable_head = (void **)&glb_ServiceKeyHead;    /* pointer to Header pointer */

    /* Statistics for PPS Desc Table */         /* by Jetsada on 21-Jul-2005 */
    sprintf(glb_MapdStat[IDX_PPS_DESC_TABLE].file_name, "%s/PPS_DESC.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_PPS_DESC_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_PPS_DESC_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_PPS_DESC_TABLE].vl_info.iNofLoadFld = 4;
    glb_MapdStat[IDX_PPS_DESC_TABLE].vl_info.aiLoadFldId[0] = 1;                /* PPS Description */
    glb_MapdStat[IDX_PPS_DESC_TABLE].vl_info.aiLoadFldId[1] = 2;                /* Authentication Result */
    glb_MapdStat[IDX_PPS_DESC_TABLE].vl_info.aiLoadFldId[2] = 3;                /* Service Type */
    glb_MapdStat[IDX_PPS_DESC_TABLE].vl_info.aiLoadFldId[3] = 4;                /* SMS / Delivery Report */
    glb_MapdStat[IDX_PPS_DESC_TABLE].load_func = Load_VariableLengthTable;          /* function used to load */
    glb_MapdStat[IDX_PPS_DESC_TABLE].load_flag = glb_AisInstFlag;               /* for AIS Installation only */
    glb_MapdStat[IDX_PPS_DESC_TABLE].load_stat = FALSE;                 /* to be loaded */
    glb_MapdStat[IDX_PPS_DESC_TABLE].pptable_head = (void **)&glb_PpsDescHead;      /* pointer to Header pointer */

    /* Statistics for AIN Cost Code Table */        /* Introduced AIN CDR Type - by Kawee on 29-Jan-2007 */
    sprintf(glb_MapdStat[IDX_AIN_COSTCODE_TABLE].file_name, "%s/AIN_COST_CODE.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].vl_info.iNofLoadFld = 4;
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].vl_info.aiLoadFldId[0] = 2;            /* Cost Code Mapping */
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].vl_info.aiLoadFldId[1] = 29;           /* Destination Code */
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].vl_info.aiLoadFldId[2] = 33;           /* CDR Type */
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].vl_info.aiLoadFldId[3] = 14;           /* Cost Band Id */
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].load_func = Load_VariableLengthTable;      /* function used to load */
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].load_flag = glb_AinInstFlag;           /* for AIN Installation only */
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].load_stat = FALSE;                 /* to be loaded */
    glb_MapdStat[IDX_AIN_COSTCODE_TABLE].pptable_head = (void **)&glb_AinCostCodeHead;  /* pointer to Header pointer */

    /* Statistics for AIN Operator Carrier Master Table */      /* Introduced AIN CDR Type - by Kawee on 29-Jan-2007 */
    sprintf(glb_MapdStat[IDX_AIN_OPER_CARRIER_MASTER_TABLE].file_name, "%s/AIN_OPER_CARRIER_MASTER.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_AIN_OPER_CARRIER_MASTER_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_AIN_OPER_CARRIER_MASTER_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_AIN_OPER_CARRIER_MASTER_TABLE].vl_info.iNofLoadFld = 2;
    glb_MapdStat[IDX_AIN_OPER_CARRIER_MASTER_TABLE].vl_info.aiLoadFldId[0] = 2; /* Oper Carrier Id */
    glb_MapdStat[IDX_AIN_OPER_CARRIER_MASTER_TABLE].vl_info.aiLoadFldId[1] = 6; /* single_bill_flag */
    glb_MapdStat[IDX_AIN_OPER_CARRIER_MASTER_TABLE].load_func = Load_VariableLengthTable;   /* function used to load */
    glb_MapdStat[IDX_AIN_OPER_CARRIER_MASTER_TABLE].load_flag = glb_AinInstFlag;    /* load this table for AIN Installation */
    glb_MapdStat[IDX_AIN_OPER_CARRIER_MASTER_TABLE].load_stat = FALSE;      /* to be loaded */
    glb_MapdStat[IDX_AIN_OPER_CARRIER_MASTER_TABLE].pptable_head = (void **)&glb_AinOperCarrierMasterHead;  /* pointer to Header pointer */

    /* Statistics for AIN Rating Tariff Element Table */        /* Introduced AIN CDR Type - by Kawee on 29-Jan-2007 */
    sprintf(glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].file_name, "%s/AIN_RATING_TARIFF_ELEMENT.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.iNofLoadFld = 9;
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.aiLoadFldId[0] = 2;   /* Rating Tariff Id */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.aiLoadFldId[1] = 3;   /* Cost Band Id */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.aiLoadFldId[2] = 4;   /* Modifier Class Id */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.aiLoadFldId[3] = 5;   /* Time Plan Id, Add by Thanakorn on 05-Mar-2010 */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.aiLoadFldId[4] = 6;   /* Time Rate Id, Add by Thanakorn on 05-Mar-2010 */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.aiLoadFldId[5] = 7;   /* Step Group, Add by Thanakorn on 05-Mar-2010 */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.aiLoadFldId[6] = 8;   /* Step Sequence, Add by Thanakorn on 05-Mar-2010 */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.aiLoadFldId[7] = 18;  /* Subscriber Type, Add by Thanakorn on 05-Mar-2010 */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].vl_info.aiLoadFldId[8] = 10;  /* Charge Rate */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].load_func = Load_VariableLengthTable; /* function used to load */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].load_flag = glb_AinInstFlag;  /* load this table for AIN Installation */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].load_stat = FALSE;        /* to be loaded */
    glb_MapdStat[IDX_AIN_RATING_TARIFF_ELEMENT_TABLE].pptable_head = (void **)&glb_AinRatingTariffElementHead;  /* pointer to Header pointer */

    /* Statistics for AIN Route Master Table */     /* Introduced AIN CDR Type - by Kawee on 29-Jan-2007 */
    sprintf(glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].file_name, "%s/AIN_ROUTE_MASTER.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].vl_info.iNofLoadFld = 4;
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].vl_info.aiLoadFldId[0] = 2;    /* Route Id */
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].vl_info.aiLoadFldId[1] = 4;    /* Oper Carrier Id */
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].vl_info.aiLoadFldId[2] = 5;    /* Cost Code Mapping */
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].vl_info.aiLoadFldId[3] = 11;   /* MTX ID */
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].load_func = Load_VariableLengthTable;  /* function used to load */
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].load_flag = glb_AinInstFlag;   /* load this table for AIN Installation */
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].load_stat = FALSE;     /* to be loaded */
    glb_MapdStat[IDX_AIN_ROUTE_MASTER_TABLE].pptable_head = (void **)&glb_AinRouteMasterHead;   /* pointer to Header pointer */

    /* Statistics for AIN Subscriber Type Master Table */       /* Introduced AIN CDR Type - by Kawee on 29-Jan-2007 */
    sprintf(glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].file_name, "%s/AIN_SUBSCRIBERTYPE_MASTER.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].vl_info.iNofLoadFld = 3;
    glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].vl_info.aiLoadFldId[0] = 6;  /* Subscriber Carrier */
    glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].vl_info.aiLoadFldId[1] = 2;  /* Subscriber Prefix */
    glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].vl_info.aiLoadFldId[2] = 3;  /* Subscriber Type */
    glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].load_func = Load_VariableLengthTable;    /* function used to load */
    glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].load_flag = glb_AinInstFlag; /* load this table for AIN Installation */
    glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].load_stat = FALSE;       /* to be loaded */
    glb_MapdStat[IDX_AIN_SUBTYPE_MASTER_TABLE].pptable_head = (void **)&glb_AinSubTypeHead; /* pointer to Header pointer */

    /* Statistics for AIN E1 Mapping Table */
    sprintf(glb_MapdStat[IDX_AIN_E1_MAPPING_TABLE].file_name, "%s/AIN_E1_MAPPING.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_AIN_E1_MAPPING_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_AIN_E1_MAPPING_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_AIN_E1_MAPPING_TABLE].vl_info.iNofLoadFld = 2;
    glb_MapdStat[IDX_AIN_E1_MAPPING_TABLE].vl_info.aiLoadFldId[0] = 2;  /* Source Name */
    glb_MapdStat[IDX_AIN_E1_MAPPING_TABLE].vl_info.aiLoadFldId[1] = 3;  /* Target Name */
    glb_MapdStat[IDX_AIN_E1_MAPPING_TABLE].load_func = Load_VariableLengthTable;    /* function used to load */
    glb_MapdStat[IDX_AIN_E1_MAPPING_TABLE].load_flag = glb_AinInstFlag; /* load this table for AIN Installation */
    glb_MapdStat[IDX_AIN_E1_MAPPING_TABLE].load_stat = FALSE;       /* to be loaded */
    glb_MapdStat[IDX_AIN_E1_MAPPING_TABLE].pptable_head = (void **)&glb_AinE1MappingHead;   /* pointer to Header pointer */

    /* Statistics for AIN Basic Time Rate Table */
    sprintf(glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].file_name, "%s/AIN_BASIC_TIME_RATE.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].vl_info.iNofLoadFld = 7;
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].vl_info.aiLoadFldId[0] = 8;     /* Start Day */
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].vl_info.aiLoadFldId[1] = 2;     /* Time Plan ID */
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].vl_info.aiLoadFldId[2] = 6;     /* Start Date */
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].vl_info.aiLoadFldId[3] = 7;     /* End Date */
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].vl_info.aiLoadFldId[4] = 9;     /* Start Time */
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].vl_info.aiLoadFldId[5] = 10;    /* End Time */
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].vl_info.aiLoadFldId[6] = 4;     /* Time Rate ID */
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].load_func = Load_VariableLengthTable;   /* function used to load */
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].load_flag = glb_AinInstFlag;    /* load this table for AIN Installation */
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].load_stat = FALSE;      /* to be loaded */
    glb_MapdStat[IDX_AIN_BASIC_TIME_RATE_TABLE].pptable_head = (void **)&glb_AinBasicTimeRateHead;  /* pointer to Header pointer */

    /* Statistics for WLAN PACKAGE Table */
    sprintf(glb_MapdStat[IDX_WLAN_PACKAGE_TABLE].file_name, "%s/WLAN_PACKAGE.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_WLAN_PACKAGE_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_WLAN_PACKAGE_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_WLAN_PACKAGE_TABLE].vl_info.iNofLoadFld = 1;
    glb_MapdStat[IDX_WLAN_PACKAGE_TABLE].vl_info.aiLoadFldId[0] = 1;    /* Access Point Name */
    glb_MapdStat[IDX_WLAN_PACKAGE_TABLE].load_func = Load_VariableLengthTable;  /* function used to load */
    glb_MapdStat[IDX_WLAN_PACKAGE_TABLE].load_flag = glb_AinInstFlag;   /* load this table for AIN Installation */
    glb_MapdStat[IDX_WLAN_PACKAGE_TABLE].load_stat = FALSE;         /* to be loaded */
    glb_MapdStat[IDX_WLAN_PACKAGE_TABLE].pptable_head = (void **)&glb_WlanPackageHead;  /* pointer to Header pointer */

    /* Introduced IODC Mapping Table for support International Operator Direct Connection No. - by Kawee on 04-Dec-2007 */
    /* Statistics for International Operator Direct Connection Table */
    sprintf(glb_MapdStat[IDX_IODC_TABLE].file_name, "%s/IODC.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_IODC_TABLE].vl_info.cComment = '~';
    glb_MapdStat[IDX_IODC_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_IODC_TABLE].vl_info.iNofLoadFld = 1;
    glb_MapdStat[IDX_IODC_TABLE].vl_info.aiLoadFldId[0] = 1;        /* IODC B-Number Prefix */
    glb_MapdStat[IDX_IODC_TABLE].load_func = Load_VariableLengthTable;  /* function used to load */
    glb_MapdStat[IDX_IODC_TABLE].load_flag = TRUE;              /* Always load this table */
    glb_MapdStat[IDX_IODC_TABLE].load_stat = FALSE;             /* to be loaded */
    glb_MapdStat[IDX_IODC_TABLE].pptable_head = (void **)&glb_IodcHead; /* pointer to Header pointer */

    /* Introduced IMSI Mapping Table for support NRTRDE CDR. - by Kawee on 06-Feb-2008 */
    /* Statistics for IMSI Mapping to PhoneNo Table */
    sprintf(glb_MapdStat[IDX_IMSI_TABLE].file_name, "%s/IMSI.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_IMSI_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_IMSI_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_IMSI_TABLE].vl_info.iNofLoadFld = 2;
    glb_MapdStat[IDX_IMSI_TABLE].vl_info.aiLoadFldId[0] = 1;        /* IMSI */
    glb_MapdStat[IDX_IMSI_TABLE].vl_info.aiLoadFldId[1] = 2;         /* Mobile Number */
    glb_MapdStat[IDX_IMSI_TABLE].load_func = Load_VariableLengthTable;  /* function used to load */
    glb_MapdStat[IDX_IMSI_TABLE].load_flag = glb_NrtInstFlag;       /* for NRTRDE Installation only */
    glb_MapdStat[IDX_IMSI_TABLE].load_stat = FALSE;             /* to be loaded */
    glb_MapdStat[IDX_IMSI_TABLE].pptable_head = (void **)&glb_ImsiHead; /* pointer to Header pointer */

    /* Introduced IMSI VSO Mapping Table for support VSO Project. - by Kawee on 15-Aug-2008 */
    /* Statistics for IMSI VSO Mapping Table */
    sprintf(glb_MapdStat[IDX_IMSI_VSO_TABLE].file_name, "%s/IMSI_VSO.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_IMSI_VSO_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_IMSI_VSO_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_IMSI_VSO_TABLE].vl_info.iNofLoadFld = 1;
    glb_MapdStat[IDX_IMSI_VSO_TABLE].vl_info.aiLoadFldId[0] = 1;        /* IMSI Prefix */
    glb_MapdStat[IDX_IMSI_VSO_TABLE].load_func = Load_VariableLengthTable;  /* function used to load */
    glb_MapdStat[IDX_IMSI_VSO_TABLE].load_flag = TRUE;          /* Always load this table */
    glb_MapdStat[IDX_IMSI_VSO_TABLE].load_stat = FALSE;         /* to be loaded */
    glb_MapdStat[IDX_IMSI_VSO_TABLE].pptable_head = (void **)&glb_ImsiVsoHead;  /* pointer to Header pointer */

    /* Introduced FIX_RATE Mapping Table for support Fixed Rate Charge calculation. - by Kawee on 19-Sep-2008 */
    /* Statistics for FIX RATE Mapping Table */
    sprintf(glb_MapdStat[IDX_FIX_RATE_TABLE].file_name, "%s/FIX_RATE.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_FIX_RATE_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_FIX_RATE_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_FIX_RATE_TABLE].vl_info.iNofLoadFld = 2;
    glb_MapdStat[IDX_FIX_RATE_TABLE].vl_info.aiLoadFldId[0] = 1;        /* NETWORK */
    glb_MapdStat[IDX_FIX_RATE_TABLE].vl_info.aiLoadFldId[1] = 2;        /* Charge Rate in Satang */
    glb_MapdStat[IDX_FIX_RATE_TABLE].load_func = Load_VariableLengthTable;  /* function used to load */
    glb_MapdStat[IDX_FIX_RATE_TABLE].load_flag = TRUE;          /* Always load this table */
    glb_MapdStat[IDX_FIX_RATE_TABLE].load_stat = FALSE;         /* to be loaded */
    glb_MapdStat[IDX_FIX_RATE_TABLE].pptable_head = (void **)&glb_FixRateHead;  /* pointer to Header pointer */

    /* Introduced REJ_ORIG_ADDR Mapping Table for support Reject Originate Address  calculation. - by Wiraphot on 07-Jan-2009 */
    /* Statistics for REJ ORIG ADDR Mapping Table */
    sprintf(glb_MapdStat[IDX_REJ_ORIG_ADDR_TABLE].file_name, "%s/REJ_ORIG_ADDR.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_REJ_ORIG_ADDR_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_REJ_ORIG_ADDR_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_REJ_ORIG_ADDR_TABLE].vl_info.iNofLoadFld = 1;
    glb_MapdStat[IDX_REJ_ORIG_ADDR_TABLE].vl_info.aiLoadFldId[0] = 1;       /* Mobile number */
    glb_MapdStat[IDX_REJ_ORIG_ADDR_TABLE].load_func = Load_VariableLengthTable; /* function used to load */
    glb_MapdStat[IDX_REJ_ORIG_ADDR_TABLE].load_flag = TRUE;         /* Always load this table */
    glb_MapdStat[IDX_REJ_ORIG_ADDR_TABLE].load_stat = FALSE;            /* to be loaded */
    glb_MapdStat[IDX_REJ_ORIG_ADDR_TABLE].pptable_head = (void **)&glb_RejOrigAddrHead; /* pointer to Header pointer */

    /* Added Load plmn code for mapping with cell area by Thanakorn on 26-Nov-2009 */
    //sprintf(glb_MapdStat[IDX_PLMN_CODE_TABLE].file_name, "%s/GEO_PLMN_CELLAREA.DAT", glb_MapData_Dir);
    //glb_MapdStat[IDX_PLMN_CODE_TABLE].load_func = Load_Plmn;                        /* function used to load */
    //glb_MapdStat[IDX_PLMN_CODE_TABLE].load_flag = TRUE;                             /* Always load this table */
    //glb_MapdStat[IDX_PLMN_CODE_TABLE].load_stat = FALSE;                            /* to be loaded */
    //glb_MapdStat[IDX_PLMN_CODE_TABLE].pptable_head = (void **)&glb_PlmnCodeHead;    /* pointer to Header pointer */

    /* Introduced APN Mapping Table for support Access Point Name NI calculation. - by Watthikorn on 24-May-2010 */
    /* Statistics for APN Mapping Table */
    sprintf(glb_MapdStat[IDX_APN_TABLE].file_name, "%s/APN.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_APN_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_APN_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_APN_TABLE].vl_info.iNofLoadFld = 2;
    glb_MapdStat[IDX_APN_TABLE].vl_info.aiLoadFldId[0] = 1;     /* Reoord Type */
    glb_MapdStat[IDX_APN_TABLE].vl_info.aiLoadFldId[1] = 2;     /* APN */
    glb_MapdStat[IDX_APN_TABLE].load_func = Load_VariableLengthTable;   /* function used to load */
    glb_MapdStat[IDX_APN_TABLE].load_flag = TRUE;           /* Always load this table */
    glb_MapdStat[IDX_APN_TABLE].load_stat = FALSE;          /* to be loaded */
    glb_MapdStat[IDX_APN_TABLE].pptable_head = (void **)&glb_ApnHead;   /* pointer to Header pointer */

    /* Introduced 3G/2G Service Mapping Table. Added by Thanakorn on Sep-2011 */
    /* Statistics for 3G/2G Mapping Table */
    sprintf(glb_MapdStat[IDX_3G_MAP_TABLE].file_name, "%s/3G_SERVICE_MAP.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_3G_MAP_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_3G_MAP_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_3G_MAP_TABLE].vl_info.iNofLoadFld = 6;
    glb_MapdStat[IDX_3G_MAP_TABLE].vl_info.aiLoadFldId[0] = 1;      /* Speedtype */
    glb_MapdStat[IDX_3G_MAP_TABLE].vl_info.aiLoadFldId[1] = 2;      /* Rat */
    glb_MapdStat[IDX_3G_MAP_TABLE].vl_info.aiLoadFldId[2] = 3;      /* Servpackid */
    glb_MapdStat[IDX_3G_MAP_TABLE].vl_info.aiLoadFldId[3] = 4;      /* Bearer_id */
    glb_MapdStat[IDX_3G_MAP_TABLE].vl_info.aiLoadFldId[4] = 5;      /* Rating B/KB */
    glb_MapdStat[IDX_3G_MAP_TABLE].vl_info.aiLoadFldId[5] = 6;      /* Description Name */
    glb_MapdStat[IDX_3G_MAP_TABLE].load_func = Load_VariableLengthTable;    /* function used to load */
    glb_MapdStat[IDX_3G_MAP_TABLE].load_flag = TRUE;                        /* Always load this table */
    glb_MapdStat[IDX_3G_MAP_TABLE].load_stat = FALSE;                       /* to be loaded */
    glb_MapdStat[IDX_3G_MAP_TABLE].pptable_head = (void **)&glb_3GHead;     /* pointer to Header pointer */

    /* Introduced toll free Mapping Table. Added by Thanakorn on Nov-2012 */
    /* Statistics for toll free Mapping Table */
    sprintf(glb_MapdStat[IDX_TOLL_FREE_TABLE].file_name, "%s/TOLL_FREE.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_TOLL_FREE_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_TOLL_FREE_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_TOLL_FREE_TABLE].vl_info.iNofLoadFld = 2;
    glb_MapdStat[IDX_TOLL_FREE_TABLE].vl_info.aiLoadFldId[0] = 1;      /* toll free number */
    glb_MapdStat[IDX_TOLL_FREE_TABLE].vl_info.aiLoadFldId[1] = 2;      /* toll free description */
    glb_MapdStat[IDX_TOLL_FREE_TABLE].load_func = Load_VariableLengthTable;    /* function used to load */
    glb_MapdStat[IDX_TOLL_FREE_TABLE].load_flag = TRUE;                        /* Always load this table */
    glb_MapdStat[IDX_TOLL_FREE_TABLE].load_stat = FALSE;                       /* to be loaded */
    glb_MapdStat[IDX_TOLL_FREE_TABLE].pptable_head = (void **)&glb_TollFreeHead;    /* pointer to Header pointer */


    /* Introduced One Love Mapping Table. Added by Thanakorn on Sep-2013 */
    /* Statistics for One Love Mapping Table */
    sprintf(glb_MapdStat[IDX_ONE_LOVE_TABLE].file_name, "%s/PKG_ONELOVE.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_ONE_LOVE_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_ONE_LOVE_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_ONE_LOVE_TABLE].vl_info.iNofLoadFld = 2;
    glb_MapdStat[IDX_ONE_LOVE_TABLE].vl_info.aiLoadFldId[0] = 1;                /* a_no */
    glb_MapdStat[IDX_ONE_LOVE_TABLE].vl_info.aiLoadFldId[1] = 2;                /* b_no */
    glb_MapdStat[IDX_ONE_LOVE_TABLE].load_func = Load_VariableLengthTable;      /* function used to load */
    glb_MapdStat[IDX_ONE_LOVE_TABLE].load_flag = TRUE;                          /* Always load this table */
    glb_MapdStat[IDX_ONE_LOVE_TABLE].load_stat = FALSE;                         /* to be loaded */
    glb_MapdStat[IDX_ONE_LOVE_TABLE].pptable_head = (void **)&glb_OneLoveHead;  /* pointer to Header pointer */

    /* Introduced BOS IMEI Mapping Table. Added by Thanakorn on 13-Nov-2013 */
    /* Statistics for BOS IMEI Mapping Table */
    sprintf(glb_MapdStat[IDX_BOS_IMEI_TABLE].file_name, "%s/IMEI_BACKLIST.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_BOS_IMEI_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_BOS_IMEI_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_BOS_IMEI_TABLE].vl_info.iNofLoadFld = 1;
    glb_MapdStat[IDX_BOS_IMEI_TABLE].vl_info.aiLoadFldId[0] = 1;                /* imei */
    glb_MapdStat[IDX_BOS_IMEI_TABLE].load_func = Load_VariableLengthTable;      /* function used to load */
    glb_MapdStat[IDX_BOS_IMEI_TABLE].load_flag = TRUE;                          /* load this table for AIN Installation */
    glb_MapdStat[IDX_BOS_IMEI_TABLE].load_stat = FALSE;                         /* to be loaded */
    glb_MapdStat[IDX_BOS_IMEI_TABLE].pptable_head = (void **)&glb_BosImeiHead;  /* pointer to Header pointer */

    /* Introduced Costcode Bno Mapping Table. Added by Thanakorn on 23-Apr-2014 */
    /* Statistics for Costcode Bno Mapping Table */
    sprintf(glb_MapdStat[IDX_COSTCODE_BNO_TABLE].file_name, "%s/COSTCODE_BNO.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_COSTCODE_BNO_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_COSTCODE_BNO_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_COSTCODE_BNO_TABLE].vl_info.iNofLoadFld = 2;
    glb_MapdStat[IDX_COSTCODE_BNO_TABLE].vl_info.aiLoadFldId[0] = 2;                    /* CDR Prefix B_No */
    glb_MapdStat[IDX_COSTCODE_BNO_TABLE].vl_info.aiLoadFldId[1] = 3;                    /* Costcode */
    glb_MapdStat[IDX_COSTCODE_BNO_TABLE].load_func = Load_VariableLengthTable;          /* function used to load */
    glb_MapdStat[IDX_COSTCODE_BNO_TABLE].load_flag = TRUE;                              /* Always load this table */
    glb_MapdStat[IDX_COSTCODE_BNO_TABLE].load_stat = FALSE;                             /* to be loaded */
    glb_MapdStat[IDX_COSTCODE_BNO_TABLE].pptable_head = (void **)&glb_CostcodeBNoHead;  /* pointer to Header pointer */


    sprintf(glb_MapdStat[IDX_USMAP_TABLE].file_name, "%s/USMAP.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_USMAP_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_USMAP_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_USMAP_TABLE].vl_info.iNofLoadFld = 6;
    glb_MapdStat[IDX_USMAP_TABLE].vl_info.aiLoadFldId[0] = 3;       // service_id
    glb_MapdStat[IDX_USMAP_TABLE].vl_info.aiLoadFldId[1] = 4;       // category_id
    glb_MapdStat[IDX_USMAP_TABLE].vl_info.aiLoadFldId[2] = 5;       // charging_cp_id
    glb_MapdStat[IDX_USMAP_TABLE].vl_info.aiLoadFldId[3] = 15;      // cct
    glb_MapdStat[IDX_USMAP_TABLE].vl_info.aiLoadFldId[4] = 32;      // company_name
    glb_MapdStat[IDX_USMAP_TABLE].vl_info.aiLoadFldId[5] = 35;      // service_name
    glb_MapdStat[IDX_USMAP_TABLE].load_func = Load_VariableLengthTable;     // function used to load
    glb_MapdStat[IDX_USMAP_TABLE].load_flag = TRUE;                         // Always load this table
    glb_MapdStat[IDX_USMAP_TABLE].load_stat = FALSE;                        // to be loaded
    glb_MapdStat[IDX_USMAP_TABLE].pptable_head = (void **)&glb_UsMapHead;   // pointer to Header pointer

    sprintf(glb_MapdStat[IDX_GEO_TABLE].file_name, "%s/CELL_GEO.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_GEO_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_GEO_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_GEO_TABLE].vl_info.iNofLoadFld = 4;
    glb_MapdStat[IDX_GEO_TABLE].vl_info.aiLoadFldId[0] = 1;     // cgi for mapping
    glb_MapdStat[IDX_GEO_TABLE].vl_info.aiLoadFldId[1] = 2;     // new cell id used by FRM
    glb_MapdStat[IDX_GEO_TABLE].vl_info.aiLoadFldId[2] = 3;     // new cell set used by FRM
    glb_MapdStat[IDX_GEO_TABLE].vl_info.aiLoadFldId[3] = 4;     // cell area
    glb_MapdStat[IDX_GEO_TABLE].load_func = Load_VariableLengthTable;   // function used to load
    glb_MapdStat[IDX_GEO_TABLE].load_flag = TRUE;                       // Always load this table
    glb_MapdStat[IDX_GEO_TABLE].load_stat = FALSE;                      // to be loaded
    glb_MapdStat[IDX_GEO_TABLE].pptable_head = (void **)&glb_GeoHead;   // pointer to Header pointer

    sprintf(glb_MapdStat[IDX_CELLAREA_TABLE].file_name, "%s/CELLAREA_GEO.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_CELLAREA_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_CELLAREA_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_CELLAREA_TABLE].vl_info.iNofLoadFld = 2;
    glb_MapdStat[IDX_CELLAREA_TABLE].vl_info.aiLoadFldId[0] = 1;     // english province name in capital letter
    glb_MapdStat[IDX_CELLAREA_TABLE].vl_info.aiLoadFldId[1] = 2;     // cell area
    glb_MapdStat[IDX_CELLAREA_TABLE].load_func = Load_VariableLengthTable;   // function used to load
    glb_MapdStat[IDX_CELLAREA_TABLE].load_flag = TRUE;                       // Always load this table
    glb_MapdStat[IDX_CELLAREA_TABLE].load_stat = FALSE;                      // to be loaded
    glb_MapdStat[IDX_CELLAREA_TABLE].pptable_head = (void **)&glb_CellAreaHead;   // pointer to Header pointer

    sprintf(glb_MapdStat[IDX_VASGROUP_TABLE].file_name, "%s/VASGROUP.DAT", glb_MapData_Dir);
    glb_MapdStat[IDX_VASGROUP_TABLE].vl_info.cComment = '#';
    glb_MapdStat[IDX_VASGROUP_TABLE].vl_info.cDelimiter = '|';
    glb_MapdStat[IDX_VASGROUP_TABLE].vl_info.iNofLoadFld = 3;
    glb_MapdStat[IDX_VASGROUP_TABLE].vl_info.aiLoadFldId[0] = 1;     // cost code type (Costcode_Desc or Costcode_Name)
    glb_MapdStat[IDX_VASGROUP_TABLE].vl_info.aiLoadFldId[1] = 2;     // Vas Group Name
    glb_MapdStat[IDX_VASGROUP_TABLE].vl_info.aiLoadFldId[2] = 3;     // Vas Group Code
    glb_MapdStat[IDX_VASGROUP_TABLE].load_func = Load_VariableLengthTable;   // function used to load
    glb_MapdStat[IDX_VASGROUP_TABLE].load_flag = TRUE;                       // Always load this table
    glb_MapdStat[IDX_VASGROUP_TABLE].load_stat = FALSE;                      // to be loaded
    glb_MapdStat[IDX_VASGROUP_TABLE].pptable_head = (void **)&glb_VasGroupHead;   // pointer to Header pointer

    /* Fill last modified time of all the Mapping Data files */
    if ( Check_MapdStat(&Dummy) ) {
        return FAILURE;
    }
    return SUCCESS;
}

int Check_MapdStat(int *Upds)
{
    int Idx = 0;

    *Upds = 0;  /* reset */
    for ( Idx = 0; Idx < NOF_MAPDFILES; Idx++ ) {   /* for all Mapping Data Table */

        /* Check only when this installation requires to load this table ? - Added by Kawee on 13-Jan-2003 */
        if ( !glb_MapdStat[Idx].load_flag ) {
            continue;   /* no need to load, continue with other tables */
        }

        /* get last modified time of this file */
        memset(&glb_fstat, 0x00, sizeof (struct stat));
        if ( stat(glb_MapdStat[Idx].file_name, &glb_fstat) ) {       /* error reading file status */
            writeLog(LOG_SYS, "cannot read %s (%s)", glb_MapdStat[Idx].file_name, strerror(errno));
            return FAILURE;
        }

        if ( glb_fstat.st_mtime > glb_MapdStat[Idx].lmod_time ) {   /* modification time not same */
            glb_MapdStat[Idx].cmod_time = glb_fstat.st_mtime;       /* save the file Time as Current Try */
            glb_MapdStat[Idx].load_stat = FALSE;                    /* (re)set status - to be loaded */
            (*Upds)++;
        }
    }

    Deb_Msg("successfully checked status of mapping data");
    return SUCCESS;
}

/*
** Name     : Load_MapdTables()
**
** Description  : Loads required Mapping Data Table from $DATADIR.
**        Calls appropriate Loading Functions to Load Mapping Table.
**
** Parameters   : char *Msg - OUTPUT - Pointer to Error Message
**
** Return Value : SUCCESS - on Successful completion
**        FAILURE - on any error.
**
*/

int Load_MapdTables()
{
    int Idx = 0;
    //int Idx2 = 0;

    for ( Idx = 0; Idx < NOF_MAPDFILES; Idx++ ) {

        /* if ( !glb_MapdStat[Idx].load_stat) {} */ /* if to be (re)loaded */ /* Changed as below by Kawee on 13-Jan-2003 */
        if ( glb_MapdStat[Idx].load_flag && !glb_MapdStat[Idx].load_stat ) {    /* if to be (re)loaded */

            /* Load data from this file into Memory */
            switch ( glb_MapdStat[Idx].load_func(Idx) ) {
            case SUCCESS :
                glb_MapdStat[Idx].lmod_time = glb_MapdStat[Idx].cmod_time;  /* save the file Time */
                glb_MapdStat[Idx].cmod_time = 0;    /* reset current try Time */
                glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
                writeLog(LOG_INF, "loaded %d recs from %s", glb_MapdStat[Idx].tot_recs, glb_MapdStat[Idx].file_name);
                break;

            /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
            case FILE_OPEN_ERROR :
                writeLog(LOG_SYS, "cannot open %s (%s)", glb_MapdStat[Idx].file_name, strerror(errno));

                if ( !glb_MapdStat[Idx].num_loads ) /* Trying to load for the First time */
                    return FAILURE;
                else        /* Sub-sequent tries - while checking for any updates */
                    break;  /* we ignore this error and continue with the already loaded codes */

            case NO_CODE_LOADED :
                writeLog(LOG_WRN, "no record loaded from %s", glb_MapdStat[Idx].file_name);
                if ( !glb_MapdStat[Idx].num_loads ) /* Trying to load for the First time */
                    return FAILURE;
                else        /* Sub-sequent tries - while checking for any updates */
                    break;  /* we ignore this error and continue with the already loaded codes */

            case LOAD_TABLE_FULL :
                writeLog(LOG_ERR, "not enough memory for %s (%d)", glb_MapdStat[Idx].file_name, errno);
                return FAILURE;
            }
        }
    }

    if ( glb_DbgFlag ) {
        for ( Idx = 0; Idx < NOF_MAPDFILES; Idx++ ) {
            writeLog(LOG_DBG, "%d -> %-45s\t%-10ld\t%-10ld\t%-5s\t%-5s\t%d\t%d\n", Idx, glb_MapdStat[Idx].file_name,
                glb_MapdStat[Idx].lmod_time, glb_MapdStat[Idx].cmod_time,
                ((glb_MapdStat[Idx].load_flag) ? "TRUE" : "FALSE"),
                ((glb_MapdStat[Idx].load_stat) ? "TRUE" : "FALSE"),
                glb_MapdStat[Idx].tot_recs, glb_MapdStat[Idx].num_loads);
        }
    }
    return SUCCESS;
}

/* Changed as below by Kawee on 22-Mar-2007 */
void Release_MapdTables()
{
    int Idx = 0;

    for ( Idx = 0; Idx < NOF_MAPDFILES; Idx++ ) {
        if ( glb_MapdStat[Idx].load_flag ) {        /* Release only if loaded - Added by Kawee on 13-Jan-2003 */
            free(*(glb_MapdStat[Idx].pptable_head));
            glb_MapdStat[Idx].tot_recs = 0;         /* Reset */
            if ( Idx == IDX_PLMN_CODE_TABLE ) {
                free(glb_PlmnPriceHead);
                free(glb_PlmnCountryHead);
            }
        }
    }
}

/*------------------------------------------------------------------------------------*/

#ifdef  REMOVE_TABLE
/*
** Name     : Load_MnetTable()
**
** Description  : Loads Mobile Network Code Records into Memory Table.
**        Opens the Mobile Network File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Mobile Network file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Mobile Network File.
**        Sorts the Memory table by Number Plan Code.
**
** Parameters   : int   Idx - INPUT - Index of Network Code Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/

int Load_MnetTable(int Idx)
{

    FILE    *fp;
    char    Input[SIZE_LOADREC+1];
    char    *pstr=NULL;
    char    Nplan[SIZE_NPA+1];
    char    Network[SIZE_NET+1];

    int iTmp = 0;
    MNET_TABLE *Temp=NULL;      /* Local Pointer to Global Mobile Network Table */

    /* open input Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while ( fgets ((char *)Input, SIZE_LOADREC, fp) != NULL ) {
        if ( *Input != '~' )    /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp )  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(MNET_TABLE) * iTmp + sizeof(MNET_TABLE);      /* 1 element extra for safety */

    /* Identify which (AIS/DPC) memory location to be Used */
    if ( Idx == IDX_MNET_TABLE )
        Temp = glb_MnetHead;
    else
        Temp = glb_DpcMnetHead;

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[Idx].num_loads )   /* First time loading */
        Temp = (MNET_TABLE *) malloc (iTmp);
    else                    /* Not First time */
        Temp = (MNET_TABLE *) realloc (Temp, iTmp);

    if ( Temp == (MNET_TABLE *)NULL )
        return LOAD_TABLE_FULL;

    /* Save the newly allocated memory Pointer */
    if ( Idx == IDX_MNET_TABLE )
        glb_MnetHead = Temp;
    else
        glb_DpcMnetHead = Temp;

    memset(Temp, 0x00, iTmp);
    glb_MapdStat[Idx].tot_recs = 0; /* Total Mobile Network Codes */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Nplan, 0x00, sizeof (Nplan));
        memset(Network, 0x00, sizeof (Network));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp) ) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL ) {

            strncpy(Nplan, pstr, SIZE_NPA);    /* Numbering Plan Code */
            Trim_Str(Nplan);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL ) {
                strncpy(Network, pstr, SIZE_NET);  /* Network */
                Trim_Str(Network);

                /* Add to Mobile Network Table */
                strcpy(Temp->nplan, Nplan);
                strcpy(Temp->network, Network);

                glb_MapdStat[Idx].tot_recs++;   /* count */
                Temp++;
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs )    /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Reset the Local Pointer to the first record */
    if ( Idx == IDX_MNET_TABLE )
        Temp = glb_MnetHead;
    else
        Temp = glb_DpcMnetHead;

    /* Sort the (AIS/DPC) Mobile Network Table by Numbering Plan Code */
    qsort((MNET_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(MNET_TABLE), Cmp_Npa);

#ifdef SHOW_LOAD
    for ( iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++ ) {
        printf ("%s %s\n",Temp->nplan, Temp->network);
    }
    Deb_Msg(glb_MsgText);
#endif
    return SUCCESS;

}

int Cmp_Npa (ptr1, ptr2)
MNET_TABLE *ptr1, *ptr2;
{
    return (memcmp(ptr1->nplan, ptr2->nplan, SIZE_NPA));   /* always SIZE_NPA chars are compared for qsort */
}

/*
** Name     : Get_Network()
**
** Description  : Mobile Net Table has different width NPA numbers after 9 digit Implementation.
**        So we need to Parse and findout the Network Code.
**        First take 3 chars (Npa) from given Number
**          Call Get_Net to get the Network Code.
**          If matched, then store the Npa and Network Code in matching statistics.
**        Repeat this until SIZE_NPA
**        If no code matched then Check if the Given Number starts with '900' then Identify as GSM else Identify as TOT.
**        If the matched Network is 'NMT' or 'GSM' and Partition is AIS Service, then
**          Reconfirm with Number Port Table - call Get_NetPort().
**
** Parameters   : char *Number - INPUT      - Pointer to the buffer contains Number to be matched.
**        char *TxnDate - INPUT     - Pointer to the buffer contains Transaction Date.
**        char *TxnTime - INPUT     - Pointer to the buffer contains Transaction Time.
**        char *Net   - OUTPUT      - Pointer to the buffer contains Matched Network.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

/* int Get_Network (char *Number, char *Net) - Changed as below by Kawee on 14-Jun-2004 */
int Get_Network (char *Number, char *Txn_Date, char *Txn_Time, char *Net)
{
    char    Tnpa[SIZE_NPA+1];
    char    Net_Orig[SIZE_NET+1];
    char    Txn_DateTime[SIZE_DATETIME+1];

    int  start = 0, end = 0, i = 0;
    int  mctr = 0;  /* number of match found */

    struct mtab {
        int nod;            /* number of digits matched */
        char    net[SIZE_NET +1];   /* Matched Network Code */
        char    npa[SIZE_CID+1];    /* Matched NPA code */
    };
    struct mtab mstat[SIZE_NPA];

    if ( *Number == '\0' ) /* Number not passed */
        return FAILURE;

    memset(mstat, 0x00, sizeof(mstat));
    memset(Tnpa, 0x00, sizeof(Tnpa));
    memset(Net_Orig, 0x00, sizeof(Net_Orig));
    memset(Txn_DateTime, 0x00, sizeof(Txn_DateTime));

    start = 3;  /* parsing starts from 3rd character, because we expect atleast 3 chars NPA to identify a Network */
    end = ((strlen(Number) < SIZE_NPA) ? strlen(Number) : SIZE_NPA); /* parsing stops after this many characters */

    /*
    **  First : take first 3 chars from Number and match with mob_network table
    **  Second: take first 3+1 chars from Number and match with mob_network table
    **     and so on...
    */

    for (i = start; i <= end; i++) {
        strncpy(Tnpa, Number, i);  /* extract i number of characters only */
        Trim_Str(Tnpa);

                /* match the extracted npa with mob_network Table and get Network */
        if ( !Get_Net (Tnpa, Net) ) { /* match found */

            /* store the matched info */
            mstat[mctr].nod = i;
            strcpy(mstat[mctr].net, Net);
            strcpy(mstat[mctr].npa, Tnpa);
            mctr++;
        }
    }

    /* now check the match statistics and take the highest match NPA */
    if ( !mctr) {    /* NPA not matched */
        /*
        ** Some times, Unidentified VAS Numbers (Is_Vasnumber) starting with 900 are identified as TOT network type.
        ** We assume, TOT don't have phone numbers starting with 900.
        ** So to protect those Unidentified VAS numbers, the following check identifies GSM.
        ** - Chamy - 11-Oct-2001
        **
        ** Also, Unidentified VAS Numbers starting with B are idenfied as TOT network type.
        ** So to protect those Unidentified VAS numbers, first char is checked if 'B' then identify as GSM.
        ** - Chamy - 10-Oct-2002
        */
        if ( !strncmp((char *)Tnpa, "900", 3) || *Tnpa == 'B')
            strcpy((char *)Net, "GSM");    /* We always identify them as GSM */
        else
            strcpy((char *)Net, "TOT");    /* we assume it is TOT */

        return SUCCESS;   /* We don't want to check in the Number Port table in this case */
    }
    else {  /* one or more npa matched locate the highest matched NPA */
        if ( mstat[mctr - 1].nod) {
            strcpy(Net, mstat[mctr - 1].net);
            strcpy(Tnpa, mstat[mctr - 1].npa);
        }
    }

    if ( glb_PartId == AISSVC_PARTITION) {
        /*
        ** Note: NMT number can be ported to GSM, PPS.  GSM number can be ported to PPS only.
        **   Can a PPS or GSM number be ported to others ?
        */
        if ( !strcmp(Net, "NMT") || !strcmp(Net, "GSM") ) {
            /* This may be a Ported Number - Reconfirm from Ported Number Table */

            if ( Get_NetPort (Number, Net))  /* no match in Number Port table */
                strcpy(Net, mstat[mctr - 1].net);  /* copy the originally matched Network */
        }
        /*
        ** Note: PPS number can be ported to GSM
        **  - Introduced Number port by Nature - added by Kawee on 14-Jun-2004
        */
        /* if ( !strcmp(Net, "PPS") ) {} - Changed as below by Kawee on 16-Jun-2004 */
        if ( (glb_AisInstFlag || glb_12cInstFlag) &&
            (!strcmp(Net, "PPS") || !strcmp(Net, "GSM")) ) {
            strcpy(Net_Orig, Net);
            strncpy(Txn_DateTime, Txn_Date, 8);
            strncat (Txn_DateTime, Txn_Time, 6);
            /* This may be a Ported Number - Reconfirm from Number Ported by Nature Table */
            if ( Get_NpbnPort (Number, Txn_DateTime, Net))   /* no match in Number Port table */
                strcpy(Net, Net_Orig);     /* copy the originally matched Network */
        }
    }
    /* For DPC there is no number port table */

    return SUCCESS;
}

/*
** Name     : Get_Net()
**
** Description  : Get Network from Mobile Network Code Table.
**        If there is Mobile Network Code Record in Memory Table then
**          Do Binary search on the Numbering Plan Table for the given Npa
**          If Matched, then copy the Network from Numbering Plan Table to the Output parameter
**
** Parameters   : char *Npa - INPUT   - Pointer to the buffer contains Npa to be matched.
**        char *Net - OUTPUT  - Pointer to the buffer contains Matched Network.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_Net (char *Npa, char *Net)
{
    MNET_TABLE *Temp = NULL;
    int     Idx = 0;

    if ( *Npa == '\0' ) /* Npa not passed */
        return FAILURE;

    if ( glb_PartId == AISSVC_PARTITION) {
        Temp = glb_MnetHead;        /* Use AIS Zone Table */
        Idx = IDX_MNET_TABLE;       /* Index of AIS Mobile Network in Memory Statistics */
    }
    else {
        Temp = glb_DpcMnetHead;     /* Use DPC Zone Table */
        Idx = IDX_DPCMNET_TABLE;    /* Index of DPC Mobile Network in Memory Statistics */
    }

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (Npa, Temp, glb_MapdStat[Idx].tot_recs, sizeof(MNET_TABLE), Cmp_GivenNpa);

    if ( Temp == (MNET_TABLE *)NULL)     /* no match found in Mobile Network Table */
        return FAILURE;
    else
        strcpy(Net, Temp->network);    /* match found - copy the Network from Mobile Network Table */

    return SUCCESS;
}

int Cmp_GivenNpa (ptr1, ptr2)
MNET_TABLE *ptr1, *ptr2;
{
    return (strcmp(ptr1->nplan, ptr2->nplan));
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_NportTable()
**
** Description  : Loads Number Port Records into Memory Table.
**        Opens the Ported Number File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Ported Number file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Ported Number File.
**        Sorts the Memory table by Ported Number.
**
** Parameters   : int   Idx - INPUT - Index of Number Port Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_NportTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];
    char    *pstr=NULL;
    char    Network[SIZE_NET+1];
    char    Nport[SIZE_PHONENO+1];

    int iTmp = 0;
    NPORT_TABLE *Temp=NULL;     /* Local Pointer to Global Number Port Table */


    /* open the input Data file */
    if ( (fp = fopen(glb_MapdStat[IDX_NPORT_TABLE].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while ( fgets ((char *)Input, SIZE_LOADREC, fp) != NULL ) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp )  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(NPORT_TABLE) * iTmp + sizeof(NPORT_TABLE);    /* 1 element extra for safety */

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[IDX_NPORT_TABLE].num_loads )   /* First time loading */
        Temp = glb_NportHead = (NPORT_TABLE *) malloc (iTmp);
    else
        Temp = glb_NportHead = (NPORT_TABLE *) realloc (glb_NportHead, iTmp);

    if ( Temp == (NPORT_TABLE *)NULL )
        return LOAD_TABLE_FULL;

    memset(glb_NportHead, 0x00, iTmp);
    glb_MapdStat[IDX_NPORT_TABLE].tot_recs = 0; /* Total Ported Numbers */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Network, 0x00, sizeof (Network));
        memset(Nport, 0x00, sizeof (Nport));

        if ( !fgets ((char *)Input, SIZE_LOADREC, fp) )   /* read one record */
            break;  /* eof */

        if ( *Input == '~' )      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL ) {

            strncpy(Network, pstr, SIZE_NET);  /* Network */
            Trim_Str(Network);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL ) {
                strncpy(Nport, pstr, SIZE_PHONENO);    /* Ported Number */
                Trim_Str(Nport);

                /* Add to Memory Number Port Table */
                strcpy(Temp->nport, Nport);
                strcpy(Temp->network, Network);

                glb_MapdStat[IDX_NPORT_TABLE].tot_recs++;   /* count */
                Temp++;
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[IDX_NPORT_TABLE].tot_recs ) /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[IDX_NPORT_TABLE].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[IDX_NPORT_TABLE].num_loads++;  /* count this loading */

    /*
    sprintf(glb_MsgText, "%d Ported Numbers loaded..", glb_MapdStat[IDX_NPORT_TABLE].tot_recs);
    Deb_Msg(glb_MsgText);
    */

    /* Sort the Number Port Table by Ported Number only */
    qsort((NPORT_TABLE *)glb_NportHead, glb_MapdStat[IDX_NPORT_TABLE].tot_recs, sizeof(NPORT_TABLE), Cmp_Pnumber);

#ifdef SHOW_LOAD
    Temp = glb_NportHead;
    for ( iTmp = 0; iTmp < glb_MapdStat[IDX_NPORT_TABLE].tot_recs; iTmp++, Temp++ ) {
                printf ("%s %s\n", Temp->nport, Temp->network);
    }
    Deb_Msg(glb_MsgText);
#endif
    return SUCCESS;

}

int  Cmp_Pnumber (const void *ptr1, const void *ptr2)
{
    /* always SIZE_PHONENO chars are compared */
    return (memcmp(((NPORT_TABLE *)ptr1)->nport, ((NPORT_TABLE *)ptr2)->nport, SIZE_PHONENO));
}

/*
** Name     : Get_NetPort()
**
** Description  : Get Network from Memory Number Port Table.
**        If there is Number Port Record in Memory Table then
**          Do Binary Search on the Number Port Table for the given number (matching SIZE_PHONENO)
**          If Matched, then copy the Network to the Output parameter.
**
** Parameters   : char *Nport - INPUT       - Pointer to the buffer contains Ported Number.
**        char *Net   - OUTPUT      - Pointer to the buffer contains Matched Network.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_NetPort (char *Nport, char *Net)
{
    int iTmp = 0;
    NPORT_TABLE *Temp = NULL;
    Temp = glb_NportHead;

    if ( *Nport == '\0' ) /* Ported Number not passed */
        return FAILURE;

    /* Do binary search on the Number Port Table */
    Temp = bsearch (Nport, Temp, glb_MapdStat[IDX_NPORT_TABLE].tot_recs, sizeof(NPORT_TABLE), Cmp_Pnumber);

    if ( Temp == (NPORT_TABLE *)NULL)
        return FAILURE;   /* no match found */
    else
        strcpy(Net, Temp->network);    /* match found - copy the Network from Table */

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_MsrnTable()
**
** Description  : Loads Mobile Station Roaming Number Records into Memory Table.
**        Opens the Mobile Station Roaming Number File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Mobile Station Roaming Number file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Mobile Station Roaming Number File.
**
** Parameters   : int   Idx - INPUT - Index of MSRN Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/

int Load_MsrnTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    Network[SIZE_NET+1];
    char    Cell[SIZE_CELL+1];
    long    MsrnFrom, MsrnTo;

    int iTmp = 0;
    MSRN_TABLE *Temp=NULL;      /* Local Pointer to Global Mobile Station Roaming Number Table */


    /* open the MSRN.DAT file */
    if ( (fp = fopen(glb_MapdStat[IDX_MSRN_TABLE].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(MSRN_TABLE) * iTmp + sizeof(MSRN_TABLE);  /* 1 element extra for safety */

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[IDX_MSRN_TABLE].num_loads)    /* First time loading */
        Temp = glb_MsrnHead = (MSRN_TABLE *) malloc (iTmp);
    else
        Temp = glb_MsrnHead = (MSRN_TABLE *) realloc (glb_MsrnHead, iTmp);

    if ( Temp == (MSRN_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    memset(glb_MsrnHead, 0x00, iTmp);
    glb_MapdStat[IDX_MSRN_TABLE].tot_recs = 0;  /* Total Mobile Station Roaming Number Records */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Network, 0x00, sizeof (Network));
        memset(Cell, 0x00, sizeof (Cell));
        MsrnFrom = MsrnTo = 0;

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#")) != NULL) {

            strncpy(Network, pstr, SIZE_NET);  /* network type */
            Trim_Str(Network);

            if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                strncpy(Cell, pstr, SIZE_CELL);    /* cell */
                Trim_Str(Cell);

                if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                    MsrnFrom = atol(pstr);     /* Msrn From */

                    if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                        MsrnTo = atol(pstr);   /* Msrn To */

                        /* Add to Mobile Station Roaming Number Table */
                        strcpy(Temp->network, Network);
                        strcpy(Temp->cell, Cell);
                        Temp->msrnfrom = MsrnFrom;
                        Temp->msrnto = MsrnTo;

                        glb_MapdStat[IDX_MSRN_TABLE].tot_recs++;    /* count */
                        Temp++;
                    }
                }
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[IDX_MSRN_TABLE].tot_recs) /* nothing is loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[IDX_MSRN_TABLE].load_stat = TRUE;  /* successfully loaded */
    glb_MapdStat[IDX_MSRN_TABLE].num_loads++;   /* count this loading */

    /*
    sprintf(glb_MsgText, "%d Mobile Station Roaming Number codes loaded..", glb_MapdStat[IDX_MSRN_TABLE].tot_recs);
    Deb_Msg(glb_MsgText);
    */

#ifdef SHOW_LOAD
    Temp = glb_MsrnHead;
    for (iTmp = 0; iTmp < glb_MapdStat[IDX_MSRN_TABLE].tot_recs; iTmp++, Temp++) {
                printf ("%s %s %ld %ld\n",Temp->network, Temp->cell, Temp->msrnfrom, Temp->msrnto);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Get_MsrnCell (char *Msrn, char *Net, char *Cell)
{
    int iTmp = 0;
    MSRN_TABLE *Temp = NULL;
    long    lMsrn = atol(Msrn);

    Temp = glb_MsrnHead;

    if ( lMsrn) { /* msrn is passed */
        /* match GSM, Cell and Cellset with Mobile Station Roaming Number Table */
        for (iTmp = 0; iTmp < glb_MapdStat[IDX_MSRN_TABLE].tot_recs; iTmp++, Temp++) {

            if ( lMsrn >= Temp->msrnfrom && lMsrn <= Temp->msrnto) { /* given msrn is within range */
                strcpy(Net, Temp->network);    /* copy the network */
                strcpy(Cell, Temp->cell);  /* copy the Cell */
                return SUCCESS;
            }
        }
    }
    return FAILURE;
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_ZoneTable()
**
** Description  : Loads Zone Records into Memory Table.
**        One function is used to load AIS Zone, DPC Zone in separate memory locations.
**        Opens the Zone File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Zone file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Zone File.
**        Sorts the Memory table by Network+Cellid (combined key).
**
** Parameters   : int   Idx - INPUT - Index of (AIS/DPC) Zone Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/

int Load_ZoneTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    Network[SIZE_NET+1];
    char    Zoneid[SIZE_ZID+1];
    char    Cellid[SIZE_CID+1];

    int iTmp = 0;
    ZONE_TABLE *Temp=NULL;      /* Local Pointer to Zone Table */

    /* open the (AIS/DPC) ZONE Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(ZONE_TABLE) * iTmp + sizeof(ZONE_TABLE);  /* 1 element extra for safety */

    /* Identify which (AIS/DPC) memory location to be Used */
    if ( Idx == IDX_ZONE_TABLE)
        Temp = glb_ZoneHead;
    else
        Temp = glb_DpcZoneHead;

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[Idx].num_loads)   /* First time */
        Temp = (ZONE_TABLE *) malloc (iTmp);
    else                    /* Not First time */
        Temp = (ZONE_TABLE *) realloc (Temp, iTmp);

    if ( Temp == (ZONE_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    /* Save the newly allocated meomory Pointer */
    if ( Idx == IDX_ZONE_TABLE)
        glb_ZoneHead = Temp;
    else
        glb_DpcZoneHead = Temp;

    memset(Temp, 0x00, iTmp);
    glb_MapdStat[Idx].tot_recs = 0;     /* reset Total Zone Codes */
    fseek (fp, 0, SEEK_SET);        /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Network, 0x00, sizeof (Network));
        memset(Zoneid, 0x00, sizeof (Zoneid));
        memset(Cellid, 0x00, sizeof (Cellid));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {

            strncpy(Network, pstr, SIZE_NET);  /* network */
            Trim_Str(Network);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                strncpy(Zoneid, pstr, SIZE_ZID);   /* zone id */
                Trim_Str(Zoneid);

                if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                    strncpy(Cellid, pstr, SIZE_CID);   /* cell id */
                    Trim_Str(Cellid);

                    /* Add to Zone Table (assemble the key) */
                    strcpy(Temp->netcell, Network);
                    Pad_Str (Temp->netcell, SIZE_NET);
                    strcat(Temp->netcell, Cellid);

                    strcpy(Temp->zoneid, Zoneid);

                    glb_MapdStat[Idx].tot_recs++;   /* count */
                    Temp++;
                }
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs)     /* no zone code loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Reset the Local Pointer to the first record */
    if ( Idx == IDX_ZONE_TABLE)
        Temp = glb_ZoneHead;
    else
        Temp = glb_DpcZoneHead;

    /* Sort the (AIS/DPC) Zone Table by Network+Cellid (combined key) */
    qsort((ZONE_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(ZONE_TABLE), Cmp_NetCell);

#ifdef SHOW_LOAD
    for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++) {
                printf ("%s %s\n",Temp->netcell, Temp->zoneid);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Cmp_NetCell (const void *ptr1, const void *ptr2)
{
    return (strcmp(((ZONE_TABLE *)ptr1)->netcell, ((ZONE_TABLE *)ptr2)->netcell));
}

/*
** Name     : Get_ZoneId()
**
** Description  : Get Zone Id from Zone Table.
**        Identifies which Partition ID (AIS/DPC) for CDR under processing.
**        Then Identifies which memory (AIS/DPC) Zone Table to be used.
**        If there is Zone record in Memory Zone Table then
**          Do Binary search the Zone Table for the given Net, Cellid
**          If Matched, then copy the Network if required, and Zone Id.
**
** Parameters   : char *Net    - INPUT/OUTPUT - Pointer to the buffer contains Network Information.
**        char *Cellid - INPUT        - Pointer to the buffer contains Cell Id Information.
**        char *Zoneid - OUTPUT       - Pointer to the matched Zone Id.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_ZoneId (char *Net, char *Cellid, char *Zoneid)
{
    ZONE_TABLE *Temp = NULL;
    int Idx = 0;
    char    Key[SIZE_NET+SIZE_CID+1];  /* To assemble search key */


    if ( *Net == '\0' || *Cellid == '\0' )    /* Net or Cellid not passed */
        return FAILURE;

    if ( glb_PartId == AISSVC_PARTITION) {
        Temp = glb_ZoneHead;        /* Use AIS Zone Table */
        Idx = IDX_ZONE_TABLE;       /* Index of AIS Zone in Memory Statistics */
    }
    else {
        Temp = glb_DpcZoneHead;     /* Use DPC Zone Table */
        Idx = IDX_DPCZONE_TABLE;    /* Index of DPC Zone in Memory Statistics */
    }

    memset(Key, 0x00, sizeof (Key));
    strcpy(Key, Net);
    Pad_Str (Key, SIZE_NET);
    strcat(Key, Cellid);

    /* Do binary search on the Zone Table */
    Temp = bsearch (Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(ZONE_TABLE), Cmp_NetCell);

    if ( Temp == (ZONE_TABLE *)NULL)
        return FAILURE;   /* no match found */
    else
        strcpy(Zoneid, Temp->zoneid);  /* match found - copy the Zone Id from Table */

    return SUCCESS;
}

int Parse_ZoneId (char *Number, char *Net, char *Cellid, char *Zoneid)
{

    char Tcellid[SIZE_CID+1];
    char Tzoneid[SIZE_ZID+1];

    int  start = 0, end = 0, i = 0;
    int  mctr = 0;  /* number of match found */

    struct mtab {
        int nod;            /* number of digits matched */
        char    net[SIZE_NET +1];   /* Network Code */
        char    cellid[SIZE_CID+1]; /* Cell Id code */
        char    zoneid[SIZE_ZID+1]; /* Zone Id code */
    };
    struct mtab mstat[SIZE_CID];

    if ( *Number == '\0' || *Net == '\0' )    /* We need the Calling or Called number and Network to parse */
        return FAILURE;

    memset(mstat, 0x00, sizeof(mstat));
    memset(Tcellid, 0x00, sizeof(Tcellid));
    memset(Tzoneid, 0x00, sizeof(Tzoneid));

    start = 1;  /* parsing starts from 1st character */
    end = ((strlen(Number) < SIZE_CID) ? strlen(Number) : SIZE_CID); /* parsing stops after this many characters */

    /*
    **  First : take first character from Number and match with zone table
    **  Second: take first two characters from Number and match with zone table
    **     and so on...
    */

    for (i = start; i <= end; i++) {
        strncpy(Tcellid, Number, i);   /* extract i number of characters only */
        Trim_Str(Tcellid);

                /* match the network, extracted characters (cellid) with Zone Table */
        if ( !Get_ZoneId (Net, Tcellid, Tzoneid) ) { /* match found */

            /* store the matched info */
            mstat[mctr].nod = i;
            strcpy(mstat[mctr].net, Net);
            strcpy(mstat[mctr].cellid, Tcellid);
            strcpy(mstat[mctr].zoneid, Tzoneid);
            mctr++;
        }
    }

    /* now check the match statistics for any match */
    switch (mctr) {
        case 0 : /* code not matched */
            return FAILURE;

        case 1 : /* only one code matched (that would be in the 0th element */
            if ( mstat[0].nod ) {
                strcpy(Net, mstat[0].net);
                /* strcpy(Cellid, mstat[0].cellid); */
                strncpy(Cellid, mstat[0].cellid, 6);   /* cell_ida/b in com_buf can contain 6 char only -chamy 16-Oct-2001 */
                strcpy(Zoneid, mstat[0].zoneid);
                return SUCCESS;
            }
            break;

        default :
            /* more than one code matched locate final matched (max) digits */
            if ( mstat[mctr - 1].nod ) {
                strcpy(Net, mstat[mctr - 1].net);
                /* strcpy(Cellid, mstat[mctr - 1].cellid); */
                strncpy(Cellid, mstat[mctr - 1].cellid, 6);    /* cell_ida/b in com_buf can contain 6 char only -chamy 16-Oct-2001 */
                strcpy(Zoneid, mstat[mctr - 1].zoneid);
                return SUCCESS;
            }
    }
    return FAILURE;
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_ZmapTable()
**
** Description  : Loads Zone Mapping Records into Memory Table.
**        One function is used to load AIS Zone Mapping, DPC Zone Mapping in separate memory locations.
**        Opens the Zone Mapping File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Zone Mapping file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Zone Mapping File.
**        Sorts the Memory table by Network+ZoneidA+ZoneidB. (combined key)
**
** Parameters   : int   Idx - INPUT - Index of (AIS/DPC) Zone Mapping Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/

int Load_ZmapTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    Network[SIZE_NET+1];
    char    Inzoneid[SIZE_ZID+1];
    char    Outzoneid[SIZE_ZID+1];
    char    Zonetype[SIZE_ZTYPE+1];

    int iTmp = 0;
    ZMAP_TABLE *Temp=NULL;      /* Local Pointer to Zone Mapping Table */


    /* open the (AIS/DPC) ZMAPPING Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(ZMAP_TABLE) * iTmp + sizeof(ZMAP_TABLE);  /* 1 element extra for safety */

    /* Identify which (AIS/DPC) memory location to be Used */
    if ( Idx == IDX_ZMAP_TABLE)
        Temp = glb_ZmapHead;
    else
        Temp = glb_DpcZmapHead;

    /* (Re)Allocate memory required for all Zone Mapping Records */
    if ( !glb_MapdStat[Idx].num_loads)   /* First time */
        Temp = (ZMAP_TABLE *) malloc (iTmp);
    else                    /* Not First time */
        Temp = (ZMAP_TABLE *) realloc (Temp, iTmp);

    if ( Temp == (ZMAP_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    /* Save the newly allocated meomory Pointer */
    if ( Idx == IDX_ZMAP_TABLE)
        glb_ZmapHead = Temp;
    else
        glb_DpcZmapHead = Temp;

    memset(Temp, 0x00, iTmp);
    glb_MapdStat[Idx].tot_recs = 0;     /* reset Total Zone Mapping Codes */
    fseek (fp, 0, SEEK_SET);        /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Network, 0x00, sizeof (Network));
        memset(Inzoneid, 0x00, sizeof (Inzoneid));
        memset(Outzoneid, 0x00, sizeof (Outzoneid));
        memset(Zonetype, 0x00, sizeof (Zonetype));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {

            strncpy(Network, pstr, SIZE_NET);  /* network */
            Trim_Str(Network);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                strncpy(Inzoneid, pstr, SIZE_ZID); /* incomming zone id */
                Trim_Str(Inzoneid);

                if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                    strncpy(Outzoneid, pstr, SIZE_ZID);    /* outgoing zone id */
                    Trim_Str(Outzoneid);

                    if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                        strncpy(Zonetype, pstr, SIZE_ZTYPE);   /* zone type */
                        Trim_Str(Zonetype);

                        /* Add to Zone Mapping Table (assemble the key) */
                        strcpy(Temp->netzoneab, Network);
                        Pad_Str (Temp->netzoneab, SIZE_NET);
                        strcat(Temp->netzoneab, Inzoneid);
                        Pad_Str (Temp->netzoneab, SIZE_NET+SIZE_ZID);
                        strcat(Temp->netzoneab, Outzoneid);
                        strcpy(Temp->zonetype, Zonetype);

                        glb_MapdStat[Idx].tot_recs++;   /* count */
                        Temp++;
                    }
                }
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs)    /* nothing is loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Reset the Local Pointer to the first record */
    if ( Idx == IDX_ZMAP_TABLE)
        Temp = glb_ZmapHead;
    else
        Temp = glb_DpcZmapHead;

    /* Sort the (AIS/DPC) Zone Mapping Table by Network + ZoneidA + ZoneidB (combined key) */
    qsort((ZMAP_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(ZMAP_TABLE), Cmp_NetZoneAB);

#ifdef SHOW_LOAD
    for ( iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++) {
                printf ("%s %s\n",Temp->netzoneab, Temp->zonetype);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Cmp_NetZoneAB (const void *ptr1, const void *ptr2)
{
    return (strcmp(((ZMAP_TABLE *)ptr1)->netzoneab, ((ZMAP_TABLE *)ptr2)->netzoneab));
}

int Get_ZoneType (char *Net, char *ZoneidA, char *ZoneidB, char *ZoneType)
{
    ZMAP_TABLE *Temp = NULL;
    int Idx=0;
    char    Key[SIZE_NET+SIZE_ZID+SIZE_ZID+1]; /* To assemble search key */

    if ( *Net == '\0' || *ZoneidA == '\0' || *ZoneidB == '\0' )
        return FAILURE;

    if ( glb_PartId == AISSVC_PARTITION) {
        Temp = glb_ZmapHead;        /* Use AIS Zone Mapping Table */
        Idx = IDX_ZMAP_TABLE;       /* Index of AIS Zone Mapping in Memory Statistics */
    }
    else {
        Temp = glb_DpcZmapHead;     /* Use DPC Zone Mapping Table */
        Idx = IDX_DPCZMAP_TABLE;    /* Index of DPC Zone Mapping in Memory Statistics */
    }

    /* Assemble Key */
    memset(Key, 0x00, sizeof (Key));
    strcpy(Key, Net);
    Pad_Str (Key, SIZE_NET);
    strcat(Key, ZoneidA);
    Pad_Str (Key, SIZE_NET+SIZE_ZID);
    strcat(Key, ZoneidB);

    /* Do binary search on the Zone Table */
    Temp = bsearch (Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(ZMAP_TABLE), Cmp_NetZoneAB);

    if ( Temp == (ZMAP_TABLE *)NULL)
        return FAILURE;   /* no match found */
    else
        strcpy(ZoneType, Temp->zonetype);  /* match found - copy the Zone Type from Table */

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_NatlRate()
**
** Description  : Loads National Rate Records into Memory Table.
**        One function is used to load AIS National Rate, DPC National Rate in separate memory locations.
**        Opens the National Rate File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from National Rate file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the National Rate File.
**
** Parameters   : int   Idx - INPUT - Index of National Rate Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/

int Load_NatlRate (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    Zonetype[SIZE_ZTYPE+1];
    double  Rate_pm;

    int iTmp = 0;
    NRATE_TABLE *Temp=NULL;     /* Local Pointer to Global National Rate Table */


    /* open the (AIS/DPC) NATL_RATE Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(NRATE_TABLE) * iTmp + sizeof(NRATE_TABLE);    /* 1 element extra for safety */

    /* Identify which (AIS/DPC) memory location to be Used */
    if ( Idx == IDX_NRATE_TABLE)
        Temp = glb_NrateHead;
    else
        Temp = glb_DpcNrateHead;

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[Idx].num_loads)       /* First time loading */
        Temp = (NRATE_TABLE *) malloc (iTmp);
    else                        /* Not First time */
        Temp = (NRATE_TABLE *) realloc (Temp, iTmp);

    if ( Temp == (NRATE_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    /* Save the newly allocated meomory Pointer */
    if ( Idx == IDX_NRATE_TABLE)
        glb_NrateHead = Temp;
    else
        glb_DpcNrateHead = Temp;

    memset(Temp, 0x00, iTmp);
    glb_MapdStat[Idx].tot_recs = 0;     /* reset Total National Rate Codes */
    fseek (fp, 0, SEEK_SET);        /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Zonetype, 0x00, sizeof (Zonetype));
        Rate_pm = 0;

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')  /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {

            strncpy(Zonetype, pstr, SIZE_ZTYPE);   /* zone type */
            Trim_Str(Zonetype);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL)    /* Skip zone type description */
            if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                Rate_pm = atof(pstr);       /* rate per minute */

                /* Add to National Rate Table */
                strcpy(Temp->zonetype, Zonetype);
                Temp->rate_pm = Rate_pm;

                glb_MapdStat[Idx].tot_recs++;   /* count */
                Temp++;
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs)    /* nothing is loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Reset the Local Pointer to the first record */
    if ( Idx == IDX_NRATE_TABLE)
        Temp = glb_NrateHead;
    else
        Temp = glb_DpcNrateHead;

#ifdef SHOW_LOAD
    for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++) {
                printf ("%s %f\n", Temp->zonetype, Temp->rate_pm);
    }
    Deb_Msg(glb_MsgText);
#endif
    return SUCCESS;
}

int Get_NatlRate (char *ZoneType, double *Rate)
{
    int Idx=0;
    int iTmp = 0;
    NRATE_TABLE *Temp = NULL;

    if ( *ZoneType == '\0' )
        return FAILURE;

    if ( glb_PartId == AISSVC_PARTITION) {
        Temp = glb_NrateHead;       /* Use AIS National Rating Table */
        Idx = IDX_NRATE_TABLE;      /* Index of AIS National Rating in Memory Statistics */
    }
    else {
        Temp = glb_DpcNrateHead;    /* Use DPC National Rating Table */
        Idx = IDX_DPCNRATE_TABLE;   /* Index of DPC National Rating in Memory Statistics */
    }

    /* match the ZoneType with National Rate Table */
    for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++) {
        if ( !strcmp(Temp->zonetype, ZoneType) ) {   /* if code matched */
            *Rate = Temp->rate_pm;
            return SUCCESS;
        }
    }
    return FAILURE;
}
#endif  /* REMOVE_TABLE */

void    Get_DayNightRate (char *ZoneType, time_t SeizeTime, double *Rate)
{

    /* struct tm    *ptm = gmtime(&SeizeTime); */   /* Fixed Bug as below by Kawee on 26-Aug-2004 */
    struct tm   *ptm = localtime(&SeizeTime);

    switch ( atoi(ZoneType) ) {
        case 6: /* Adjascent Malaysia       */
            if ( ptm->tm_hour >= 18 || ptm->tm_hour < 7 )
                *Rate = 10;

            break;

        case 8: /* Long Distance Malaysia   */
            if ( ptm->tm_hour >= 18 || ptm->tm_hour < 7 )
                *Rate = 20;

            break;

        case 14:    /* Long Distance Myanmar    */
            if ( ptm->tm_wday == 0 || ptm->tm_hour >= 18 || ptm->tm_hour < 7)
                *Rate = 24;

            break;

        case 13:    /* Long Distance Cambodia   */
            if ( ptm->tm_wday == 0 || ptm->tm_hour >= 18 || ptm->tm_hour < 7)
                *Rate = 24;

            break;
    }
    /* Added below for Debug gmtime Function - by Kawee on 26-Aug-2004 */
#ifdef DONT_DELETE
    if ( glb_DbgFlag) {
        printf("ZoneType = %s, SeizeTime=%d, Hour=%d, Rate=%f\n", ZoneType, SeizeTime, ptm->tm_hour, *Rate);
    }
#endif
}

/*------------------------------------------------------------------------------------*/
int Parse_Area (char *dialed_no, char *code)
{
    char Ddigits[32+1];
    char ptmp[32+1], acode[SIZE_NDD+1];
    int  i;

    int  mctr = 0;  /* number of match found */
    int  len_acode = 0; /* Size of matched area code */

    memset(Ddigits, 0x00, sizeof(Ddigits));
    memset(ptmp, 0x00, sizeof(ptmp));
    memset(acode, 0x00, sizeof(acode));

    if ( !strncmp(dialed_no, "66", 2) ) {
        *Ddigits = '0';
        strcpy(Ddigits + 1, dialed_no+2);
    }
    else if ( *dialed_no != '0') {
        /*
        ** if the first character of dialed_no is not '0' then prefix '0' and start Parsing
        ** This condition will occur while processing TAP CDRs.
        */
        *Ddigits = '0';
        strcat(Ddigits, (char *)dialed_no);
    }
    else
        strcpy(Ddigits, (char *)dialed_no);

    /* if ( strlen(Ddigits) < SIZE_NDD)
        return FAILURE; */

    /*
    ** First : match Ddigits with Area Code
    ** Second: if found matched Area Code greater than one code get the longest code as matched code
    */

    /* match the extracted character in area table */
    for (i = 0; i < glb_tac; i++) {
        /* if code match found */
        if ( !strncmp(area_tab[i].area_code, Ddigits, area_tab[i].size) ) {

            /* store the matched info */
            if ( len_acode < area_tab[i].size) {
                strcpy(acode, area_tab[i].area_code);
                len_acode = area_tab[i].size;
            }
            mctr++;
        }
    } /* end for i */

    /* now check the match statistics for exact match */
    if ( mctr == 0 ) {
        return PARSE_NOT_MATCH;
    }
    else {
        strcpy(code, acode);
        return SUCCESS;
    }
    /* return FAILURE; */     /* Statement is unreachable - Removed by Kawee on 12-Jul-2006 */
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_IntlRate()
**
** Description  : Loads Intl' Rate Records into Memory Table.
**        Opens the Intl' Rate File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Intl' Rate file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Intl' Rate File.
**        Sorts the Memory table by Idd Codes.
**
** Parameters   : int   Idx - INPUT - Index of Intl' Rate Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Load records exceeds NOF_IRATES.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/

int Load_IntlRate (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    Iddcode[SIZE_IDD+1];
    double  IDDRatepm = 0;
    double  EPHRatepm = 0;
    double  TOTIntlRatepm = 0;
    double  TOTVoipRatepm = 0;

    int iTmp = 0;
    IDD_TABLE *Temp=NULL;       /* Local Pointer to Global International Rate Table */


    /* open the INTL_RATE Data file */
    if ( (fp = fopen(glb_MapdStat[IDX_IDD_TABLE].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(IDD_TABLE) * iTmp + sizeof(IDD_TABLE);    /* 1 element extra for safety */

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[IDX_IDD_TABLE].num_loads)     /* First time loading */
        Temp = (IDD_TABLE *) malloc (iTmp);
    else
        Temp = (IDD_TABLE *) realloc (glb_IddHead, iTmp);

    if ( Temp == (IDD_TABLE *)NULL)
        return LOAD_TABLE_FULL;
    glb_IddHead = Temp;

    memset(glb_IddHead, 0x00, iTmp);
    glb_MapdStat[IDX_IDD_TABLE].tot_recs = 0;   /* Total International Rate Codes */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Iddcode, 0x00, sizeof (Iddcode));
        IDDRatepm = 0;
        EPHRatepm = 0;
        TOTIntlRatepm = 0;
        TOTVoipRatepm = 0;

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')  /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {

            strncpy(Iddcode, pstr, SIZE_IDD);  /* country code */
            Trim_Str(Iddcode);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL)    /* Skip Country Description */
            if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {  /* IDD Rate per Minute */
                IDDRatepm = atof(pstr);             /* Save the rate */

                if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {  /* E-Phone Rate per Minute */
                    EPHRatepm = atof(pstr);         /* Save the rate */

                    if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {  /* TOT Intl' Rate per Minute */
                        TOTIntlRatepm = atof(pstr);         /* Save the rate */

                        if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                            /* TOT VOIP Intl' Rate per Minute */
                            TOTVoipRatepm = atof(pstr);         /* Save the rate */

                            /* Add to International Rate Table */
                            strcpy(Temp->idd_code, Iddcode);
                            Temp->idd_rate_pm = IDDRatepm;
                            Temp->eph_rate_pm = EPHRatepm;
                            Temp->tot_intl_rate_pm = TOTIntlRatepm;
                            Temp->tot_voip_rate_pm = TOTVoipRatepm;

                            glb_MapdStat[IDX_IDD_TABLE].tot_recs++;     /* count */
                            Temp++;
                        }
                    }
                }
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[IDX_IDD_TABLE].tot_recs) /* nothing is loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[IDX_IDD_TABLE].load_stat = TRUE;   /* successfully loaded */
    glb_MapdStat[IDX_IDD_TABLE].num_loads++;    /* count this loading */

    /*
    sprintf(glb_MsgText, "%d International Rate codes loaded..", glb_MapdStat[IDX_IDD_TABLE].tot_recs);
    Deb_Msg(glb_MsgText);
    */

    /* Sort the Mobile Network Table by Idd Code */
    qsort((IDD_TABLE *)glb_IddHead, glb_MapdStat[IDX_IDD_TABLE].tot_recs, sizeof(IDD_TABLE), Cmp_Idd);

#ifdef SHOW_LOAD
    Temp = glb_IddHead;
    for (iTmp = 0; iTmp < glb_MapdStat[IDX_IDD_TABLE].tot_recs; iTmp++, Temp++) {
                printf ("%s %f %f %f %f\n",
            Temp->idd_code, Temp->idd_rate_pm, Temp->eph_rate_pm, Temp->tot_intl_rate_pm, Temp->tot_voip_rate_pm);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Cmp_Idd (const void *ptr1, const void *ptr2)
{
    return (strcmp(((IDD_TABLE *)ptr1)->idd_code, ((IDD_TABLE *)ptr2)->idd_code));
}

/*
** Function is revised by chamy on 10-Oct-2001 to accomodate E-Phone Int'l Access.
**
** For HR2_TYPE, IR2_TYPE, IR1_TYPE this function assumes that the International Access code is not passed in dialed_no.
** For Other types this function assumes that the International Access code is present in the dialed_no.
** This because we need to find if IDD or E-Phone Access Code is present in the dialed_no.
** Rates are different for IDD and E-Phone.
*/

int Parse_Country (char *dialed_no, char *code, double *rate)
{
    IDD_TABLE *Temp = NULL;

    char Acccode[5+1]; /* size is as per GSM standard */
    char Dialedno[32+1];   /* size is as per frm */

    char Iddcode[SIZE_IDD+1];
    int  i;
    int  mctr = 0;  /* number of match found */

    struct mtab {
        int nod;            /* number of digits */
        char    ccode[SIZE_IDD+1];  /* country code */
        double  rate;           /* rate per minute */
    };
    struct mtab mstat[SIZE_IDD];

    if ( *dialed_no == '\0' ) /* We need the Dailled Number to parse */
        return FAILURE;

    memset(mstat, 0x00, sizeof(mstat));

    /*
    ** Changed as below for removed TAP format.
    ** - Kawee 11-Apr-2003
    */
    if ( !strncmp(dialed_no, IDDACC_CODE, IDDACC_LEN) ) {
        strncpy(Acccode, dialed_no, IDDACC_LEN);       /* Save the IDD Access code */
        strcpy(Dialedno, dialed_no+IDDACC_LEN);        /* Strip the IDD Access code */
    }
    else if ( !strncmp(dialed_no, EPHACC_CODE, EPHACC_LEN) ) {
        strncpy(Acccode, dialed_no, EPHACC_LEN);       /* Save the E-Phone Access code */
        strcpy(Dialedno, dialed_no+EPHACC_LEN);        /* Strip the E-Phone Access code */
    }
    /* Introduced TOT International access - Added by Kawee on 24-Aug-2004 */
    else if ( !strncmp(dialed_no, TOTIDDACC_CODE, TOTIDDACC_LEN) ) {
        strncpy(Acccode, dialed_no, TOTIDDACC_LEN);        /* Save the TOT IDD Access code */
        strcpy(Dialedno, dialed_no+TOTIDDACC_LEN);     /* Strip the TOT IDD Access code */
    }
    /* Introduced TOT VOIP International access - Added by Kawee on 07-Sep-2004 */
    else if ( !strncmp(dialed_no, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ) {
        strncpy(Acccode, dialed_no, TOTVOIPACC_LEN);       /* Save the TOT VOIP Access code */
        strcpy(Dialedno, dialed_no+TOTVOIPACC_LEN);        /* Strip the TOT VOIP Access code */
    }
    /*
    ** In V9.2-1, Calculate Get Charge by get rate from other tables, don't use rate in INTL_RATE.DAT table
    ** Use INTL_RATE.DAT Table for parse country code only.
    ** - Added below by Kawee on 08-Sep-2005
    */
    else if ( !strncmp(dialed_no, TOTMALAYACC_CODE, TOTMALAYACC_LEN) ) {
        strncpy(Acccode, dialed_no, IDDACC_LEN);       /* Save the IDD Access code */
        strcpy(Dialedno, dialed_no+IDDACC_LEN);        /* Strip the IDD Access code */
    }
    /* Introduced AIN 3rd Product Intl - Added by Kawee on 11-Nov-2009 */
    else if ( !strncmp(dialed_no, AIN3RDACC_CODE, AIN3RDACC_LEN) ||
              !strncmp(dialed_no, AWNIDDACC_COD3, AIN3RDACC_LEN) ) {   /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
        strncpy(Acccode, dialed_no, AIN3RDACC_LEN);        /* Save the AIN 3rd Product Access code */
        strcpy(Dialedno, dialed_no+AIN3RDACC_LEN);     /* Strip the AIN 3rd Product Access code */
    }
    /* Introduced AIN 2nd Product Intl - Added by Kawee on 25-Aug-2008 */
    else if ( !strncmp(dialed_no, AIN2NDACC_CODE, AIN2NDACC_LEN) ||
              !strncmp(dialed_no, AWNIDDACC_COD2, AIN2NDACC_LEN) ) {       /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
        strncpy(Acccode, dialed_no, AIN2NDACC_LEN);        /* Save the AIN 2nd Product Access code */
        strcpy(Dialedno, dialed_no+AIN2NDACC_LEN);     /* Strip the AIN 2nd Product Access code */
    }
    /* Introduced AIN International access - Added by Kawee on 04-Jan-2007 */
    else if ( !strncmp(dialed_no, AINIDDACC_CODE, AINIDDACC_LEN) ||
              !strncmp(dialed_no, AWNIDDACC_COD1, AINIDDACC_LEN) ) {       /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
        strncpy(Acccode, dialed_no, AINIDDACC_LEN);        /* Save the AIN IDD Access code */
        strcpy(Dialedno, dialed_no+AINIDDACC_LEN);     /* Strip the AIN IDD Access code */
    }
    /* Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007 */
    else if ( !strncmp(dialed_no, "006", 3) ) {
        strncpy(Acccode, dialed_no, 3);            /* Save the ?AIN IDD Access code */
        strcpy(Dialedno, dialed_no+3);             /* Strip the ?AIN IDD Access code */
    }

    /*
    ** First : take first one from Dialedno and then match with country table
    ** Second: take first two from Dialedno and then match with country table
    ** Third : take first three from Dialedno and then match with country table
    ** upto SIZE_IDD times..
    */

    for (i = 1; i <= SIZE_IDD ; i++) {
        memset(Iddcode, 0x00, sizeof(Iddcode));
        Temp = glb_IddHead;

        strncpy(Iddcode, Dialedno, i);     /* extract i number of characters only */
        Trim_Str(Iddcode);

        /* match the extracted character in International Rate table - binary search */
        Temp = bsearch (Iddcode, Temp, glb_MapdStat[IDX_IDD_TABLE].tot_recs, sizeof(IDD_TABLE), Cmp_Idd);
        if ( Temp != (IDD_TABLE *)NULL) {

            /* store the matched info */
            mstat[mctr].nod = i;
            strcpy(mstat[mctr].ccode, Temp->idd_code);
            if ( !strncmp(com_buf.b_no, EPHACC_CODE, EPHACC_LEN))   /* E-Phone access Code */
                mstat[mctr].rate = Temp->eph_rate_pm;       /* Use E-Phone Rate */
            else if ( !strncmp(com_buf.b_no, TOTIDDACC_CODE, TOTIDDACC_LEN))    /* TOT IDD access Code */
                mstat[mctr].rate = Temp->tot_intl_rate_pm;  /* Use TOT IDD Rate */
            else if ( !strncmp(com_buf.b_no, TOTVOIPACC_CODE, TOTVOIPACC_LEN))  /* TOT VOIP access Code */
                mstat[mctr].rate = Temp->tot_voip_rate_pm;  /* Use TOT VOIP Rate */
            else
                mstat[mctr].rate = Temp->idd_rate_pm;       /* Use IDD Rate */
            mctr++;
        }
    }

    /* now check the match statistics for exact match */
    switch (mctr) {
        case 0 : /* code not matched */
            return PARSE_NOT_MATCH;

        case 1 : /* only one code matched */
            for (i = 0; i < SIZE_IDD; i++ ) {   /* locate the matched code */
                if ( mstat[i].nod ) {
                    strcpy(code, mstat[i].ccode);
                    *rate = mstat[i].rate;
                    return SUCCESS;
                }
            }
            break;

        default :
            /*
            ** more than one Idd code matched
            ** This will occur for example :
            **     the parse digits starts with 21 and next digit is any of : 2, 3, 8
            **     the parse digits starts with 37 and next digit is any of : 0, 1, 2, 3
            */

            /* locate max match digits */
            if ( mstat[mctr - 1].nod ) {
                strcpy(code, mstat[mctr - 1].ccode);
                *rate = mstat[mctr - 1].rate;
                return PARSE_MUL_MATCH;
            }
            break;
    }
    return FAILURE;
}

/*------------------------------------------------------------------------------------*/

#ifdef  REMOVE_TABLE
/*
** Name     : Load_CmapTable()
**
** Description  : Loads Cell Mapping Records into Memory Table.
**        Opens the Cell Mapping File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Cell Mapping file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Cell Mapping File.
**
** Parameters   : int   Idx - INPUT - Index of Cell Mapping Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/

int Load_CmapTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    Network[SIZE_NET+1];
    char    Cellarea[SIZE_CAREA+1];
    char    Cellset[SIZE_CSET+1];
    char    Cell[SIZE_CELL+1];

    int iTmp = 0;
    CMAP_TABLE *Temp=NULL;      /* Local Pointer to Global Cell Map Table */


    /* open the CELL_MAP.DAT file */
    if ( (fp = fopen(glb_MapdStat[IDX_CMAP_TABLE].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(CMAP_TABLE) * iTmp + sizeof(CMAP_TABLE);  /* 1 element extra for safety */

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[IDX_CMAP_TABLE].num_loads)    /* First time loading */
        Temp = glb_CmapHead = (CMAP_TABLE *) malloc (iTmp);
    else
        Temp = glb_CmapHead = (CMAP_TABLE *) realloc (glb_CmapHead, iTmp);

    if ( Temp == (CMAP_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    memset(glb_CmapHead, 0x00, iTmp);
    glb_MapdStat[IDX_CMAP_TABLE].tot_recs = 0;  /* Total Cell Map Codes */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Network, 0x00, sizeof (Network));
        memset(Cellarea, 0x00, sizeof (Cellarea));
        memset(Cellset, 0x00, sizeof (Cellset));
        memset(Cell, 0x00, sizeof (Cell));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#")) != NULL) {

            strncpy(Network, pstr, SIZE_NET);  /* network type */
            Trim_Str(Network);

            if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                strncpy(Cellarea, pstr, SIZE_CAREA);   /* cell area */
                Trim_Str(Cellarea);

                if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                    strncpy(Cellset, pstr, SIZE_CSET); /* cell set */
                    Trim_Str(Cellset);

                    if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                        strncpy(Cell, pstr, SIZE_CELL);    /* cell */
                        Trim_Str(Cell);

                        /* Add to Cell Map Table */
                        strcpy(Temp->network, Network);
                        strcpy(Temp->cell_area, Cellarea);
                        strcpy(Temp->cell_set, Cellset);
                        strcpy(Temp->cell, Cell);

                        glb_MapdStat[IDX_CMAP_TABLE].tot_recs++;    /* count */
                        Temp++;
                    }
                }
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[IDX_CMAP_TABLE].tot_recs) /* nothing is loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[IDX_CMAP_TABLE].load_stat = TRUE;  /* successfully loaded */
    glb_MapdStat[IDX_CMAP_TABLE].num_loads++;   /* count this loading */

    /*
    sprintf(glb_MsgText, "%d Cell Mapping codes loaded..", glb_MapdStat[IDX_CMAP_TABLE].tot_recs);
    Deb_Msg(glb_MsgText);
    */

#ifdef SHOW_LOAD
    Temp = glb_CmapHead;
    for (iTmp = 0; iTmp < glb_MapdStat[IDX_CMAP_TABLE].tot_recs; iTmp++, Temp++) {
                printf ("%s %s %s %s\n",Temp->network, Temp->cell_area, Temp->cell_set, Temp->cell);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Get_NmtCellInfo (char *Cell, char *Cellset, char *Cellarea)
{
    int iTmp = 0;
    CMAP_TABLE *Temp = NULL;
    Temp = glb_CmapHead;

    /*
    ** For NMT network only Cell in known from the CDR
    ** match NMT, Cell with Cell Mappping Table
    */
    for (iTmp = 0; iTmp < glb_MapdStat[IDX_CMAP_TABLE].tot_recs; iTmp++, Temp++) {
        if ( !strcmp(Temp->network, "NMT") && !strcmp(Temp->cell, Cell) ) { /* if code match found */

            strcpy(Cellset, Temp->cell_set);   /* copy the Cell Set */
            strcpy(Cellarea, Temp->cell_area); /* copy the Cell Area */
            return SUCCESS;
        }
    }
    return FAILURE;
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_SrateTable()
**
** Description  : Loads Service Rate Records into Memory Table.
**        Opens the Service Rate File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Service Rate file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Service Rate File.
**
** Parameters   : int   Idx - INPUT - Index of Service Rate Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/

int Load_SrateTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];
    int iTmp = 0;
    char    *pstr=NULL;
    SRATE_TABLE lbuf;           /* Local Buffer for Parsing */
    SRATE_TABLE *Temp=NULL;     /* Local Pointer to Global Service Rate Table */


    /* open the SERVICE_RATE.DAT file */
    if ( (fp = fopen(glb_MapdStat[IDX_SRATE_TABLE].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(SRATE_TABLE) * iTmp + sizeof(SRATE_TABLE);    /* 1 element extra for safety */

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[IDX_SRATE_TABLE].num_loads)   /* First time loading */
        Temp = glb_SrateHead = (SRATE_TABLE *) malloc (iTmp);
    else
        Temp = glb_SrateHead = (SRATE_TABLE *) realloc (glb_SrateHead, iTmp);

    if ( Temp == (SRATE_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    memset(glb_SrateHead, 0x00, iTmp);
    glb_MapdStat[IDX_SRATE_TABLE].tot_recs = 0; /* Total Service Rate Codes */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(&lbuf, 0x00, sizeof (SRATE_TABLE));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#")) != NULL) {

            strncpy(lbuf.scat_id, pstr, SIZE_SCAT);    /* service category id */
            Trim_Str(lbuf.scat_id);

            if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                strncpy(lbuf.cont_id, pstr, SIZE_CONT);   /* content id */
                Trim_Str(lbuf.cont_id);

                if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                    lbuf.bearer = *pstr;        /* Bearer Code */

                    if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                        strncpy(lbuf.service_id, pstr, SIZE_SVC);  /* Service Id */
                        Trim_Str(lbuf.service_id);

                        if ( (pstr = strtok((char *)NULL, "#")) != NULL) /* Skip Abbreviation */
                        if ( (pstr = strtok((char *)NULL, "#")) != NULL) /* Skip Description */
                        if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                            lbuf.charge_type = atoi(pstr);      /* Charge Type */

                            if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                                lbuf.txn_value = atof(pstr);    /* Transaction Value */

                                if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                                    lbuf.cont_value = atof(pstr);   /* Content Value */

                                    /* Add to Service Rate Table */
                                    strcpy(Temp->scat_id, lbuf.scat_id);
                                    strcpy(Temp->cont_id, lbuf.cont_id);
                                    Temp->bearer = lbuf.bearer;
                                    strcpy(Temp->service_id, lbuf.service_id);
                                    Temp->charge_type = lbuf.charge_type;
                                    Temp->txn_value = lbuf.txn_value;
                                    Temp->cont_value = lbuf.cont_value;

                                    glb_MapdStat[IDX_SRATE_TABLE].tot_recs++;   /* count */
                                    Temp++;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[IDX_SRATE_TABLE].tot_recs) /* nothing is loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[IDX_SRATE_TABLE].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[IDX_SRATE_TABLE].num_loads++;  /* count this loading */

    /*
    sprintf(glb_MsgText, "%d Service Rate codes loaded..", glb_MapdStat[IDX_SRATE_TABLE].tot_recs);
    Deb_Msg(glb_MsgText);
    */

#ifdef SHOW_LOAD
    Temp = glb_SrateHead;
    for (iTmp = 0; iTmp < glb_MapdStat[IDX_SRATE_TABLE].tot_recs; iTmp++, Temp++) {
                printf ("%s %s %c %s %d %f %f\n", Temp->scat_id, Temp->cont_id, Temp->bearer, Temp->service_id,
            Temp->charge_type, Temp->txn_value, Temp->cont_value);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Get_ServiceRate (char *Catid, char *Contid, char Bear, char *Svcid, double *Txnval, double *Contval)
{
    int iTmp = 0;
    SRATE_TABLE *Temp = NULL;
    Temp = glb_SrateHead;

    /* match GSM, Cell and Cellset with Service Rate Table */
    for (iTmp = 0; iTmp < glb_MapdStat[IDX_SRATE_TABLE].tot_recs; iTmp++, Temp++) {

        if ( !strcmp(Temp->scat_id, Catid) && !strcmp(Temp->cont_id, Contid) &&
            Temp->bearer == Bear && !strcmp(Temp->service_id, Svcid) ) {
            /* *Txnval = (double) ceil (Temp->txn_value);    copy Transaction Value & Round-up */

            *Txnval = (double) (Temp->txn_value);       /* copy Transaction Value */
            *Contval = (double) (Temp->cont_value);     /* copy Content Value */

            return SUCCESS;
        }
    }
    return FAILURE;
}

/*
** Name     : Load_TempPhoneTable()
**
** Description  : Loads Temporary Phone Number Records into Memory Table.
**        Opens the Temporary Phone Number File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Temporary Phone Number file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Temporary Phone Number File.
**        Sorts the Memory table by Phone Number.
**
** Parameters   : int   Idx - INPUT - Index of Temporary Phone Number Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_TempPhoneTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    PhoneNo[SIZE_PHONENO+1];

    int iTmp = 0;
    TEMP_PHONE_TABLE *Temp=NULL;        /* Local Pointer to Global Temporary Phone Number Table */


    /* open the input Data file */
    if ( (fp = fopen(glb_MapdStat[IDX_TEMPPHONE_TABLE].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(TEMP_PHONE_TABLE) * iTmp + sizeof(TEMP_PHONE_TABLE);  /* 1 element extra for safety */

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[IDX_TEMPPHONE_TABLE].num_loads)   /* First time loading */
        Temp = glb_TempPhoneHead = (TEMP_PHONE_TABLE *) malloc (iTmp);
    else
        Temp = glb_TempPhoneHead = (TEMP_PHONE_TABLE *) realloc (glb_TempPhoneHead, iTmp);

    if ( Temp == (TEMP_PHONE_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    memset(glb_TempPhoneHead, 0x00, iTmp);
    glb_MapdStat[IDX_TEMPPHONE_TABLE].tot_recs = 0; /* Reset Total Tariff Rates */
    fseek (fp, 0, SEEK_SET);            /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(PhoneNo, 0x00, sizeof (PhoneNo));

        if ( !fgets ((char *)Input, SIZE_LOADREC, fp))   /* read one record */
            break;  /* eof */

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {
            strncpy(PhoneNo, pstr, SIZE_PHONENO);              /* Phone Number */
            Trim_Str(PhoneNo);

            /* Add to Temporary Phone Number Table */
            strcpy(Temp->phoneno, PhoneNo);

            glb_MapdStat[IDX_TEMPPHONE_TABLE].tot_recs++;   /* count */
            Temp++;
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[IDX_TEMPPHONE_TABLE].tot_recs) /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[IDX_TEMPPHONE_TABLE].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[IDX_TEMPPHONE_TABLE].num_loads++;      /* count this loading */

    /* Sort the Temp Phone Table by Phone Number as key */
    qsort((TEMP_PHONE_TABLE *)glb_TempPhoneHead, glb_MapdStat[IDX_TEMPPHONE_TABLE].tot_recs, sizeof(TEMP_PHONE_TABLE), Cmp_TempPhone);

#ifdef SHOW_LOAD
    Temp = glb_TempPhoneHead;
    for (iTmp = 0; iTmp < glb_MapdStat[IDX_TEMPPHONE_TABLE].tot_recs; iTmp++, Temp++) {
                printf ("%s\n", Temp->phoneno);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Cmp_TempPhone (const void *ptr1, const void *ptr2)
{
    /* always SIZE_PHONENO chars are compared */
    return (memcmp(((TEMP_PHONE_TABLE *)ptr1)->phoneno, ((TEMP_PHONE_TABLE *)ptr2)->phoneno, SIZE_PHONENO));
}

/*
** Name     : Check_TempPhone()
**
** Description  : Check Temporary Phone Number from Memory Temporary Phone Number Table.
**        If there is Temporary Phone Number Record in Memory Table then
**          Do Binary Search on the Temporary Phone Number Table.
**          If Matched, return SUCCESS. Else return FAILURE.
**
** Parameters   : char   *PhoneNo  - INPUT     - Pointer to the buffer contains Phone Number.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Check_TempPhone (char *PhoneNo)
{
    int iTmp = 0;
    char    key[SIZE_PHONENO+1];
    TEMP_PHONE_TABLE *Temp = NULL;
    Temp = glb_TempPhoneHead;

    if ( *PhoneNo == '\0' )   /* PhoneNo not passed */
        return FAILURE;

    /* Assemble the key */
    memset(key, 0x00, SIZE_PHONENO+1);
    strcpy(key, PhoneNo);

    /* Do binary search on the DPC Customer Tariff Table */
    Temp = bsearch (key, Temp, glb_MapdStat[IDX_TEMPPHONE_TABLE].tot_recs, sizeof(TEMP_PHONE_TABLE), Cmp_TempPhone);

    if ( Temp == (TEMP_PHONE_TABLE *)NULL)
        return FAILURE;   /* no match found */
    else
        return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_CustTariffTable()
**
** Description  : Loads Customer Tariff Records into Memory Table.
**        Opens the Customer Tariff File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Customer Tariff file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Customer Tariff File.
**        Sorts the Memory table by Phone Number.
**
** Parameters   : int   Idx - INPUT - Index of Customer Tariff Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_CustTariffTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    PhoneNo[SIZE_PHONENO+1];
    char    Tariff[SIZE_TARIFF+1];

    int iTmp = 0;
    CUST_TARIFF_TABLE *Temp=NULL;       /* Local Pointer to Global Customer Tariff Table */


    /* open the input Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(CUST_TARIFF_TABLE) * iTmp + sizeof(CUST_TARIFF_TABLE);    /* 1 element extra for safety */

    /* Identify which (AIS/DPC) memory location to be Used */
    if ( Idx == IDX_CUST_TARIFF)
        Temp = glb_CustTariffHead;
    else
        Temp = glb_DpcCustTariffHead;

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[Idx].num_loads)   /* First time loading */
        Temp = (CUST_TARIFF_TABLE *) malloc (iTmp);
    else                    /* Not First Time */
        Temp = (CUST_TARIFF_TABLE *) realloc (Temp, iTmp);

    if ( Temp == (CUST_TARIFF_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    /* Save the newly allocated memory Pointer */
    if ( Idx == IDX_CUST_TARIFF)
        glb_CustTariffHead = Temp;
    else
        glb_DpcCustTariffHead = Temp;

    memset(Temp, 0x00, iTmp);
    glb_MapdStat[Idx].tot_recs = 0;         /* Reset Customer Tariff records */
    fseek (fp, 0, SEEK_SET);            /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(PhoneNo, 0x00, sizeof (PhoneNo));
        memset(Tariff, 0x00, sizeof (Tariff));

        if ( !fgets ((char *)Input, SIZE_LOADREC, fp))   /* read one record */
            break;  /* eof */

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {

            strncpy(PhoneNo, pstr, SIZE_PHONENO);  /* Phone Number */
            Trim_Str(PhoneNo);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                strncpy(Tariff, pstr, SIZE_TARIFF);    /* Tariff */
                Trim_Str(Tariff);

                /* Add to Memory Cust Tariff Table */
                strcpy(Temp->phoneno, PhoneNo);
                strcpy(Temp->tariff, Tariff);

                glb_MapdStat[Idx].tot_recs++;   /* count */
                Temp++;
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs) /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Reset the Local Pointer to the first record */
    if ( Idx == IDX_CUST_TARIFF)
        Temp = glb_CustTariffHead;
    else
        Temp = glb_DpcCustTariffHead;

    /* Sort the Cust Tariff Table by Phone Number only */
    qsort((CUST_TARIFF_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(CUST_TARIFF_TABLE), Cmp_TariffPNo);

#ifdef SHOW_LOAD
    for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++) {
                printf ("%s %s\n", Temp->phoneno, Temp->tariff);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Cmp_TariffPNo (const void *ptr1, const void *ptr2)
{
    /* always SIZE_PHONENO chars are compared */
    return (memcmp(((CUST_TARIFF_TABLE *)ptr1)->phoneno, ((CUST_TARIFF_TABLE *)ptr2)->phoneno, SIZE_PHONENO));
}


/*
** Name     : Get_Tariff()
**
** Description  : Get Tariff from Memory AIS/DPC Customer Tariff Table.
**        If there is AIS/DPC Customer Tariff Record in Memory Table then
**          Do Binary Search on the AIS/DPC Customer Tariff Table for the given number (matching SIZE_PHONENO)
**          If Matched, then copy the Tariff to the Output parameter.
**
** Parameters   : char *PhoneNo - INPUT     - Pointer to the buffer contains Phone Number.
**        char *Tariff  - OUTPUT    - Pointer to the buffer contains Matched Tariff.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_Tariff (char *PhoneNo, char *Tariff)
{
    int iTmp = 0;
    int Idx = 0;
    CUST_TARIFF_TABLE *Temp = NULL;

    if ( *PhoneNo == '\0' ) /* Phone Number not passed */
        return FAILURE;

    if ( glb_PartId == AISSVC_PARTITION) {
        Temp = glb_CustTariffHead;  /* Use AIS Cust Tariff Table */
        Idx = IDX_CUST_TARIFF;      /* Index of AIS Cust Tariff in Memory Statistics */
    }
    else {
        Temp = glb_DpcCustTariffHead;   /* Use DPC Cust Tariff Table */
        Idx = IDX_DPCCUST_TARIFF;   /* Index of DPC Cust Tariff in Memory Statistics */
    }

    /* Do binary search on the AIS/DPC Customer Tariff Table */
    Temp = bsearch (PhoneNo, Temp, glb_MapdStat[Idx].tot_recs, sizeof(CUST_TARIFF_TABLE), Cmp_TariffPNo);

    if ( Temp == (CUST_TARIFF_TABLE *)NULL)
        return FAILURE;   /* no match found */
    else
        strcpy(Tariff, Temp->tariff);  /* match found - copy the Tariff from Table */

    return SUCCESS;
}

/*
** Name     : Load_VasTable()
**
** Description  : Loads VAS Records into Memory Table.
**        Opens the VAS File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from VAS file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the VAS File.
**        Sorts the Memory table by Cost Code.
**
** Parameters   : int   Idx - INPUT - Index of VAS Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_VasTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    CostCode[SIZE_COSTCODE+1];
    char    CostBandId[SIZE_COSTBAND_ID+1];
    char    VasType;

    int iTmp = 0;
    VAS_TABLE *Temp=NULL;       /* Local Pointer to Global VAS Table */

    /* open the input Data file */
    if ( (fp = fopen(glb_MapdStat[IDX_VAS_TABLE].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(VAS_TABLE) * iTmp + sizeof(VAS_TABLE);    /* 1 element extra for safety */

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[IDX_VAS_TABLE].num_loads) /* First time loading */
        Temp = glb_VasHead = (VAS_TABLE *) malloc (iTmp);
    else
        Temp = glb_VasHead = (VAS_TABLE *) realloc (glb_VasHead, iTmp);

    if ( Temp == (VAS_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    memset(glb_VasHead, 0x00, iTmp);
    glb_MapdStat[IDX_VAS_TABLE].tot_recs = 0;   /* Reset Total VAS Records */
    fseek (fp, 0, SEEK_SET);            /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(CostCode, 0x00, sizeof (CostCode));

        if ( !fgets ((char *)Input, SIZE_LOADREC, fp))   /* read one record */
            break;  /* eof */

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {
            strncpy(CostCode, pstr, SIZE_COSTCODE);    /* Cost Code */
            Trim_Str(CostCode);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL)  {
                strncpy(CostBandId, pstr, SIZE_COSTBAND_ID);   /* Cost Band Id */
                Trim_Str(CostBandId);

                if ( (pstr = strtok((char *)NULL, "#" )) != NULL)    /* Skip Cost Band Name */
                if ( (pstr = strtok((char *)NULL, "#" )) != NULL)  {
                    VasType = pstr[0];

                    /* Add to Cost Code, CostBand Id to VAS Table */
                    Temp->vas_key[0] = VasType;
                    strcpy(Temp->vas_key+1, CostCode);
                    strcpy(Temp->cost_band_id, CostBandId);

                    glb_MapdStat[IDX_VAS_TABLE].tot_recs++; /* count */
                    Temp++;
                }
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[IDX_VAS_TABLE].tot_recs)  /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[IDX_VAS_TABLE].load_stat = TRUE;       /* successfully loaded */
    glb_MapdStat[IDX_VAS_TABLE].num_loads++;        /* count this loading */

    /* Sort the Temp Phone Table by Phone Number as key */
    qsort((VAS_TABLE *)glb_VasHead, glb_MapdStat[IDX_VAS_TABLE].tot_recs, sizeof(VAS_TABLE), Cmp_VasKey);

#ifdef SHOW_LOAD
    Temp = glb_VasHead;
    for (iTmp = 0; iTmp < glb_MapdStat[IDX_VAS_TABLE].tot_recs; iTmp++, Temp++) {
                printf ("%s %s\n", Temp->vas_key, Temp->cost_band_id);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Cmp_VasKey(const void *ptr1, const void *ptr2)
{
    return (strcmp(((VAS_TABLE *)ptr1)->vas_key, ((VAS_TABLE *)ptr2)->vas_key));
}

int Cmp_Vas(const void *ptr1, const void *ptr2)
{
    return (memcmp(((VAS_TABLE *)ptr1)->vas_key, ((VAS_TABLE *)ptr2)->vas_key, strlen(((VAS_TABLE *)ptr1)->vas_key)));
}

/*
** Name     : Get_CostBandId()
**
** Description  : Get Cost Band Id from Memory VAS Table.
**                If there is VAS Record in Memory Table then
**                      Do Binary Search on the VAS Table for the given Vas Type and cost code.
**                      If Matched, then copy the Cost Band Id to the Output parameter.
**
** Parameters   : char VasType     - INPUT  - Vas Type Value.
**        char *CostCode   - INPUT  - Pointer to the buffer contains Cost Code.
**        char *CostBandId - OUTPUT - Pointer to the buffer contains Matched Cost Band Id.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_CostBandId (char VasType, char *CostCode, char *CostBandId)
{
    char    VasKey[SIZE_VASTYPE+SIZE_COSTCODE+1];
    int iTmp = 0;
    VAS_TABLE *Temp = NULL;
    Temp = glb_VasHead;

    if ( *CostCode == '\0' )  /* CostCode not passed */
        return FAILURE;

    VasKey[0] = VasType;
    strcpy(VasKey+1, CostCode);

    /* Do binary search on the VAS Table */
    Temp = bsearch (VasKey, Temp, glb_MapdStat[IDX_VAS_TABLE].tot_recs, sizeof(VAS_TABLE), Cmp_Vas);

    if ( Temp == (VAS_TABLE *)NULL)
        return FAILURE;       /* no match found */
    else
        strcpy(CostBandId, Temp->cost_band_id);    /* match found - copy the Cost Band Id from Table */

    return SUCCESS;
}
#endif  /* REMOVE_TABLE */

/*------------------------------------------------------------------------------------*/

#ifdef  REMOVE_TABLE
/*
** Name     : Load_TariffRateTable()
**
** Description  : Loads DPC Tariff Rate Records into Memory Table.
**        Opens the DPC Tariff Rate File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from DPC Tariff Rate file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the DPC Tariff Rate File.
**        Sorts the Memory table by Network, Tariff, and Zone Type.
**
** Parameters   : int   Idx - INPUT - Index of DPC Tariff Rate Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_TariffRateTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    Network[SIZE_NET+1];
    char    Tariff[SIZE_TARIFF+1];
    char    ZoneType[SIZE_ZTYPE+1];
    char    UnitCode[SIZE_UNIT+1];

    int iTmp = 0;
    TARIFF_RATE_TABLE *Temp=NULL;       /* Local Pointer to Global DPC Tariff Rate Table */


    /* open the input Data file */
    if ( (fp = fopen(glb_MapdStat[IDX_DPCTARIFF_RATE].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')      /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(TARIFF_RATE_TABLE) * iTmp + sizeof(TARIFF_RATE_TABLE);    /* 1 element extra for safety */

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[IDX_DPCTARIFF_RATE].num_loads)    /* First time loading */
        Temp = glb_TariffRateHead = (TARIFF_RATE_TABLE *) malloc (iTmp);
    else
        Temp = glb_TariffRateHead = (TARIFF_RATE_TABLE *) realloc (glb_TariffRateHead, iTmp);

    if ( Temp == (TARIFF_RATE_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    memset(glb_TariffRateHead, 0x00, iTmp);
    glb_MapdStat[IDX_DPCTARIFF_RATE].tot_recs = 0;  /* Reset Total Tariff Rates */
    fseek (fp, 0, SEEK_SET);            /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Network, 0x00, sizeof (Network));
        memset(Tariff, 0x00, sizeof (Tariff));
        memset(ZoneType, 0x00, sizeof (ZoneType));
        memset(UnitCode, 0x00, sizeof (UnitCode));

        if ( !fgets ((char *)Input, SIZE_LOADREC, fp))   /* read one record */
            break;  /* eof */

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {

            strncpy(Network, pstr, SIZE_NET);              /* Network */
            Trim_Str(Network);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                strncpy(Tariff, pstr, SIZE_TARIFF);            /* Tariff */
                Trim_Str(Tariff);

                if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                    strncpy(ZoneType, pstr, SIZE_ZTYPE);       /* Zone Type */

                    if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                        strncpy(UnitCode, pstr, SIZE_UNIT);    /* Unit Code */

                        if ( (pstr = strtok((char *)NULL, "#")) != NULL) {
                            Temp->rate_pm = atof(pstr);     /* Rate per minute */

                            /* Add to DPC Tariff Rate Table (assemble the key) */
                            strcpy(Temp->tariff_key, Network);
                            Pad_Str (Temp->tariff_key, SIZE_NET);
                            strcat(Temp->tariff_key, Tariff);
                            Pad_Str (Temp->tariff_key, SIZE_NET+SIZE_TARIFF);
                            strcat(Temp->tariff_key, ZoneType);
                            Pad_Str (Temp->tariff_key, SIZE_NET+SIZE_TARIFF+SIZE_ZTYPE);
                            strcat(Temp->tariff_key, UnitCode);

                            glb_MapdStat[IDX_DPCTARIFF_RATE].tot_recs++;    /* count */
                            Temp++;
                        }
                    }
                }
            }
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[IDX_DPCTARIFF_RATE].tot_recs) /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[IDX_DPCTARIFF_RATE].load_stat = TRUE;  /* successfully loaded */
    glb_MapdStat[IDX_DPCTARIFF_RATE].num_loads++;       /* count this loading */

    /* Sort the Tariff Rate Table by Network+Tariff+ZoneType+Unit Code as key */
    qsort((TARIFF_RATE_TABLE *)glb_TariffRateHead, glb_MapdStat[IDX_DPCTARIFF_RATE].tot_recs, sizeof(TARIFF_RATE_TABLE), Cmp_TariffKey);

#ifdef SHOW_LOAD
    Temp = glb_TariffRateHead;
    for (iTmp = 0; iTmp < glb_MapdStat[IDX_DPCTARIFF_RATE].tot_recs; iTmp++, Temp++) {
                printf ("%s %f\n", Temp->tariff_key, Temp->rate_pm);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}


int Cmp_TariffKey (const void *ptr1, const void *ptr2)
{
    /* always SIZE_NET+SIZE_TARIFF+SIZE_ZTYPE+SIZE_UNIT chars are compared */
    return (memcmp(((TARIFF_RATE_TABLE *)ptr1)->tariff_key, ((TARIFF_RATE_TABLE *)ptr2)->tariff_key, SIZE_NET+SIZE_TARIFF+SIZE_ZTYPE+SIZE_UNIT));
}


/*
** Name     : Get_DpcTariffRate()
**
** Description  : Get DPC Tariff Rate from Memory DPC Tariff Rate Table.
**        If there is DPC Tariff Rate Record in Memory Table then
**          Do Binary Search on the DPC Tariff Rate Table.
**          If Matched, then copy the DPC Service Rate to the Output parameter.
**
** Parameters   : char   *Network  - INPUT     - Pointer to the buffer contains Network.
**        char   *Tariff   - INPUT     - Pointer to the buffer contains Tariff.
**        char   *ZoneType - INPUT     - Pointer to the buffer contains Zone Type.
**        char   *UnitCode - INPUT     - Pointer to the buffer contains Unit Code.
**        double *Rate_pm  - OUTPUT    - Pointer to the buffer contains Matched Rate_pm.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_DpcTariffRate (char *Network, char *Tariff, char* ZoneType, char* UnitCode, double *Rate_pm)
{
    int iTmp = 0;
    char    key[SIZE_NET+SIZE_TARIFF+SIZE_ZTYPE+SIZE_UNIT+1];
    TARIFF_RATE_TABLE *Temp = NULL;
    Temp = glb_TariffRateHead;

    if ( *Network == '\0' || *Tariff == '\0' || *ZoneType == '\0' || *UnitCode == '\0' )  /* Network or Tariff or Zone Type not passed */
        return FAILURE;

    /* Assemble the key */
    memset(key, 0x00, SIZE_NET+SIZE_TARIFF+SIZE_ZTYPE+SIZE_UNIT+1);
    strcpy(key, Network);
    Pad_Str (key, SIZE_NET);
    strcat(key, Tariff);
    Pad_Str (key, SIZE_NET+SIZE_TARIFF);
    strcat(key, ZoneType);
    Pad_Str (key, SIZE_NET+SIZE_TARIFF+SIZE_ZTYPE);
    strcat(key, UnitCode);

    /* Do binary search on the DPC Customer Tariff Table */
    Temp = bsearch (key, Temp, glb_MapdStat[IDX_DPCTARIFF_RATE].tot_recs, sizeof(TARIFF_RATE_TABLE), Cmp_TariffKey);

    if ( Temp == (TARIFF_RATE_TABLE *)NULL)
        return FAILURE;   /* no match found */
    else
        *Rate_pm = (double) (Temp->rate_pm);    /* Match found - copy the rate_pm value */

    return SUCCESS;
}
#endif  /* REMOVE_TABLE */

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_NpbnTable()
**
** Description  : Loads Number Port by Nature (Port 1-2-Call to GSM) into Memory Table.
**        Opens the Number Port by Nature File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Number Port by Nature file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Number Port by Nature File.
**        Sorts the Memory table by Phone Number.
**
** Parameters   : int   Idx - INPUT - Index of Number Port by Nature Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_NpbnTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    Mob_Number[SIZE_PHONENO+1];
    char    Start_Eff_Date[SIZE_DATETIME+1];
    char    End_Eff_Date[SIZE_DATETIME+1];
    char    Network[SIZE_NET+1];

    int iTmp = 0;
    NPBN_TABLE *Temp=NULL;      /* Local Pointer to Number Port by Nature Table */

    /* open input Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')  /* Comment Line not counted */
            iTmp++;
    }
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(NPBN_TABLE) * iTmp + sizeof(NPBN_TABLE);      /* 1 element extra for safety */

    Temp = glb_NpbnHead;

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[Idx].num_loads)   /* First time loading */
        Temp = (NPBN_TABLE *) malloc (iTmp);
    else                    /* Not First time */
        Temp = (NPBN_TABLE *) realloc (Temp, iTmp);

    if ( Temp == (NPBN_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    /* Save the newly allocated memory Pointer */
    glb_NpbnHead = Temp;

    memset(Temp, 0x00, iTmp);
    glb_MapdStat[Idx].tot_recs = 0; /* Total Mobile Network Codes */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Mob_Number, 0x00, sizeof (Mob_Number));
        memset(Start_Eff_Date, 0x00, sizeof (Start_Eff_Date));
        memset(End_Eff_Date, 0x00, sizeof (End_Eff_Date));
        memset(Network, 0x00, sizeof (Network));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {

            strncpy(Mob_Number, pstr, SIZE_PHONENO);   /* Mobile Number */
            Trim_Str(Mob_Number);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                strncpy(Start_Eff_Date, pstr, SIZE_DATETIME);  /* Effective Date */
                Trim_Str(Start_Eff_Date);

                if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                    strncpy(End_Eff_Date, pstr, SIZE_DATETIME);
                    Trim_Str(End_Eff_Date);

                    if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                        if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                            strncpy(Network, pstr, SIZE_NET);
                            Trim_Str(Network);

                            strcpy(Temp->mob_number, Mob_Number);
                            strcpy(Temp->start_eff_date, Start_Eff_Date);
                            strcpy(Temp->end_eff_date, End_Eff_Date);
                            strcpy(Temp->network, Network);

                            glb_MapdStat[Idx].tot_recs++;   /* count */
                            Temp++;
                        }
                    }
                }
            }
        }

    }   /* end of while */
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs)    /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Reset the Local Pointer to the first record */
    Temp = glb_NpbnHead;

    qsort((NPBN_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(NPBN_TABLE), Cmp_Npbn);

#ifdef SHOW_LOAD
    for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++) {
                printf ("%s %s %s %s\n",Temp->mob_number, Temp->start_eff_date, Temp->end_eff_date, Temp->network);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Cmp_Npbn (const void *ptr1, const void *ptr2)
{
    return (memcmp(((NPBN_TABLE *)ptr1)->mob_number, ((NPBN_TABLE *)ptr2)->mob_number, SIZE_PHONENO));
}


/*
** Name     : Get_NpbnPort()
**
** Description  : Get Network from Memory Number Port by Nature Table.
**        If there is Number Port by Nature Record in Memory Table then
**          Do Binary Search on the Number Port by Nature Table for the given number (matching SIZE_PHONENO)
**          If Matched, then copy the Network to the Output parameter.
**
** Parameters   : char *Nport - INPUT       - Pointer to the buffer contains Ported Number.
**        char *Txn_DateTime - INPUT - Pointer to the buffer contains Transaction Date-time.
**        char *Net   - OUTPUT      - Pointer to the buffer contains Matched Network.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_NpbnPort (char *Nport, char *Txn_DateTime, char *Net)
{
    NPBN_TABLE *Temp = NULL;
    int     Idx = 0;

    if ( *Nport == '\0' ) /* mobile number not passed */
        return FAILURE;

    Temp = glb_NpbnHead;
    Idx = IDX_NPBN_TABLE;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (Nport, Temp, glb_MapdStat[Idx].tot_recs, sizeof(NPBN_TABLE), Cmp_Npbn);

    if ( Temp == (NPBN_TABLE *)NULL) {       /* no match found in Number Port by Nature Table */
        return FAILURE;
    }
    else {
        /* match found - copy the Network from Table */
        if ( memcmp(Txn_DateTime, Temp->start_eff_date, SIZE_DATETIME) >= 0 &&
             memcmp (Txn_DateTime, Temp->end_eff_date, SIZE_DATETIME) <= 0 ) {  /* Txn Date Between Effective Date */
            if ( !strcmp(Temp->network, "GSM") )    /* Converted to GSM Between Effect Date */
                strcpy(Net, "GSM");                /* Number has been ported to GSM */
            else                                    /* Converted to 1-2-Call Between Effect Date */
                strcpy(Net, "PPS");                /* Number has been ported to 1-2-Call */
        }
        else  { /* Out of Effective Period */
            if ( !strcmp(Temp->network, "GSM") )    /* Converted to GSM Between Effect Date */
                strcpy(Net, "PPS");                 /* Number ported to GSM has been expired return to 1-2-Call */
            else                                    /* Converted to 1-2-Call Between Effect Date */
                strcpy(Net, "GSM");                 /* Number ported to 1-2-Call has been expired return to GSM */
        }
    }

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_BillRegTable()
**
** Description  : Loads Bill Register into Memory Table.
**        Opens the Bill Register File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Bill Register file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Bill Register File.
**        Sorts the Memory table by Msisdn Number.
**
** Parameters   : int   Idx - INPUT - Index of Bill Register Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_BillRegTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    //char    *pstr=NULL;
    char    Msisdn[SIZE_PHONENO+2+1];
    char    BillProv[SIZE_PROVCODE+1];

    int iTmp = 0;
    BILL_REG_TABLE *Temp=NULL;      /* Local Pointer to Bill Register Table */

    /* open input Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')  /* Comment Line not counted */
            iTmp++;
    }
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(BILL_REG_TABLE) * iTmp + sizeof(BILL_REG_TABLE);      /* 1 element extra for safety */

    Temp = glb_BillRegHead;

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[Idx].num_loads)   /* First time loading */
        Temp = (BILL_REG_TABLE *) malloc (iTmp);
    else                    /* Not First time */
        Temp = (BILL_REG_TABLE *) realloc (Temp, iTmp);

    if ( Temp == (BILL_REG_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    /* Save the newly allocated memory Pointer */
    glb_BillRegHead = Temp;

    memset(Temp, 0x00, iTmp);
    glb_MapdStat[Idx].tot_recs = 0; /* Total Mobile Network Codes */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(Msisdn, 0x00, sizeof (Msisdn));
        memset(BillProv, 0x00, sizeof (BillProv));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        strncpy(Msisdn, Input, 11);
        strncpy(BillProv, Input+11, SIZE_PROVCODE);
        Trim_Str(Msisdn);
        Trim_Str(BillProv);

        if ( strlen(Msisdn) < SIZE_PHONENO)
            continue;

        strcpy(Temp->msisdn, Msisdn);
        strcpy(Temp->bill_prov, BillProv);

        glb_MapdStat[Idx].tot_recs++;   /* count */
        Temp++;

    }   /* end of while */
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs)    /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Reset the Local Pointer to the first record */
    Temp = glb_BillRegHead;

    qsort((BILL_REG_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(BILL_REG_TABLE), Cmp_BillReg);

#ifdef SHOW_LOAD
    for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++) {
                printf ("%s|%s\n", Temp->msisdn, Temp->bill_prov);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}


int Cmp_BillReg (const void *ptr1, const void *ptr2)
{
    return (memcmp(((BILL_REG_TABLE *)ptr1)->msisdn, ((BILL_REG_TABLE *)ptr2)->msisdn, SIZE_PHONENO));
}


/*
** Name     : Get_BillProvince()
**
** Description  : Get Bill Province from Memory Bill Register Table.
**        If there is Bill Province Record in Memory Table then
**          Do Binary Search on the Bill Province Table for the given msisdn (matching SIZE_PHONENO)
**          If Matched, then copy the Network to the Output parameter.
**
** Parameters   : char *Msisdn   - INPUT       - Pointer to the buffer contains Msisdn.
**        char *BillProv - OUTPUT      - Pointer to the buffer contains Matched Bill Province.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_BillProvince (char *Msisdn, char *BillProv)
{
    BILL_REG_TABLE *Temp = NULL;
    int     Idx = 0;

    if ( *Msisdn == '\0' ) /* Msisdn number not passed */
        return FAILURE;

    Temp = glb_BillRegHead;
    Idx = IDX_BILLREG_TABLE;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (Msisdn, Temp, glb_MapdStat[Idx].tot_recs, sizeof(BILL_REG_TABLE), Cmp_BillReg);

    if ( Temp == (BILL_REG_TABLE *)NULL) {       /* no match found in Bill Register Table */
        return FAILURE;
    }
    else {
        strcpy(BillProv, Temp->bill_prov);
    }
    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_AdjGrpTable()
**
** Description  : Loads Adjacent Group into Memory Table.
**        Opens the Adjacent Group File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Adjacent Group file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Adjacent Group File.
**        Sorts the Memory table by Bill Province.
**
** Parameters   : int   Idx - INPUT - Index of Adjacent Group Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_AdjGrpTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    BillProv[SIZE_PROVCODE+1];
    char    AdjGrp[SIZE_ADJGRP+1];

    int iTmp = 0;
    ADJ_GRP_TABLE *Temp=NULL;       /* Local Pointer to Adjacent Group Table */

    /* open input Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')  /* Comment Line not counted */
            iTmp++;
    }
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(ADJ_GRP_TABLE) * iTmp + sizeof(ADJ_GRP_TABLE);        /* 1 element extra for safety */

    Temp = glb_AdjGrpHead;

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[Idx].num_loads)   /* First time loading */
        Temp = (ADJ_GRP_TABLE *) malloc (iTmp);
    else                    /* Not First time */
        Temp = (ADJ_GRP_TABLE *) realloc (Temp, iTmp);

    if ( Temp == (ADJ_GRP_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    /* Save the newly allocated memory Pointer */
    glb_AdjGrpHead = Temp;

    memset(Temp, 0x00, iTmp);
    glb_MapdStat[Idx].tot_recs = 0; /* Total Mobile Network Codes */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(BillProv, 0x00, sizeof (BillProv));
        memset(AdjGrp, 0x00, sizeof (AdjGrp));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {

            strncpy(BillProv, pstr, SIZE_PROVCODE);    /* Bill Register Province */
            Trim_Str(BillProv);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                strncpy(AdjGrp, pstr, SIZE_ADJGRP);    /* Adjacent Group */
                Trim_Str(AdjGrp);

                strcpy(Temp->bill_prov, BillProv);
                strcpy(Temp->adj_grp, AdjGrp);

                glb_MapdStat[Idx].tot_recs++;   /* count */
                Temp++;
            }
        }
    }   /* end of while */
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs)    /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Reset the Local Pointer to the first record */
    Temp = glb_AdjGrpHead;

    qsort((ADJ_GRP_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(ADJ_GRP_TABLE), Cmp_AdjGrp);

#ifdef SHOW_LOAD
    for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++) {
                printf ("%s %s\n",Temp->bill_prov, Temp->adj_grp);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}


int Cmp_AdjGrp (const void *ptr1, const void *ptr2)
{
    return (memcmp(((ADJ_GRP_TABLE *)ptr1)->bill_prov, ((ADJ_GRP_TABLE *)ptr2)->bill_prov, SIZE_PROVCODE));
}


/*
** Name     : Get_AdjGrp()
**
** Description  : Get Adjacent Group from Adjacent Group Table.
**        If there is Adjacent Group Record in Memory Table then
**          Do Binary Search on the Adjacent Group Table for the given Bill Province (matching SIZE_PROVCODE)
**          If Matched, then copy the Adjacent Group to the Output parameter.
**
** Parameters   : char *BillProv - INPUT       - Pointer to the buffer contains Bill Province Code.
**        char *AdjGrp   - OUTPUT      - Pointer to the buffer contains Matched Adjacent Group.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_AdjGrp (char *BillProv, char *AdjGrp)
{
    ADJ_GRP_TABLE *Temp = NULL;
    int     Idx = 0;

    if ( *BillProv == '\0' ) /* Bill Province not passed */
        return FAILURE;

    Temp = glb_AdjGrpHead;
    Idx = IDX_ADJGRP_TABLE;

    /* Do binary search on the Adjacent Group Table */
    Temp = bsearch (BillProv, Temp, glb_MapdStat[Idx].tot_recs, sizeof(ADJ_GRP_TABLE), Cmp_AdjGrp);

    if ( Temp == (ADJ_GRP_TABLE *)NULL) {        /* no match found in Number Port by Nature Table */
        return FAILURE;
    }
    else {
        strcpy(AdjGrp, Temp->adj_grp);
    }

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/

/*
** Name     : Load_BillAreaTable()
**
** Description  : Loads Bill Area into Memory Table.
**        Opens the Bill Area File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Bill Area file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Bill Area File.
**        Sorts the Memory table by Phone Number.
**
** Parameters   : int   Idx - INPUT - Index of Bill Area Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_BillAreaTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    CellArea[SIZE_CAREA+1];
    char    BillProv[SIZE_PROVCODE+1];

    int iTmp = 0;
    BILL_AREA_TABLE *Temp=NULL;     /* Local Pointer to Bill Area Table */

    /* open input Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')  /* Comment Line not counted */
            iTmp++;
    }
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(BILL_AREA_TABLE) * iTmp + sizeof(BILL_AREA_TABLE);    /* 1 element extra for safety */

    Temp = glb_BillAreaHead;

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[Idx].num_loads)   /* First time loading */
        Temp = (BILL_AREA_TABLE *) malloc (iTmp);
    else                    /* Not First time */
        Temp = (BILL_AREA_TABLE *) realloc (Temp, iTmp);

    if ( Temp == (BILL_AREA_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    /* Save the newly allocated memory Pointer */
    glb_BillAreaHead = Temp;

    memset(Temp, 0x00, iTmp);
    glb_MapdStat[Idx].tot_recs = 0; /* Total Mobile Network Codes */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(CellArea, 0x00, sizeof (CellArea));
        memset(BillProv, 0x00, sizeof (BillProv));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "#" )) != NULL) {

            strncpy(CellArea, pstr, SIZE_CAREA);   /* Cell Area */
            Trim_Str(CellArea);

            if ( (pstr = strtok((char *)NULL, "#" )) != NULL) {
                strncpy(BillProv, pstr, SIZE_PROVCODE);    /* Bill Province */
                Trim_Str(BillProv);

                strcpy(Temp->cell_area, CellArea);
                strcpy(Temp->bill_prov, BillProv);

                glb_MapdStat[Idx].tot_recs++;   /* count */
                Temp++;
            }
        }

    }   /* end of while */
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs)    /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Reset the Local Pointer to the first record */
    Temp = glb_BillAreaHead;

    qsort((BILL_AREA_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(BILL_AREA_TABLE), Cmp_BillArea);

#ifdef SHOW_LOAD
    for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++) {
                printf ("%s %s\n",Temp->cell_area, Temp->bill_prov);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}


int Cmp_BillArea (const void *ptr1, const void *ptr2)
{
    return (memcmp(((BILL_AREA_TABLE *)ptr1)->cell_area, ((BILL_AREA_TABLE *)ptr2)->cell_area, SIZE_CAREA));
}


/*
** Name     : Get_BillArea()
**
** Description  : Get Bill Province from Memory Bill Area Table.
**        If there is Bill Area Record in Memory Table then
**          Do Binary Search on the Bill Area Table for the given Cell Area (matching SIZE_CAREA)
**          If Matched, then copy the Bill Province to the Output parameter.
**
** Parameters   : char *CellArea - INPUT  - Pointer to the buffer contains Cell Area.
**        char *BillProv - OUTPUT - Pointer to the buffer contains Matched Billing Province.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_BillArea (char *CellArea, char *BillProv)
{
    BILL_AREA_TABLE *Temp = NULL;
    int     Idx = 0;

    if ( *CellArea == '\0' ) /* mobile number not passed */
        return FAILURE;

    Temp = glb_BillAreaHead;
    Idx = IDX_BILLAREA_TABLE;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (CellArea, Temp, glb_MapdStat[Idx].tot_recs, sizeof(BILL_AREA_TABLE), Cmp_BillArea);

    if ( Temp == (BILL_AREA_TABLE *)NULL) {      /* no match found in Bill Area Table */
        return FAILURE;
    }
    else {
        strcpy(BillProv, Temp->bill_prov);
    }
    return SUCCESS;
}

/*
** Name     : Validate_AdjArea()
**
** Description  : Lookup Bill Register Table by Using PhoneNo to get Bill Register Province Code.
**        If not matched then return FAILURE.
**        Lookup Cell Area Table by Using CellArea to get CellArea Province Code.
**        If not matched then return FAILURE.
**        Lookup Adjacent Group Table by Using Bill Register Province Code to get Bill Register Adjacent Group.
**        If not matched then return FAILURE.
**        Lookup Adjacent Group Table by Using CellArea Province Code to get CellArea Adjacent Group.
**        If not matched then return FAILURE.
**        Compare Both Adjacent Group (Bill Register Adjacent Group and CellArea Adjacent Group)
**
** Parameters   : char *PhoneNo  - INPUT  - Pointer to the buffer contains Phone Number.
**        char *CellArea - INPUT  - Pointer to the buffer contains Cell Area.
**        int  *Result   - OUTPUT - Pointer to the buffer contains Validate Adjacent Area Result.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Validate_AdjArea (char *PhoneNo, char *CellArea, int *Result)
{
    char    bill_prov[SIZE_PROVCODE+1];
    char    cell_prov[SIZE_PROVCODE+1];
    char    bill_adjgrp[SIZE_ADJGRP+1];
    char    cell_adjgrp[SIZE_ADJGRP+1];

    memset(bill_prov, 0x00, sizeof (bill_prov));
    memset(cell_prov, 0x00, sizeof (cell_prov));
    memset(bill_adjgrp, 0x00, sizeof (bill_adjgrp));
    memset(cell_adjgrp, 0x00, sizeof (cell_adjgrp));

    if ( Get_BillProvince (PhoneNo, bill_prov) ) {    /* Failure */
        sprintf(glb_MsgText, "cannot Get Bill Province: PhoneNo=%s", PhoneNo);
        return FAILURE;
    }

    if ( Get_BillArea (CellArea, cell_prov) ) {       /* Failure */
        sprintf(glb_MsgText, "cannot Get Bill Province: CellArea=%s", CellArea);
        return FAILURE;
    }

    if ( Get_AdjGrp (bill_prov, bill_adjgrp) ) {      /* Failure */
        sprintf(glb_MsgText, "cannot Get Bill Register Adjacent Group: PhoneNo=%s, Bill Province=%s", PhoneNo, bill_prov);
        return FAILURE;
    }

    if ( Get_AdjGrp (cell_prov, cell_adjgrp) ) {      /* Failure */
        sprintf(glb_MsgText, "cannot Get CellArea Adjacent Group: CellArea=%s, Cell Province=%s", CellArea, cell_prov);
        return FAILURE;
    }

    *Result = strncmp(bill_adjgrp, cell_adjgrp, SIZE_ADJGRP);

    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/
/* Intorduce CDG CDR Type. Added Bearer Table - by Kawee on 02-Jun-2005 */

/*
** Name     : Load_BearerTable()
**
** Description  : Loads Bearer into Memory Table.
**        Opens the Bearer File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Reads the Records from Bearer file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Bearer Area File.
**        Sorts the Memory table by Sgwid.
**
** Parameters   : int   Idx - INPUT - Index of Bearer Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_BearerTable (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];

    char    *pstr=NULL;
    char    *pchData;
    char    *pchSgwid, *pchBearer;
    int iSizeSgwid, iSizeBearer;
    int iFldCnt, iFldLen, iRecCnt;
    int iSizeHead, iSizeData, iSizeRec;
    int i;

    int iTmp = 0;
    BEARER_TABLE *Temp=NULL;        /* Local Pointer to Bearer Area Table */

    /* open input Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    iSizeSgwid = 0;
    iSizeBearer = 0;
    iRecCnt = 0;
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input == '#')  /* Comment Line not counted */
            continue;

        iFldCnt = 0;
        while ( 1 ) {
            if ( !iFldCnt)
                pstr = Get_StrTok (Input, '|');
            else
                pstr = Get_StrTok ((char *)NULL, '|');

            if ( !pstr)  /* No more Field */
                break;

            iFldCnt++;
            Trim_Str(pstr);
            iFldLen = strlen(pstr);
            switch (iFldCnt) {
                case 1:
                    if ( iFldLen > iSizeSgwid)
                        iSizeSgwid = iFldLen;
                    break;
                case 2:
                    if ( iFldLen > iSizeBearer)
                        iSizeBearer = iFldLen;
                    break;
            }
        }
        if ( iFldCnt < 2)
            continue;

        iRecCnt++;
    }
    if ( !iRecCnt)   /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iSizeHead = sizeof (BEARER_TABLE) * iRecCnt;
    iSizeRec = iSizeSgwid + iSizeBearer + 2;
    iSizeData = iRecCnt * iSizeRec;
    iTmp = iSizeHead + iSizeData;

    Temp = glb_BearerHead;

    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[Idx].num_loads)   /* First time loading */
        Temp = (BEARER_TABLE *) malloc (iTmp);
    else                    /* Not First time */
        Temp = (BEARER_TABLE *) realloc (Temp, iTmp);

    if ( Temp == (BEARER_TABLE *)NULL)
        return LOAD_TABLE_FULL;

    memset(Temp, 0x00, iTmp);
    pchData = ((char *)Temp) + iSizeHead;
    for (i = 0; i<iRecCnt; i++) {
        Temp[i].pchSgwid = pchData + (iSizeRec * i);
        Temp[i].pchBearer = Temp[i].pchSgwid + iSizeSgwid + 1;
    }

    /* Save the newly allocated memory Pointer */
    glb_BearerHead = Temp;

    glb_MapdStat[Idx].tot_recs = 0; /* Total Mobile Network Codes */
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    iRecCnt = 0;
    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '#')      /* Comment Line */
            continue;       /* No need to Parse */

        iFldCnt = 0;
        while ( 1 ) {
            if ( !iFldCnt)
                pstr = Get_StrTok (Input, '|');
            else
                pstr = Get_StrTok ((char *)NULL, '|');

            if ( !pstr)  /* No more Field */
                break;

            iFldCnt++;
            Trim_Str(pstr);
            switch (iFldCnt) {
                case 1:
                    pchSgwid = pstr;
                    break;
                case 2:
                    pchBearer = pstr;
                    break;
            }
        }
        if ( iFldCnt < 2)
            continue;

        strcpy(Temp[iRecCnt].pchSgwid, pchSgwid);
        strcpy(Temp[iRecCnt].pchBearer, pchBearer);
        iRecCnt++;
        glb_MapdStat[Idx].tot_recs++;
    }   /* end of while */
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs)    /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Reset the Local Pointer to the first record */
    Temp = glb_BearerHead;

    qsort((BEARER_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(BEARER_TABLE), Cmp_Bearer);

#ifdef SHOW_LOAD
    for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++) {
        printf ("%s %s\n",Temp[iTmp].pchSgwid, Temp[iTmp].pchBearer);
    }
    Deb_Msg(glb_MsgText);
#endif

    return SUCCESS;
}

int Cmp_Bearer (const void *ptr1, const void *ptr2)
{
    return (strcmp(((BEARER_TABLE *)ptr1)->pchSgwid, ((BEARER_TABLE *)ptr2)->pchSgwid));
}


/*
** Name     : Get_Bearer()
**
** Description  : Get Bearer from Memory Bearer Table.
**        If there is Bearer Record in Memory Table then
**              Do Binary Search on the Bearer Table for the given Sgwid (matching whole word)
**          If Matched, then copy the Bearer to the Output parameter.
**
** Parameters   : char *pchSgwid  - INPUT  - Pointer to the buffer contains Sgwid.
**        char *pchBearer - OUTPUT - Pointer to the buffer contains Matched Bearer.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_Bearer (char *pchSgwid, char *pchBearer)
{
    BEARER_TABLE *Temp = NULL;
    BEARER_TABLE Key;
    int     Idx = 0;

    if ( *pchSgwid == '\0' ) /* mobile number not passed */
        return FAILURE;

    Temp = glb_BearerHead;
    Idx = IDX_BEARER_TABLE;
    Key.pchSgwid = pchSgwid;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(BEARER_TABLE), Cmp_Bearer);

    if ( Temp == (BEARER_TABLE *)NULL) {     /* no match found in Bearer Table */
        return FAILURE;
    }
    else {
        strcpy(pchBearer, Temp->pchBearer);
    }
    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/
/* Intorduce CDG CDR Type. Added Cost Code Table - by Kawee on 02-Jun-2005 */

int Cmp_CostCodeTable (const void *ptr1, const void *ptr2)
{
    /*
    ** ORDER SEQUENCE
    ** 1. Banding Model Id  -> by assending
    ** 2. Cost Code     -> by assending
    ** 3. Cost Band Id  -> by dessending
    ** REMARK: if Banding Model Id and Cost Code is equal then copy the max Cost Band Id
    ** to both record.
    */
    int rv;
    rv = strcmp(((COSTCODE_TABLE *)ptr1)->banding_model_id, ((COSTCODE_TABLE *)ptr2)->banding_model_id);
    if ( rv)     /* Not Equal */
        return rv;
    rv = strcmp(((COSTCODE_TABLE *)ptr1)->costcode, ((COSTCODE_TABLE *)ptr2)->costcode);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((COSTCODE_TABLE *)ptr1)->cost_band_id, ((COSTCODE_TABLE *)ptr2)->cost_band_id);
    return (rv * -1);
}

int Cmp_CostCode (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((COSTCODE_TABLE *)ptr1)->banding_model_id, ((COSTCODE_TABLE *)ptr2)->banding_model_id);
    if ( rv)     /* Not Equal */
        return rv;
    return (strcmp(((COSTCODE_TABLE *)ptr1)->costcode, ((COSTCODE_TABLE *)ptr2)->costcode));
}


/*
** Name     : Get_RmCostBandIdExact()
**
** Description  : Get CostBandId from Memory CostCode Table.
**        If there is Cost Code Record in Memory Table then
**              Do Binary Search on the Cost Code Table for the given CostCode (matching whole word)
**          If Matched, then copy the CostBandId to the Output parameter.
**
** Parameters   : char *banding_model_id - INPUT - Pointer to the buffer contains Banding Model Id.
**        char *costcode  - INPUT  - Pointer to the buffer contains Cost Code.
**        char *cost_band_id - OUTPUT - Pointer to the buffer contains Matched Cost Band Id.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/
int Get_RmCostBandIdExact (char *banding_model_id, char *costcode, char *cost_band_id, char *vas_name)
{
    COSTCODE_TABLE *Temp = NULL;
    COSTCODE_TABLE Key;
    int     Idx = 0;
    char    szTemp[128];

    memset(gszCostcode_Desc, 0x00, sizeof(gszCostcode_Desc));
    memset(gszCostcode_Name, 0x00, sizeof(gszCostcode_Name));

    if ( *costcode == '\0' ) /* costcode value not passed */
        return FAILURE;

    Temp = glb_CostCodeHead;
    Idx = IDX_COSTCODE_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.banding_model_id = banding_model_id;
    Key.costcode = costcode;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(COSTCODE_TABLE), Cmp_CostCode);

    if ( Temp == (COSTCODE_TABLE *)NULL) {       /* no match found in Cost Code Table */
        return FAILURE;
    }
    else {
        strcpy(cost_band_id, Temp->cost_band_id);
        sprintf(szTemp, "%s:%s", Temp->costcode_name, Temp->costcode_desc);
        strcpy(gszCostcode_Desc, Temp->costcode_desc);
        strcpy(gszCostcode_Name, Temp->costcode_name);
        strncpy(vas_name, szTemp, SIZE_VAS_NAME);
    }
    return SUCCESS;
}


/*
** Name     : Get_RmCostGroupId()
**
** Description  : Get CostGroupId from Memory CostCode Table.
**        If there is Cost Code Record in Memory Table then
**              Do Binary Search on the Cost Code Table for the given CostCode (matching whole word)
**          If Matched, then copy the CostGroupId to the Output parameter.
**
** Parameters   : char *banding_model_id - INPUT - Pointer to the buffer contains Banding Model Id.
**        char *costcode  - INPUT  - Pointer to the buffer contains Cost Code.
**        char *costgroup_id - OUTPUT - Pointer to the buffer contains Matched CostGroup Id.
**        char *costcode_name - OUTPUT - Pointer to the buffer contains Matched Costcode Name.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_RmCostGroupIdExact (char *banding_model_id, char *costcode, char *costgroup_id, char *costcode_name)
{
    COSTCODE_TABLE *Temp = NULL;
    COSTCODE_TABLE Key;
    int     Idx = 0;

    if ( *costcode == '\0' ) /* costcode value not passed */
        return FAILURE;

    Temp = glb_CostCodeHead;
    Idx = IDX_COSTCODE_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.banding_model_id = banding_model_id;
    Key.costcode = costcode;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(COSTCODE_TABLE), Cmp_CostCode);

    if ( Temp == (COSTCODE_TABLE *)NULL) {       /* no match found in Cost Code Table */
        return FAILURE;
    }
    else {
        strcpy(costgroup_id, Temp->costgroup_id);
        strncpy(costcode_name, Temp->costcode_name, SIZE_COSTCODE_NAME);
    }
    return SUCCESS;
}

/* Added below function by Kawee on 19-Apr-2007 */
/*
** Name     : Lookup_CostcodeExact()
**
** Description  : Get CostGroupId, CostBandId, and VasName from Memory CostCode Table.
**        If there is Cost Code Record in Memory Table then
**              Do Binary Search on the Cost Code Table for the given BandingModelId, and CostCode (matching whole word)
**          If Matched, then copy the CostGroupId, CostBandId and VasName to the Output parameter.
**
** Parameters   : char *banding_model_id - INPUT - Pointer to the buffer contains Banding Model Id.
**        char *costcode         - INPUT  - Pointer to the buffer contains Cost Code.
**        char *costgroup_id     - OUTPUT - Pointer to the buffer contains Matched CostGroup Id.
**        char *cost_band_id     - OUTPUT - Pointer to the buffer contains Matched CostBand Id.
**        char *vas_name         - OUTPUT - Pointer to the buffer contains Matched CostCostName+CostcodeDesc.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/
int Lookup_CostcodeExact (char *banding_model_id, char *costcode, char *costgroup_id, char *cost_band_id, char *vas_name)
{
    COSTCODE_TABLE *Temp = NULL;
    COSTCODE_TABLE Key;
    int     Idx = 0;
    char    szTemp[128];

    if ( *costcode == '\0' ) /* costcode value not passed */
        return FAILURE;

    Temp = glb_CostCodeHead;
    Idx = IDX_COSTCODE_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.banding_model_id = banding_model_id;
    Key.costcode = costcode;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(COSTCODE_TABLE), Cmp_CostCode);

    if ( Temp == (COSTCODE_TABLE *)NULL) {       /* no match found in Cost Code Table */
        return FAILURE;
    }
    else {
        /* strcpy(costgroup_id, Temp->costgroup_id); */
        /* strcpy(cost_band_id, Temp->cost_band_id); */
        strncpy(costgroup_id, Temp->costgroup_id, SIZE_COSTGROUP_ID);
        strncpy(cost_band_id, Temp->cost_band_id, SIZE_COSTBAND_ID);
        sprintf(szTemp, "%s:%s", Temp->costcode_name, Temp->costcode_desc);
        strncpy(vas_name, szTemp, SIZE_COSTCODE_NAME);
        /* strncpy(vas_name, szTemp, SIZE_VAS_NAME); */
    }
    return SUCCESS;
}


int Get_RmCostBandId (char *banding_model_id, char *costcode, char *cost_band_id)
{
    int costcode_len = 0;
    char    temp_costcode[SIZE_COSTCODE+1];
    char    vas_name[SIZE_VAS_NAME+1];  /* Add Vas_Name field for USC and CDG Event Type - by Kawee on 12-Mar-2007 */

    if ( *costcode == '\0' ) /* costcode value not passed */
        return FAILURE;

    costcode_len = strlen(costcode);

    while(costcode_len > 1) {
        memset(temp_costcode, 0x00, sizeof(temp_costcode));
        memset(vas_name, 0x00, sizeof(vas_name));
        strncpy(temp_costcode, costcode, costcode_len);

        if ( !Get_RmCostBandIdExact(banding_model_id, temp_costcode, cost_band_id, vas_name))    /* SUCCESS */
            return SUCCESS;
        costcode_len--;
    }

    return FAILURE;
}

/* Add Vas_Name field for USC and CDG Event Type - by Kawee on 12-Mar-2007 */
int Get_RmCostBandId2 (char *banding_model_id, char *costcode, char *cost_band_id, char *vas_name)
{
    int costcode_len = 0;
    char temp_costcode[SIZE_COSTCODE+1];

    if ( *costcode == '\0' ) /* costcode value not passed */
        return FAILURE;

    costcode_len = strlen(costcode);

    while(costcode_len > 1) {
        memset(temp_costcode, 0x00, sizeof(temp_costcode));
        strncpy(temp_costcode, costcode, costcode_len);

        if ( !Get_RmCostBandIdExact(banding_model_id, temp_costcode, cost_band_id, vas_name))    /* SUCCESS */
            return SUCCESS;
        costcode_len--;
    }

    return FAILURE;
}

int Get_RmCostGroupId (char *banding_model_id, char *costcode, char *costgroup_id)
{
    int costcode_len = 0;
    char temp_costcode[SIZE_COSTCODE+1];
    char temp_costcode_name[SIZE_COSTCODE_NAME+1];

    if ( *costcode == '\0' ) /* costcode value not passed */
        return FAILURE;

    costcode_len = strlen(costcode);

    while(costcode_len > 1) {
        memset(temp_costcode, 0x00, sizeof(temp_costcode));
        memset(temp_costcode_name, 0x00, sizeof(temp_costcode_name));
        strncpy(temp_costcode, costcode, costcode_len);

        if ( !Get_RmCostGroupIdExact(banding_model_id, temp_costcode, costgroup_id, temp_costcode_name)) /* SUCCESS */
            return SUCCESS;

        costcode_len--;
    }

    return FAILURE;
}

/* Added Get_RmCostGroupId2 by Kawee on 07-Nov-2007 */
int Get_RmCostGroupId2 (char *banding_model_id, char *costcode, char *costgroup_id, char *costcode_name)
{
    int costcode_len = 0;
    char temp_costcode[SIZE_COSTCODE+1];
    //char temp_costcode_name[SIZE_VAS_NAME+1];

    if ( *costcode == '\0' ) /* costcode value not passed */
        return FAILURE;

    costcode_len = strlen(costcode);

    while(costcode_len > 1) {
        memset(temp_costcode, 0x00, sizeof(temp_costcode));
        strncpy(temp_costcode, costcode, costcode_len);

        if ( !Get_RmCostGroupIdExact(banding_model_id, temp_costcode, costgroup_id, costcode_name))  /* SUCCESS */
            return SUCCESS;

        costcode_len--;
    }

    return FAILURE;
}

/* Added below function by Kawee on 19-Apr-2007 */
int Lookup_Costcode (char *banding_model_id, char *costcode, char *costgroup_id, char *cost_band_id, char *vas_name)
{
    int costcode_len = 0;
    char temp_costcode[SIZE_COSTCODE+1];
    /* Removed below by Kawee on 22-Sep-2008 */
    /* char vas_name[SIZE_VAS_NAME+1]; */   /* Add Vas_Name field for USC and CDG Event Type - by Kawee on 12-Mar-2007 */

    if ( *costcode == '\0' ) /* costcode value not passed */
        return FAILURE;

    costcode_len = strlen(costcode);

    while(costcode_len > 1) {
        memset(temp_costcode, 0x00, sizeof(temp_costcode));
        strncpy(temp_costcode, costcode, costcode_len);

        if ( !Lookup_CostcodeExact(banding_model_id, temp_costcode, costgroup_id, cost_band_id, vas_name))  /* SUCCESS */
            return SUCCESS;
        costcode_len--;
    }

    return FAILURE;
}

int Get_Network_New(char *Number, char *Net)
{
    COSTCODE_TABLE *Temp = NULL;
    COSTCODE_TABLE Key;
    int     Idx = 0;
    char    sCellId[6+1];
    static char sBandingModelId[] = "1";

    if ( *Number == '\0' ) /* Phone Number value not passed */
        return FAILURE;

    memset(sCellId, 0x00, sizeof(sCellId));
    strncpy(sCellId, Number, 6);

    Temp = glb_CostCodeHead;
    Idx = IDX_COSTCODE_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.banding_model_id = sBandingModelId;
    Key.costcode = sCellId;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(COSTCODE_TABLE), Cmp_CostCode);

    if ( Temp == (COSTCODE_TABLE *)NULL) {       /* no match found in Cost Code Table */
        return FAILURE;
    }
    else {
        strncpy(Net, Temp->costcode_name, SIZE_NET);
    }
    return SUCCESS;
}

int Get_RmNetwork(char *Phone_No, const char *Default_Net, char *Network, char *Cosgroup_Id, char *Costband_Id)
{
    COSTCODE_TABLE *Temp = NULL;
    COSTCODE_TABLE Key;
    int     Idx = 0;
    /* Changed to support 10 Digits as below - by Kawee on 04-Apr2006 */
    /* char sCellId[6+1]; */
    char    sCellId[7+1];
    static char sBandingModelId[] = "1";

    if ( *Phone_No == '\0' ) /* Phone Number value not passed */
        return FAILURE;

    memset(sCellId, 0x00, sizeof(sCellId));
    /* Changed to support 10 Digits as below - by Kawee on 04-Apr2006 */
    /* strncpy(sCellId, Phone_No, 6); */
    strncpy(sCellId, Phone_No, 7);

    Temp = glb_CostCodeHead;
    Idx = IDX_COSTCODE_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.banding_model_id = sBandingModelId;
    Key.costcode = sCellId;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(COSTCODE_TABLE), Cmp_CostCode);

    if ( Temp == (COSTCODE_TABLE *)NULL) {       /* no match found in Cost Code Table */
        return FAILURE;
    }
    else {
        strcpy(Cosgroup_Id, Temp->costgroup_id);
        strcpy(Costband_Id, Temp->cost_band_id);
        strncpy(Network, Temp->costcode_name, SIZE_NET);

        /* Changed as below by Kawee on 26-Jun-2007 */
        /* if ( !strcmp(Network, "GSM") || !strcmp(Network, "PPS") ) {} */
        if ( !strcmp(Network, "GSM") || !strcmp(Network, "PPS") || !strcmp(Network, "AIS") ) {
            if ( !strcmp(Default_Net, "GSM"))
                strcpy(Network, "GSM");
            else
                strcpy(Network, "PPS");
        }
    }
    return SUCCESS;
}


/*------------------------------------------------------------------------------------*/
/* Intorduce CDG CDR Type. Added Rating Element Table - by Kawee on 02-Jun-2005 */

int Cmp_RatingElementKey (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->rate_tariff_id, ((RATING_ELEMENT_TABLE *)ptr2)->rate_tariff_id);
    if ( rv)
        return rv;

    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->cost_band_id, ((RATING_ELEMENT_TABLE *)ptr2)->cost_band_id);
    if ( rv)
        return rv;

    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->event_class_id, ((RATING_ELEMENT_TABLE *)ptr2)->event_class_id);
    if ( rv)
        return rv;

    /* Introduced AIN - Added below by Kawee on 04-Jan-2007 */
    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->charge_segment_id, ((RATING_ELEMENT_TABLE *)ptr2)->charge_segment_id);
    if ( rv)
        return rv;

    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->rating_catalogue_id, ((RATING_ELEMENT_TABLE *)ptr2)->rating_catalogue_id);
    if ( rv)
        return rv;

    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->fix_charge_mny, ((RATING_ELEMENT_TABLE *)ptr2)->fix_charge_mny);
    if ( rv)
        return rv;

    return (strcmp(((RATING_ELEMENT_TABLE *)ptr1)->charge_rate, ((RATING_ELEMENT_TABLE *)ptr2)->charge_rate));
}

int Cmp_RatingElementKey2 (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->rate_tariff_id, ((RATING_ELEMENT_TABLE *)ptr2)->rate_tariff_id);
    if ( rv)
        return rv;

    return (strcmp(((RATING_ELEMENT_TABLE *)ptr1)->cost_band_id, ((RATING_ELEMENT_TABLE *)ptr2)->cost_band_id));
}

int Cmp_RatingElementKey3 (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->rate_tariff_id, ((RATING_ELEMENT_TABLE *)ptr2)->rate_tariff_id);
    if ( rv)
        return rv;

    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->cost_band_id, ((RATING_ELEMENT_TABLE *)ptr2)->cost_band_id);
    if ( rv)
        return rv;

    return (strcmp(((RATING_ELEMENT_TABLE *)ptr1)->event_class_id, ((RATING_ELEMENT_TABLE *)ptr2)->event_class_id));
}

/* Introduced AIN - Added below by Kawee on 04-Jan-2007 */
int Cmp_RatingElementKey4 (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->rate_tariff_id, ((RATING_ELEMENT_TABLE *)ptr2)->rate_tariff_id);
    if ( rv)
        return rv;

    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->cost_band_id, ((RATING_ELEMENT_TABLE *)ptr2)->cost_band_id);
    if ( rv)
        return rv;

    rv = strcmp(((RATING_ELEMENT_TABLE *)ptr1)->event_class_id, ((RATING_ELEMENT_TABLE *)ptr2)->event_class_id);
    if ( rv)
        return rv;

    return (strcmp(((RATING_ELEMENT_TABLE *)ptr1)->charge_segment_id, ((RATING_ELEMENT_TABLE *)ptr2)->charge_segment_id));
}

/*
** Name     : Parse_RatingElement()
**
** Description  : Parse Rating Tariff Id, Cost Band Id, Event Class Id and Rating Calalog Id from Memory Rating Element Table.
**        If there is Rating Element Record in Memory Table then
**              Do Binary Search on the Rating Element Table for the given Fixed Charge Money and Charging Rate
**              (matching whole word)
**          If Matched, then copy the Fixed Charge Money and Charging Rate to the Output parameter.
**
** Parameters   : char *rate_tariff_id - INPUT - Pointer to the buffer contains Rate Tariff Id.
**        char *cost_band_id - INPUT - Pointer to the buffer contains Cost Band Id.
**        char *event_class_id - INPUT - Pointer to the buffer contains Event Class Id.
**        char *charge_segment_id - INPUT - Pointer to the buffer contains Charge Segment Id.
**        char *rating_catalogue_id - INPUT - Pointer to the buffer contains Rating Catalogue Id.
**        char *fix_charge_mny - OUTPUT - Pointer to the buffer contains Fixed Charge Money.
**        char *charge_rate - OUTPUT - Pointer to the buffer contains Charging Rate.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_RatingElement (char *rate_tariff_id, char *cost_band_id, char *event_class_id, char *charge_segment_id, char *rating_catalogue_id, char *fix_charge_mny, char *charge_rate)
{
    RATING_ELEMENT_TABLE *Temp = NULL;
    RATING_ELEMENT_TABLE Key;
    int     Idx = 0;
    //long    lCharge;

    if ( *cost_band_id == '\0' )  /* cost_band_id value not passed */
        return FAILURE;

    Key.rate_tariff_id = rate_tariff_id;
    Key.cost_band_id = cost_band_id;
    Key.event_class_id = event_class_id;
    Key.charge_segment_id = charge_segment_id;
    Key.rating_catalogue_id = rating_catalogue_id;

    Temp = glb_RatingElementHead;
    Idx = IDX_RATING_ELEMENT_TABLE;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(RATING_ELEMENT_TABLE), Cmp_RatingElementKey);

    if ( Temp == (RATING_ELEMENT_TABLE *)NULL) {     /* no match found in Rating Element Table */
        return FAILURE;
    }
    else {
        strcpy(fix_charge_mny, Temp->fix_charge_mny);
        strcpy(charge_rate, Temp->charge_rate);
    }
    return SUCCESS;
}

/*
** Name     : Parse_RatingElement2()
**
** Description  : Parse Rating Tariff Id and Cost Band Id from Memory Rating Element Table.
**        If there is Rating Element Record in Memory Table then
**              Do Binary Search on the Rating Element Table for the given Fixed Charge Money and Charging Rate
**              (matching whole word)
**          If Matched, then copy the Fixed Charge Money and Charging Rate to the Output parameter.
**
** Parameters   : char *rate_tariff_id - INPUT - Pointer to the buffer contains Rate Tariff Id.
**        char *cost_band_id - INPUT - Pointer to the buffer contains Cost Band Id.
**        char *fix_charge_mny - OUTPUT - Pointer to the buffer contains Fixed Charge Money.
**        char *charge_rate - OUTPUT - Pointer to the buffer contains Charging Rate.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_RatingElement2 (char *rate_tariff_id, char *cost_band_id, char *fix_charge_mny, char *charge_rate)
{
    RATING_ELEMENT_TABLE *Temp = NULL;
    RATING_ELEMENT_TABLE Key;
    int     Idx = 0;
    //long    lCharge;

    if ( *cost_band_id == '\0' )  /* cost_band_id value not passed */
        return FAILURE;

    Key.rate_tariff_id = rate_tariff_id;
    Key.cost_band_id = cost_band_id;

    Temp = glb_RatingElementHead;
    Idx = IDX_RATING_ELEMENT_TABLE;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(RATING_ELEMENT_TABLE), Cmp_RatingElementKey2);

    if ( Temp == (RATING_ELEMENT_TABLE *)NULL) {     /* no match found in Rating Element Table */
        return FAILURE;
    }
    else {
        strcpy(fix_charge_mny, Temp->fix_charge_mny);
        strcpy(charge_rate, Temp->charge_rate);
    }
    return SUCCESS;
}

/*
** Name     : Parse_RatingElement3()
**
** Description  : Parse Rating Tariff Id, Cost Band Id and Event Class Id from Memory Rating Element Table.
**        If there is Rating Element Record in Memory Table then
**              Do Binary Search on the Rating Element Table for the given Fixed Charge Money and Charging Rate
**              (matching whole word)
**          If Matched, then copy the Fixed Charge Money and Charging Rate to the Output parameter.
**
** Parameters   : char *rate_tariff_id - INPUT - Pointer to the buffer contains Rate Tariff Id.
**        char *cost_band_id - INPUT - Pointer to the buffer contains Cost Band Id.
**        char *event_class_id - INPUT - Pointer to the buffer contains Event Class Id.
**        char *fix_charge_mny - OUTPUT - Pointer to the buffer contains Fixed Charge Money.
**        char *charge_rate - OUTPUT - Pointer to the buffer contains Charging Rate.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_RatingElement3 (char *rate_tariff_id, char *cost_band_id, char *event_class_id, char *fix_charge_mny, char *charge_rate)
{
    RATING_ELEMENT_TABLE *Temp = NULL;
    RATING_ELEMENT_TABLE Key;
    int     Idx = 0;
    //long    lCharge;

    if ( *cost_band_id == '\0' )  /* cost_band_id value not passed */
        return FAILURE;

    Key.rate_tariff_id = rate_tariff_id;
    Key.cost_band_id = cost_band_id;
    Key.event_class_id = event_class_id;

    Temp = glb_RatingElementHead;
    Idx = IDX_RATING_ELEMENT_TABLE;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(RATING_ELEMENT_TABLE), Cmp_RatingElementKey3);

    if ( Temp == (RATING_ELEMENT_TABLE *)NULL) {     /* no match found in Rating Element Table */
        return FAILURE;
    }
    else {
        strcpy(fix_charge_mny, Temp->fix_charge_mny);
        strcpy(charge_rate, Temp->charge_rate);
    }
    return SUCCESS;
}

/* Introduced AIN - Added below by Kawee on 04-Jan-2007 */
/*
** Name     : Parse_RatingElement4()
**
** Description  : Parse Rating Tariff Id, Cost Band Id, Event Class Id, and Charge Segment Id
**        from Memory Rating Element Table.
**        If there is Rating Element Record in Memory Table then
**              Do Binary Search on the Rating Element Table for the given Fixed Charge Money and Charging Rate
**              (matching whole word)
**          If Matched, then copy the Fixed Charge Money and Charging Rate to the Output parameter.
**
** Parameters   : char *rate_tariff_id - INPUT - Pointer to the buffer contains Rate Tariff Id.
**        char *cost_band_id - INPUT - Pointer to the buffer contains Cost Band Id.
**        char *event_class_id - INPUT - Pointer to the buffer contains Event Class Id.
**        char *charge_segment_id - INPUT - Pointer to the buffer contains Charge Segment Id.
**        char *fix_charge_mny - OUTPUT - Pointer to the buffer contains Fixed Charge Money.
**        char *charge_rate - OUTPUT - Pointer to the buffer contains Charging Rate.
**        char *unit_duration - OUTPUT - Pointer to the buffer contains Unit Duration.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_RatingElement4 (char *rate_tariff_id, char *cost_band_id, char *event_class_id, char *charge_segment_id, char *fix_charge_mny, char *charge_rate, char *unit_duration)
{
    RATING_ELEMENT_TABLE *Temp = NULL, *pFirstMatch = NULL, *pLastMatch = NULL, *pRec = NULL;
    RATING_ELEMENT_TABLE Key;
    int     Idx = 0;
    //int i;
    //long    lCharge;
    double  dMaxChgRate, dChgRate;

    if ( *cost_band_id == '\0' )  /* cost_band_id value not passed */
        return FAILURE;

    Key.rate_tariff_id = rate_tariff_id;
    Key.cost_band_id = cost_band_id;
    Key.event_class_id = event_class_id;
    Key.charge_segment_id = charge_segment_id;

    Temp = glb_RatingElementHead;
    Idx = IDX_RATING_ELEMENT_TABLE;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(RATING_ELEMENT_TABLE), Cmp_RatingElementKey4);

    if ( Temp == (RATING_ELEMENT_TABLE *)NULL) {     /* no match found in Rating Element Table */
        return FAILURE;
    }

    /* Find Up for Matched Record */
    pFirstMatch = Temp;
    while (pFirstMatch > glb_RatingElementHead) {
        if ( Cmp_RatingElementKey4(&Key, pFirstMatch-1) ) {   /* Not Match */
            break;
        }
        pFirstMatch--;
    }

    /* Find Last Matched Record */
    pLastMatch = Temp;
    while (pLastMatch < glb_RatingElementHead + (glb_MapdStat[Idx].tot_recs - 1) ) {
        if ( Cmp_RatingElementKey4(&Key, pLastMatch+1) ) {    /* Not Match */
            break;
        }
        pLastMatch++;
    }

    /* Find Max Charge_Rate */
    Temp = pFirstMatch;
    dMaxChgRate = atof(Temp->charge_rate) / atof(Temp->unit_duration);
    for (pRec = pFirstMatch+1; pRec <= pLastMatch; pRec++) {
        dChgRate = atof(pRec->charge_rate) / atof(pRec->unit_duration);
        if ( dChgRate > dMaxChgRate) {
            Temp = pRec;
            dMaxChgRate = dChgRate;
        }
    }

    strcpy(fix_charge_mny, Temp->fix_charge_mny);
    strcpy(charge_rate, Temp->charge_rate);
    strcpy(unit_duration, Temp->unit_duration);
    return SUCCESS;
}

/*
** Name     : Parse_RatingElement3Avg()
**
** Description  : Parse Rating Tariff Id, Cost Band Id and Event Class Id from Memory Rating Element Table.
**        If there is Rating Element Record in Memory Table then
**              Do Binary Search on the Rating Element Table for the given Fixed Charge Money and Charging Rate
**              (matching whole word)
**          If Matched, then copy the Fixed Charge Money and Charging Rate to the Output parameter.
**
** Parameters   : char *rate_tariff_id - INPUT - Pointer to the buffer contains Rate Tariff Id.
**        char *cost_band_id - INPUT - Pointer to the buffer contains Cost Band Id.
**        char *event_class_id - INPUT - Pointer to the buffer contains Event Class Id.
**        char *fix_charge_mny - OUTPUT - Pointer to the buffer contains Fixed Charge Money Average.
**        char *charge_rate - OUTPUT - Pointer to the buffer contains Charging Rate Average.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_RatingElement3Avg (char *rate_tariff_id, char *cost_band_id, char *event_class_id, char *fix_charge_mny, char *charge_rate)
{
    RATING_ELEMENT_TABLE *Temp = NULL;
    RATING_ELEMENT_TABLE Key;
    int     Idx = 0;
    //long    lCharge;

    if ( *cost_band_id == '\0' )  /* cost_band_id value not passed */
        return FAILURE;

    Key.rate_tariff_id = rate_tariff_id;
    Key.cost_band_id = cost_band_id;
    Key.event_class_id = event_class_id;

    Temp = glb_RatingElementHead;
    Idx = IDX_RATING_ELEMENT_TABLE;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(RATING_ELEMENT_TABLE), Cmp_RatingElementKey3);

    if ( Temp == (RATING_ELEMENT_TABLE *)NULL) {     /* no match found in Rating Element Table */
        return FAILURE;
    }
    else {
        strcpy(fix_charge_mny, Temp->fix_charge_mny_avg);
        strcpy(charge_rate, Temp->charge_rate_avg);
#if DEBUG_AVERAGE
printf("[%s][%s][%s] => FixCharge[%s], ChargeRate[%s], AvFixCharge[%s], AvChargeRate[%s]\n",
            rate_tariff_id, cost_band_id, event_class_id,
            Temp->fix_charge_mny, Temp->charge_rate,
            Temp->fix_charge_mny_avg, Temp->charge_rate_avg);
#endif
    }
    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/
/* Added Costgroup Xref Table - by Jetsada on 21-Jul-2005 */

int Cmp_CostgroupXref (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((COSTGROUP_XREF_TABLE *)ptr1)->banding_model_id, ((COSTGROUP_XREF_TABLE *)ptr2)->banding_model_id);
    if ( rv)     /* Not Equal */
        return rv;
    rv = strcmp(((COSTGROUP_XREF_TABLE *)ptr1)->costgroup_1_id, ((COSTGROUP_XREF_TABLE *)ptr2)->costgroup_1_id);
    if ( rv)     /* Not Equal */
        return rv;
    return (strcmp(((COSTGROUP_XREF_TABLE *)ptr1)->costgroup_2_id, ((COSTGROUP_XREF_TABLE *)ptr2)->costgroup_2_id));
}

/*
** Name     : Get_XfCostBandId()
**
** Description  : Get CostBandId from Memory Costgroup Xref Table.
**        If there is Costgroup Xref Record in Memory Table then
**              Do Binary Search on the Costgroup Xref Table for the given Costgroup 1 Id and Costgroup 2 Id (matching whole word)
**          If Matched, then copy the CostBandId to the Output parameter.
**
** Parameters   : char *banding_model_id - INPUT - Pointer to the buffer contains Banding Model Id.
**        char *costgroup_1_id - INPUT - Pointer to the buffer contains Costgroup 1 Id.
**        char *costgroup_2_id  - INPUT  - Pointer to the buffer contains Costgroup 2 Id.
**        char *cost_band_id - OUTPUT - Pointer to the buffer contains Matched Cost Band Id.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_XfCostBandId (char *banding_model_id, char *costgroup_1_id, char *costgroup_2_id, char *cost_band_id)
{
    COSTGROUP_XREF_TABLE *Temp = NULL;
    COSTGROUP_XREF_TABLE Key;
    int     Idx = 0;

    if ( *banding_model_id == '\0' || *costgroup_1_id == '\0' || *costgroup_2_id == '\0' ) /* banding_model_id or costgroup_1_id or costgroup_2_id value not passed */
        return FAILURE;

    Temp = glb_CostgroupXrefHead;
    Idx = IDX_COSTGROUP_XREF_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.banding_model_id = banding_model_id;
    Key.costgroup_1_id = costgroup_1_id;
    Key.costgroup_2_id = costgroup_2_id;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(COSTGROUP_XREF_TABLE), Cmp_CostgroupXref);

    if ( Temp == (COSTGROUP_XREF_TABLE *)NULL) {     /* no match found in Costgroup Xref Table */
        return FAILURE;
    }
    else {
        strcpy(cost_band_id, Temp->cost_band_id);
    }
    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/
/* Added Service Key Table - by Jetsada on 21-Jul-2005 */

int Cmp_ServiceKey (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((SERVICE_KEY_TABLE *)ptr1)->cdr_type, ((SERVICE_KEY_TABLE *)ptr2)->cdr_type);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((SERVICE_KEY_TABLE *)ptr1)->service_key, ((SERVICE_KEY_TABLE *)ptr2)->service_key);
    if ( rv)     /* Not Equal */
        return rv;

    return (strcmp(((SERVICE_KEY_TABLE *)ptr1)->fci, ((SERVICE_KEY_TABLE *)ptr2)->fci));
}

/*
** Name     : Get_Service()
**
** Description  : Get Service from Memory Service Key Table.
**        If there is Service Key Record in Memory Table then
**              Do Binary Search on the Service Key Table for the given Service Key (matching whole word)
**          If Matched, then copy the Service to the Output parameter.
**
** Parameters   : char *service_key - INPUT - Pointer to the buffer contains Banding Model Id.
**        char *fci  - INPUT  - Pointer to the buffer contains FCI.
**        char *service - OUTPUT - Pointer to the buffer contains Matched Service.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_Service (char *cdr_type, char *service_key, char *fci, char *service)
{
    static char szAnyFci[] = "*";
    SERVICE_KEY_TABLE *Temp = NULL;
    SERVICE_KEY_TABLE Key;
    int     Idx = 0;

    /* FCI Can be blank (zero length string). Don't Check for Value Not Passed */

    Temp = glb_ServiceKeyHead;
    Idx = IDX_SERVICE_KEY_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.cdr_type = cdr_type;
    Key.service_key = service_key;
    Key.fci = fci;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(SERVICE_KEY_TABLE), Cmp_ServiceKey);

    /* Change Service_Key Concept - Added below by Kawee on 31-Jul-2007 */
    if ( Temp == (SERVICE_KEY_TABLE *)NULL) {        /* no match found in Service Key Table */
        Temp = glb_ServiceKeyHead;
        Key.fci = szAnyFci;
        Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(SERVICE_KEY_TABLE), Cmp_ServiceKey);
    }

    if ( Temp == (SERVICE_KEY_TABLE *)NULL) {        /* no match found in Service Key Table */
        return FAILURE;
    }
    else {
        strcpy(service, Temp->service);
#if SHOW_GET_SERVICE
printf ("[%s:%s],[%s:%s], service=%s\n", service_key, fci, Temp->service_key, Temp->fci, service);
#endif
    }
    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/
/* Added PPS Desc Table - by Jetsada on 15-Aug-2005 */

int Cmp_PpsDesc (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((PPS_DESC_TABLE *)ptr1)->pps_desc, ((PPS_DESC_TABLE *)ptr2)->pps_desc);
    if ( rv)     /* Not Equal */
        return rv;

    return (strcmp(((PPS_DESC_TABLE *)ptr1)->auth_result, ((PPS_DESC_TABLE *)ptr2)->auth_result));
}

/*
** Name     : Parse_PpsDesc()
**
** Description  : Parse Pps_Desc and Auth Result from Memory PPS Desc Table.
**        If there is PPS Desc Record in Memory Table then
**              Do Binary Search on the PPS Desc Table for the given Service Type and Report
**              (matching whole word)
**          If Matched, then copy the Service Type and Report to the Output parameter.
**
** Parameters   : char *pps_desc - INPUT - Pointer to the buffer contains PPS Description.
**        char *auth_result - INPUT - Pointer to the buffer contains Authentication Result.
**        char *service_type - OUTPUT - Pointer to the buffer contains Service Type.
**        char *report - OUTPUT - Pointer to the buffer contains SMS / Delivery Report.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_PpsDesc (char *pps_desc, char *auth_result, char *service_type, char *report)
{
    PPS_DESC_TABLE *Temp = NULL;
    PPS_DESC_TABLE Key;
    int     Idx = 0;
    //long    lCharge;

    if ( pps_desc == '\0' || auth_result == '\0' )    /* pps_desc value not passed */
        return FAILURE;

    Key.pps_desc = pps_desc;
    Key.auth_result = auth_result;

    Temp = glb_PpsDescHead;
    Idx = IDX_PPS_DESC_TABLE;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(PPS_DESC_TABLE), Cmp_PpsDesc);

    if ( Temp == (PPS_DESC_TABLE *)NULL) {       /* no match found in PPS Desc Table */
        return FAILURE;
    }
    else {
        strcpy(service_type, Temp->service_type);
        strcpy(report, Temp->report);
    }
    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/
/* Added AIN Cost Code Table - by Kawee on 29-Jan-2007 */
int Cmp_AinCostCodeKey (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((AIN_COSTCODE_TABLE *)ptr1)->costcode_mapping, ((AIN_COSTCODE_TABLE *)ptr2)->costcode_mapping);
    if ( rv)     /* Not Equal */
        return rv;

    return (strcmp(((AIN_COSTCODE_TABLE *)ptr1)->dest_code, ((AIN_COSTCODE_TABLE *)ptr2)->dest_code));
}

int Cmp_AinCostCodeKey2 (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((AIN_COSTCODE_TABLE *)ptr1)->costcode_mapping, ((AIN_COSTCODE_TABLE *)ptr2)->costcode_mapping);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((AIN_COSTCODE_TABLE *)ptr1)->cdr_type, ((AIN_COSTCODE_TABLE *)ptr2)->cdr_type);
    if ( rv)     /* Not Equal */
        return rv;

    return (strcmp(((AIN_COSTCODE_TABLE *)ptr1)->dest_code, ((AIN_COSTCODE_TABLE *)ptr2)->dest_code));
}

/*
** Name     : Parse_AinCostCodeExact()
**
** Description  : Parse Cost Code Mapping and Destination Code from Memory AIN Cost Code Table.
**        If there is AIN Cost Code Record in Memory Table then
**              Do Binary Search on the AIN Cost Code Table for the given Cost Code Mapping (matching whole word)
**          and Destination Code (matching only match_length size)
**          If Matched, then copy the Cost Band Id the Output parameter.
**
** Parameters   : char *costcode_mapping - INPUT - Pointer to the buffer contains Cost Code Mapping.
**        char *dest_code - INPUT - Pointer to the buffer contains Destination Code.
**        char *cost_band_id - OUTPUT - Pointer to the buffer contains Cost Band Id.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_AinCostCodeExact (char *costcode_mapping, char *dest_code, char *cost_band_id)
{
    AIN_COSTCODE_TABLE *Temp = NULL;
    AIN_COSTCODE_TABLE Key;
    int     Idx = 0;

    if ( costcode_mapping == '\0' || dest_code == '\0' )  /* pps_desc value not passed */
        return FAILURE;

    Key.costcode_mapping = costcode_mapping;
    Key.dest_code = dest_code;

    Temp = glb_AinCostCodeHead;
    Idx = IDX_AIN_COSTCODE_TABLE;

    /* Do binary search on the AIN Cost Code Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_COSTCODE_TABLE), Cmp_AinCostCodeKey);

    if ( Temp == (AIN_COSTCODE_TABLE *)NULL) {       /* no match found in AIN Cost Code Table */
        return FAILURE;
    }
    else {
        strcpy(cost_band_id, Temp->cost_band_id);
    }
    return SUCCESS;
}

/*
** Name     : Parse_AinCostCode()
**
** Description  : Parse Cost Code Mapping and Destination Code from Memory AIN Cost Code Table.
**        If there is AIN Cost Code Record in Memory Table then
**          Do loop to call Parse_AinCostCodeExact function for match the longest Destination Code
**          If Matched, then copy the Cost Band Id the Output parameter (Done by Parse_AinCostCodeExact function).
**
** Parameters   : char *costcode_mapping - INPUT - Pointer to the buffer contains Cost Code Mapping.
**        char *dest_code - INPUT - Pointer to the buffer contains Destination Code.
**        char *cost_band_id - OUTPUT - Pointer to the buffer contains Cost Band Id.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_AinCostCode (char *costcode_mapping, char *dest_code, char *cost_band_id)
{
    int destcode_len = 0;
    char temp_destcode[SIZE_AIN_DESTCODE+1];

    if ( costcode_mapping == '\0' || dest_code == '\0' )  /* costcode_mapping and dest_code value not passed */
        return FAILURE;

    destcode_len = strlen(dest_code);

    while(destcode_len > 1) {
        memset(temp_destcode, 0x00, sizeof(temp_destcode));
        strncpy(temp_destcode, dest_code, destcode_len);

        if ( !Parse_AinCostCodeExact(costcode_mapping, temp_destcode, cost_band_id)) /* SUCCESS */
            return SUCCESS;

        destcode_len--;
    }

    return FAILURE;
}

int Parse_AinCostCodeExact2 (char *costcode_mapping, char *dest_code, char *cdr_type, char *cost_band_id)
{
    AIN_COSTCODE_TABLE *Temp = NULL;
    AIN_COSTCODE_TABLE Key;
    int     Idx = 0;

    if ( costcode_mapping == '\0' || dest_code == '\0' )  /* pps_desc value not passed */
        return FAILURE;

    Key.costcode_mapping = costcode_mapping;
    Key.dest_code = dest_code;
    Key.cdr_type = cdr_type;

    Temp = glb_AinCostCodeHead;
    Idx = IDX_AIN_COSTCODE_TABLE;

    /* Do binary search on the AIN Cost Code Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_COSTCODE_TABLE), Cmp_AinCostCodeKey2);

    if ( Temp == (AIN_COSTCODE_TABLE *)NULL) {       /* no match found in AIN Cost Code Table */
        return FAILURE;
    }
    else {
        strcpy(cost_band_id, Temp->cost_band_id);
    }
    return SUCCESS;
}

int Parse_AinCostCode2 (char *costcode_mapping, char *dest_code, char *cdr_type, char *cost_band_id)
{
    int destcode_len = 0;
    char temp_destcode[SIZE_AIN_DESTCODE+1];

    if ( costcode_mapping == '\0' || dest_code == '\0' )  /* costcode_mapping and dest_code value not passed */
        return FAILURE;

    destcode_len = strlen(dest_code);

    while(destcode_len > 1) {
        memset(temp_destcode, 0x00, sizeof(temp_destcode));
        strncpy(temp_destcode, dest_code, destcode_len);

        if ( !Parse_AinCostCodeExact2(costcode_mapping, temp_destcode, cdr_type, cost_band_id))  /* SUCCESS */
            return SUCCESS;

        destcode_len--;
    }

    return FAILURE;
}
/*------------------------------------------------------------------------------------*/
/* Added AIN Operator Carrier Master Table - by Kawee on 29-Jan-2007 */
int Cmp_AinOperCarrierMasterKey (const void *ptr1, const void *ptr2)
{
    return (strcmp(((AIN_OPER_CARRIER_MASTER_TABLE *)ptr1)->oper_carrier_id, ((AIN_OPER_CARRIER_MASTER_TABLE *)ptr2)->oper_carrier_id));
}


/*
** Name     : Get_AinOperSingleBillFlag()
**
** Description  : Parse Operator Carrier Id from Memory AIN Operator Carrier Master Table.
**        If there is AIN Operator Carrier Master Record in Memory Table then
**              Do Binary Search on the AIN Operator Carrier Master Table for the given Operator Carrier Id
**              (matching whole word)
**          If Matched, then copy the Single Bill Flag to the Output parameter.
**
** Parameters   : char *oper_carrier_id - INPUT - Pointer to the buffer contains Operator Carrier Id.
**        char *single_bill_flag - OUTPUT - Pointer to the buffer contains Operator Single Bill Flag.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Get_AinOperSingleBillFlag (char *oper_carrier_id, char *single_bill_flag)
{
    AIN_OPER_CARRIER_MASTER_TABLE *Temp = NULL;
    AIN_OPER_CARRIER_MASTER_TABLE Key;
    int     Idx = 0;

    if ( oper_carrier_id == '\0' )        /* oper_carrier_id value not passed */
        return FAILURE;

    Key.oper_carrier_id = oper_carrier_id;
    Key.single_bill_flag = single_bill_flag;

    Temp = glb_AinOperCarrierMasterHead;
    Idx = IDX_AIN_OPER_CARRIER_MASTER_TABLE;

    /* Do binary search on the AIN Operator Carrier Master Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_OPER_CARRIER_MASTER_TABLE), Cmp_AinOperCarrierMasterKey);

    if ( Temp == (AIN_OPER_CARRIER_MASTER_TABLE *)NULL) {        /* no match found in AIN Operator Carrier Master Table */
        return FAILURE;
    }
    else {
        strcpy(single_bill_flag, Temp->single_bill_flag);
    }
    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/
/* Added AIN Rating Tariff Element Table - by Kawee on 29-Jan-2007 */
int Cmp_AinRatingTariffElementTable (const void *ptr1, const void *ptr2)
{
    int rv;
    double  diff_chg_rate;
    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->rating_tariff_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->rating_tariff_id);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->cost_band_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->cost_band_id);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->modifier_class_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->modifier_class_id);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->time_plan_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->time_plan_id);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->time_rate_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->time_rate_id);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->step_group, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->step_group);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->step_seq, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->step_seq);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->subs_type, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->subs_type);
    if ( rv)     /* Not Equal */
        return rv;

    diff_chg_rate = atof(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->charge_rate) - atof(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->charge_rate);
    if ( diff_chg_rate > 0)
        rv = 1;
    else if ( diff_chg_rate < 0)
        rv = -1;
    else
        rv = 0;
    return (rv * -1);
}

int Cmp_AinRatingTariffElementKey (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->rating_tariff_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->rating_tariff_id);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->cost_band_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->cost_band_id);
    if ( rv)     /* Not Equal */
        return rv;

    return (strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->modifier_class_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->modifier_class_id));
}

/*
** Name     : Parse_AinRatingTariffElement()
**
** Description  : Parse Rating Tariff Id, Cost Band Id, and Modifier Class Id from Memory AIN Rating Tariff Element Table.
**        If there is AIN Rating Tariff Element Record in Memory Table then
**              Do Binary Search on the AIN Rating Tariff Element Table for the given Rating Tariff Id, Cost Band Id,
**          and Modifier Class Id (matching whole word)
**          If Matched, then copy the Charge Rate to the Output parameter.
**
** Parameters   : char *rating_tariff_id - INPUT - Pointer to the buffer contains Rating Tariff Id.
**        char *cost_band_id - INPUT - Pointer to the buffer contains Cost Band Id.
**        char *modifier_class_id - INPUT - Pointer to the buffer contains Modifier Class Id.
**        char *charge_rate - OUTPUT - Pointer to the buffer contains Charge Rate.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_AinRatingTariffElement (char *rating_tariff_id, char *cost_band_id, char *modifier_class_id, char *charge_rate)
{
    AIN_RATING_TARIFF_ELEMENT_TABLE *Temp = NULL;
    AIN_RATING_TARIFF_ELEMENT_TABLE Key;
    int     Idx = 0;

    if ( rating_tariff_id == '\0' || cost_band_id == '\0' || modifier_class_id == '\0' )  /* Input value not passed */
        return FAILURE;

    Key.rating_tariff_id = rating_tariff_id;
    Key.cost_band_id = cost_band_id;
    Key.modifier_class_id = modifier_class_id;

    Temp = glb_AinRatingTariffElementHead;
    Idx = IDX_AIN_RATING_TARIFF_ELEMENT_TABLE;

    /* Do binary search on the AIN Rating Tariff Element Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_RATING_TARIFF_ELEMENT_TABLE), Cmp_AinRatingTariffElementKey);

    if ( Temp == (AIN_RATING_TARIFF_ELEMENT_TABLE *)NULL) {      /* no match found in AIN Rating Tariff Element Table */
        return FAILURE;
    }
    else {
        strcpy(charge_rate, Temp->charge_rate);
    }
    return SUCCESS;
}

int Cmp_AinRatingTariffElementKey2 (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->rating_tariff_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->rating_tariff_id);
    if ( rv)
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->cost_band_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->cost_band_id);
    if ( rv)
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->modifier_class_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->modifier_class_id);
    if ( rv)
        return rv;

    /* Introduced AIN - Added below by Kawee on 04-Jan-2007 */
    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->time_plan_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->time_plan_id);
    if ( rv)
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->time_rate_id, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->time_rate_id);
    if ( rv)
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->step_group, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->step_group);
    if ( rv)
        return rv;

    rv = strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->step_seq, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->step_seq);
    if ( rv)
        return rv;

    return (strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr1)->subs_type, ((AIN_RATING_TARIFF_ELEMENT_TABLE *)ptr2)->subs_type));
}

int Parse_AinRatingTariffElement2 (char *rating_tariff_id, char *cost_band_id, char *modifier_class_id, char *time_plan_id, char *time_rate_id, char *step_group, char *step_seq, char *subs_type, char *charge_rate)
{
    AIN_RATING_TARIFF_ELEMENT_TABLE *Temp = NULL;
    AIN_RATING_TARIFF_ELEMENT_TABLE Key;
    int     Idx = 0;

    if ( rating_tariff_id == '\0' || cost_band_id == '\0' || modifier_class_id == '\0' )  /* Input value not passed */
        return FAILURE;

    Key.rating_tariff_id = rating_tariff_id;
    Key.cost_band_id = cost_band_id;
    Key.modifier_class_id = modifier_class_id;
    Key.time_plan_id = time_plan_id;
    Key.time_rate_id = time_rate_id;
    Key.step_group = step_group;
    Key.step_seq = step_seq;
    Key.subs_type = subs_type;

    Temp = glb_AinRatingTariffElementHead;
    Idx = IDX_AIN_RATING_TARIFF_ELEMENT_TABLE;

    /* Do binary search on the AIN Rating Tariff Element Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_RATING_TARIFF_ELEMENT_TABLE), Cmp_AinRatingTariffElementKey);

    if ( Temp == (AIN_RATING_TARIFF_ELEMENT_TABLE *)NULL) {      /* no match found in AIN Rating Tariff Element Table */
        return FAILURE;
    }
    else {
        strcpy(charge_rate, Temp->charge_rate);
    }
    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/
/* Added AIN Route Master Table - by Kawee on 29-Jan-2007 */
int Cmp_AinRouteMaster (const void *ptr1, const void *ptr2)
{
    return (strcmp(((AIN_ROUTE_MASTER_TABLE *)ptr1)->route_id, ((AIN_ROUTE_MASTER_TABLE *)ptr2)->route_id));
}

/*
** Name     : Parse_AinRouteMaster()
**
** Description  : Parse Route Id from Memory AIN Route Master Table.
**        If there is AIN Route Master Record in Memory Table then
**              Do Binary Search on the AIN Route Master Table for the given Route Id (matching whole word)
**          If Matched, then copy the Operator Carrier Id and Cost Code Mapping to the Output parameter.
**
** Parameters   : char *route_id - INPUT - Pointer to the buffer contains Route Id.
**        char *oper_carrier_id - OUTPUT - Pointer to the buffer contains Operator Carrier Id.
**        char *costcode_mapping - OUTPUT - Pointer to the buffer contains Cost Code mapping.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_AinRouteMaster (char *route_id, char *oper_carrier_id, char *costcode_mapping, char *mtx_id)
{
    AIN_ROUTE_MASTER_TABLE *Temp = NULL;
    AIN_ROUTE_MASTER_TABLE Key;
    int     Idx = 0;

    if ( route_id == '\0' )           /* Route Id value not passed */
        return FAILURE;

    Key.route_id = route_id;

    Temp = glb_AinRouteMasterHead;
    Idx = IDX_AIN_ROUTE_MASTER_TABLE;

    /* Do binary search on the Mobile Network Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_ROUTE_MASTER_TABLE), Cmp_AinRouteMaster);

    if ( Temp == (AIN_ROUTE_MASTER_TABLE *)NULL) {       /* no match found in AIN Route Master Table */
        return FAILURE;
    }
    else {
        strcpy(oper_carrier_id, Temp->oper_carrier_id);
        strcpy(costcode_mapping, Temp->costcode_mapping);
        strcpy(mtx_id, Temp->mtx_id);
    }
    return SUCCESS;
}

/*------------------------------------------------------------------------------------*/
/* Added AIN Subscriber Type Master Table - by Kawee on 29-Jan-2007 */
int Cmp_AinSubTypeMasterKey (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((AIN_SUB_TYPE_TABLE *)ptr1)->sub_carrier, ((AIN_SUB_TYPE_TABLE *)ptr2)->sub_carrier);
    if ( rv)     /* Not Equal */
        return rv;

    return (strcmp(((AIN_SUB_TYPE_TABLE *)ptr1)->sub_prefix, ((AIN_SUB_TYPE_TABLE *)ptr2)->sub_prefix));
}

/*
** Name     : Parse_AinSubTypeExact()
**
** Description  : Parse Subscriber Carrier and Subscriber Prefix from Memory Subscriber Type Master Table.
**        If there is Subscriber Type Master Record in Memory Table then
**              Do Binary Search on the Subscriber Type Master Table for the given Subscriber Carrier
**          and Subscriber Prefix (matching whole word)
**          If Matched, then copy the Subscriber Type to the Output parameter.
**
** Parameters   : char *sub_carrier - INPUT - Pointer to the buffer contains Subscriber Carrier.
**        char *sub_prefix - INPUT - Pointer to the buffer contains Subscriber Prefix.
**        char *sub_type - OUTPUT - Pointer to the buffer contains Subscriber Type.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_AinSubTypeExact (char *sub_carrier, char *sub_prefix, char *sub_type)
{
    AIN_SUB_TYPE_TABLE *Temp = NULL;
    AIN_SUB_TYPE_TABLE Key;
    int     Idx = 0;
    //long    lCharge;

    if ( sub_carrier == '\0' || sub_prefix == '\0' )      /* sub_carrier or sub_prefix value not passed */
        return FAILURE;

    Key.sub_carrier = sub_carrier;
    Key.sub_prefix = sub_prefix;

    Temp = glb_AinSubTypeHead;
    Idx = IDX_AIN_SUBTYPE_MASTER_TABLE;

    /* Do binary search on the AIN Subscriber Type Master Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_SUB_TYPE_TABLE), Cmp_AinSubTypeMasterKey);

    if ( Temp == (AIN_SUB_TYPE_TABLE *)NULL) {       /* no match found in PPS Desc Table */
        return FAILURE;
    }
    else {
        strcpy(sub_type, Temp->sub_type);
    }
    return SUCCESS;
}

/*
** Name     : Parse_AinSubType()
**
** Description  : Parse Subscriber Carrier and Subscriber Prefix from Memory Subscriber Type Master Table.
**        If there is Subscriber Type Master Record in Memory Table then
**              Do loop to Call Parse_AinSubTypeExact Function to match Exact Subscriber Carrier
**          and match longest Subscriber Prefix
**          If Matched, then copy the Subscriber Type to the Output parameter (Done by Parse_AinSubTypeExact Function).
**
** Parameters   : char *sub_carrier - INPUT - Pointer to the buffer contains Subscriber Carrier.
**        char *sub_prefix - INPUT - Pointer to the buffer contains Subscriber Prefix.
**        char *sub_type - OUTPUT - Pointer to the buffer contains Subscriber Type.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_AinSubType (char *sub_carrier, char *sub_prefix, char *sub_type)
{
    int prefix_len = 0;
    char temp_prefix[SIZE_AIN_SUBPREFIX+1];

    if ( sub_carrier == '\0' || sub_prefix == '\0' )      /* sub_carrier or sub_prefix value not passed */
        return FAILURE;

    prefix_len = strlen(sub_prefix);
    if ( prefix_len > SIZE_AIN_SUBPREFIX)
        prefix_len = SIZE_AIN_SUBPREFIX;

    while(prefix_len > 1) {
        memset(temp_prefix, 0x00, sizeof(temp_prefix));
        strncpy(temp_prefix, sub_prefix, prefix_len);

        if ( !Parse_AinSubTypeExact(sub_carrier, temp_prefix, sub_type)) /* SUCCESS */
            return SUCCESS;

        prefix_len--;
    }

    return FAILURE;
}

/*------------------------------------------------------------------------------------*/
/* Added AIN E1 Mapping Table - by Jetsada on 17-Sep-2007 */
int Cmp_AinE1MappingKey (const void *ptr1, const void *ptr2)
{
    return (strcmp(((AIN_E1_MAPPING_TABLE *)ptr1)->source_name, ((AIN_E1_MAPPING_TABLE *)ptr2)->source_name));
}

/*
** Name     : Parse_AinE1Mapping()
**
** Description  : Parse Source Name from Memory E1 Mapping Table.
**        If there is E1 Mapping Record in Memory Table then
**              Do Binary Search on the E1 Mapping Table for the given Source Name (matching whole word)
**          If Matched, then return TRUE.
**
** Parameters   : char *source_name - INPUT - Pointer to the buffer contains Source Name.
**        char *target_name - INPUT - Pointer to the buffer contains Target Name.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/

int Parse_AinE1Mapping (char *source_name, char *target_name)
{
    AIN_E1_MAPPING_TABLE *Temp = NULL;
    AIN_E1_MAPPING_TABLE Key;
    int     Idx = 0;

    if ( source_name == '\0' )        /* source_name value not passed */
        return FAILURE;

    Key.source_name = source_name;

    Temp = glb_AinE1MappingHead;
    Idx = IDX_AIN_E1_MAPPING_TABLE;

    /* Do binary search on the AIN E1 Mapping Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_E1_MAPPING_TABLE), Cmp_AinE1MappingKey);

    if ( Temp == (AIN_E1_MAPPING_TABLE *)NULL) {     /* no match found in E1 Mapping Table */
        return FAILURE;
    }
    else {
        strcpy(target_name, Temp->target_name);
    }
    return SUCCESS;
}

/* Added AIN Basic Time Rate Mapping Table - by Thanakorn on 04-Mar-2010 */
int Cmp_AinBasicTimeRate(const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((AIN_BASIC_TIME_RATE_TABLE *)ptr1)->start_day, ((AIN_BASIC_TIME_RATE_TABLE *)ptr2)->start_day);
    if ( rv)     /* Not Equal */
        return rv;

    rv = strcmp(((AIN_BASIC_TIME_RATE_TABLE *)ptr1)->time_plan_id, ((AIN_BASIC_TIME_RATE_TABLE *)ptr2)->time_plan_id);
    if ( rv)
        return rv;

    rv = strcmp(((AIN_BASIC_TIME_RATE_TABLE *)ptr1)->start_date, ((AIN_BASIC_TIME_RATE_TABLE *)ptr2)->start_date);
    if ( rv)
        return rv;

    rv = strcmp(((AIN_BASIC_TIME_RATE_TABLE *)ptr1)->start_time, ((AIN_BASIC_TIME_RATE_TABLE *)ptr2)->start_time);
    if ( rv)
        return rv;

    rv = strcmp(((AIN_BASIC_TIME_RATE_TABLE *)ptr1)->end_date, ((AIN_BASIC_TIME_RATE_TABLE *)ptr2)->end_date);
    if ( rv)
        return rv;

    return (strcmp(((AIN_BASIC_TIME_RATE_TABLE *)ptr1)->end_time, ((AIN_BASIC_TIME_RATE_TABLE *)ptr2)->end_time));
}

/*
** Name : Parse_AinBasicTimeRate()
**
** Description : Parse Time Rate Id from Memory Basic Time Rate Mapping Table.
**               If there is Basic Time Rate Mapping Record in Memory Table then
**                  Do Binary Search on the Basic Time Rate Mapping Table for the given start_day and time_plan_id (matching whole word)
**               If Matched, then return TRUE.
**
** Parameters : char *start_day    - Pointer to the buffer contains start day (INPUT)
**              char *time_plan_id - Pointer to the buffer contains time plan id (INPUT)
**              char *time_rate_id - (OUTPUT)
** Return Value : SUCCESS - on successfull Match.
**                FAILURE - on no Match.
*/

int Parse_AinBasicTimeRate(char *start_day, char *time_plan_id, char *evt_dt, char *time_rate_id)
{
    AIN_BASIC_TIME_RATE_TABLE *Temp = NULL;
//    AIN_BASIC_TIME_RATE_TABLE Key;
    int Idx = 0;
    char evt_date[6], evt_time[10];

    sprintf(evt_date, "%c%c/%c%c", *(evt_dt+8),  *(evt_dt+9),  *(evt_dt+5),  *(evt_dt+6));
    sprintf(evt_time, "%c%c:%c%c:%c%c", *(evt_dt+11), *(evt_dt+12), *(evt_dt+14), *(evt_dt+15), *(evt_dt+17), *(evt_dt+18));

    if ( start_day == '\0' || time_plan_id == '\0' )  /* value is not passed */
        return FAILURE;

//    Key.start_day = start_day;
//    Key.time_plan_id = time_plan_id;

    Temp = glb_AinBasicTimeRateHead;
    Idx = IDX_AIN_BASIC_TIME_RATE_TABLE;

    //int size = sizeof(AIN_BASIC_TIME_RATE_TABLE);
	int i;
    for ( i=0; i<glb_MapdStat[Idx].tot_recs; i++ )
    {
        if ( strcmp(Temp[i].start_day, start_day) == 0 && strcmp(Temp[i].time_plan_id, time_plan_id) == 0 )
        {
            if ( strcmp(Temp[i].start_date, evt_date) >= 0 && strcmp(evt_date, Temp[i].end_date) <= 0 )
            {
                if ( (strcmp(Temp[i].start_time, "00:00:00") ==0 || strcmp(Temp[i].start_time, evt_time) >= 0) && strcmp(evt_time, Temp[i].end_time) <= 0 )
                {
                    strcpy(time_rate_id, Temp[i].time_rate_id);
                    return SUCCESS;
                }
            }
        }
    }
    return FAILURE;
}

/*------------------------------------------------------------------------------------*/
/* Added WLAN PACKAGE Table - by Jetsada on 10-Oct-2007 */
int Cmp_WlanPackageKey (const void *ptr1, const void *ptr2)
{
    return (strcmp(((WLAN_PACKAGE_TABLE *)ptr1)->apn, ((WLAN_PACKAGE_TABLE *)ptr2)->apn));
}

/*
** Name     : Is_WlanPackage()
**
** Description  : Parse Access Point Name from WLAN PACKAGE Table.
**        If there is WLAN PACKAGE Record in WLAN PACKAGE Table then
**              Do Binary Search on the WLAN PACKAGE Table for the given Access Point Name (matching whole word)
**          If Matched, then return TRUE.
**
** Parameters   : char *apn - INPUT - Pointer to the buffer contains Access Point Name.
**
** Return Value : TRUE - on successfull Match.
**        FALSE - on no Match.
*/

int Is_WlanPackage (char *apn)
{
    WLAN_PACKAGE_TABLE *Temp = NULL;
    WLAN_PACKAGE_TABLE Key;
    int     Idx = 0;

    if ( apn == '\0' )        /* apn value not passed */
        return FALSE;

    Key.apn = apn;

    Temp = glb_WlanPackageHead;
    Idx = IDX_WLAN_PACKAGE_TABLE;

    /* Do binary search on the WLAN PACKAGE Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(WLAN_PACKAGE_TABLE), Cmp_WlanPackageKey);

    if ( Temp == (WLAN_PACKAGE_TABLE *)NULL) {       /* no match found in WLAN PACKAGE Table */
        return FALSE;
    }
    return TRUE;
}

/*------------------------------------------------------------------------------------*/

/* Introduced IODC Mapping Table for support International Operator Direct Connection No. - by Kawee on 04-Dec-2007 */
int Cmp_IodcKey (const void *ptr1, const void *ptr2)
{
    return (strcmp(((IODC_TABLE *)ptr1)->iodcacc_code, ((IODC_TABLE *)ptr2)->iodcacc_code));
}

/*
** Name     : Is_IodcNumber()
**
** Description  : Parse IODC Access Code from Memory IODC Table.
**        If there is IODC Record in Memory Table then
**          Do loop to call Is_IodcNumberExact function for match the longest IODC Access Code
**          If Matched, then return TRUE (Done by Is_IodcNumberExact function).
**          Else Return FALSE
**
** Parameters   : char *iodcacc_code - INPUT - Pointer to the buffer contains IODC Access Code.
**
** Return Value : TRUE - on successfull Match.
**        FALSE - on no Match.
*/
int Is_IodcNumber (char *iodcacc_code)
{
    int iodc_len = 0;
    char temp_iodc[SIZE_IODC+1];

    if ( *iodcacc_code == '\0' ) /* iodcacc_code value not passed */
        return FAILURE;

    iodc_len = strlen(iodcacc_code);

    while(iodc_len > 1) {
        memset(temp_iodc, 0x00, sizeof(temp_iodc));
        strncpy(temp_iodc, iodcacc_code, SIZE_IODC);

        if ( Is_IodcNumberExact(temp_iodc))  /* TRUE */
            return TRUE;

        iodc_len--;
    }

    return FALSE;
}

/*
** Name     : Is_IodcNumberExact()
**
** Description  : Parse IODC Access Code from IODC Table.
**        If there is IODC Record in Memory Table then
**              Do Binary Search on the IODC Table for the given IODC Access Code (matching whole word)
**          If Matched, then return TRUE.
**
** Parameters   : char *iodcacc_code - INPUT - Pointer to the buffer contains IODC Access Code.
**
** Return Value : TRUE - on successfull Match.
**        FALSE - on no Match.
*/
int Is_IodcNumberExact (char *iodcacc_code)
{
    IODC_TABLE *Temp = NULL;
    IODC_TABLE Key;
    int     Idx = 0;

    if ( iodcacc_code == '\0' )       /* iodcacc_code value not passed */
        return FALSE;

    Temp = glb_IodcHead;
    Idx = IDX_IODC_TABLE;

    Key.iodcacc_code = iodcacc_code;

    /* Do binary search on the IODC Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(IODC_TABLE), Cmp_IodcKey);

    if ( Temp == (IODC_TABLE *)NULL) {       /* no match found in IODC Table */
        return FALSE;
    }
    return TRUE;
}

/*------------------------------------------------------------------------------------*/

/* Introduced IMSI Mapping Table for support convert NRTRDE IMSI to Mobile Number. - by Kawee on 11-Feb-2008 */
int Cmp_ImsiKey (const void *ptr1, const void *ptr2)
{
    return (strcmp(((IMSI_TABLE *)ptr1)->imsi, ((IMSI_TABLE *)ptr2)->imsi));
}

/*
** Name     : Parse_Imsi()
**
** Description  : Parse IMSI from IMSI Table.
**        If there is IMSI Record in Memory Table then
**              Do Binary Search on the IMSI Table for the given IMSI Number (matching whole word)
**          If Matched, then return Mobile Number.
**
** Parameters   : char *imsi - INPUT - Pointer to the buffer contains IMSI Number.
**        char *mobile_no - OUTPUT - Pointer to the buffer contains Mobile Number.
**
** Return Value : TRUE - on successfull Match.
**        FALSE - on no Match.
*/
int Parse_Imsi (char *imsi, char *mobile_no)
{
    IMSI_TABLE *Temp = NULL;
    IMSI_TABLE Key;
    int     Idx = 0;

    if ( imsi == '\0' )       /* imsi value not passed */
        return FALSE;

    Temp = glb_ImsiHead;
    Idx = IDX_IMSI_TABLE;

    Key.imsi = imsi;

    /* Do binary search on the IMSI Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(IMSI_TABLE), Cmp_ImsiKey);

    if ( Temp == (IMSI_TABLE *)NULL) {       /* no match found in IMSI Table */
        return FALSE;
    }
    strcpy(mobile_no, Temp->mobile_no);
    return TRUE;
}

/*------------------------------------------------------------------------------------*/

/* Introduced IMSI Mapping Table for support convert NRTRDE IMSI to Mobile Number. - by Kawee on 11-Feb-2008 */
int Cmp_ImsiVsoKey (const void *ptr1, const void *ptr2)
{
    return (strcmp(((IMSI_VSO_TABLE *)ptr1)->imsi, ((IMSI_VSO_TABLE *)ptr2)->imsi));
}

/* Added below function by Kawee on 15-Aug-2008 */
/*
** Name     : Lookup_ImsiVsoExact()
**
** Description  : Parse IMSI from IMSI VSO Table.
**        If there is IMSI VSO Record in Memory Table then
**              Do Binary Search on the IMSI VSO Table for the given IMSI Number (matching whole word)
**          If Matched, then return Success else return Failure.
**
** Parameters   : char *imsi - INPUT - Pointer to the buffer contains IMSI Number.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/
int Lookup_ImsiVsoExact (char *imsi)
{
    IMSI_VSO_TABLE *Temp = NULL;
    IMSI_VSO_TABLE Key;
    int     Idx = 0;
    //char    szTemp[128];

    if ( *imsi == '\0' )      /* imsi value not passed */
        return FAILURE;

    Temp = glb_ImsiVsoHead;
    Idx = IDX_IMSI_VSO_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.imsi = imsi;

    /* Do binary search on the IMSI VSO Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(IMSI_VSO_TABLE), Cmp_ImsiVsoKey);

    if ( Temp == (IMSI_VSO_TABLE *)NULL) {       /* no match found in IMSI VSO Table */
        return FAILURE;
    }
    return SUCCESS;
}

/* Added below function by Kawee on 15-Aug-2008 */
int Lookup_ImsiVso (char *imsi)
{
    int imsi_len = 0;
    char    temp_imsi[SIZE_IMSI+1];

    if ( *imsi == '\0' )      /* imsi value not passed */
        return FAILURE;

    imsi_len = strlen(imsi);

    while(imsi_len > 8) {
        memset(temp_imsi, 0x00, sizeof(temp_imsi));
        strncpy(temp_imsi, imsi, imsi_len);

        if ( !Lookup_ImsiVsoExact(temp_imsi))  /* SUCCESS */
            return SUCCESS;
        imsi_len--;
    }

    return FAILURE;
}

/*------------------------------------------------------------------------------------*/

/* Introduced FIX RATE Mapping Table. - by Kawee on 19-Sep-2008 */
int Cmp_FixRateKey (const void *ptr1, const void *ptr2)
{
    return (strcmp(((FIX_RATE_TABLE *)ptr1)->network, ((FIX_RATE_TABLE *)ptr2)->network));
}

/* Added below function by Kawee on 19-Sep-2008 */
/*
** Name     : Get_FixRate()
**
** Description  : Parse Network from FIX RATE Table.
**        If there is FIX RATE Record in Memory Table then
**              Do Binary Search on the FIX RATE Table for the given Network Name (matching whole word)
**          If Matched, then return Success else return Failure.
**
** Parameters   : char *network - INPUT - Pointer to the buffer contains Network Name.
**            char *charge_rate - OUTPUT - Pointer to the buffer contains Output Charge Rate Name.
**
** Return Value : SUCCESS - on successfull Match.
**        FAILURE - on no Match.
*/
int Get_FixRate (char *network, char *charge_rate)
{
    FIX_RATE_TABLE *Temp = NULL;
    FIX_RATE_TABLE Key;
    int     Idx = 0;
    //char    szTemp[128];

    if ( *network == '\0' )       /* network value not passed */
        return FAILURE;

    Temp = glb_FixRateHead;
    Idx = IDX_FIX_RATE_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.network = network;

    /* Do binary search on the IMSI VSO Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(FIX_RATE_TABLE), Cmp_FixRateKey);

    if ( Temp == (FIX_RATE_TABLE *)NULL) {       /* no match found in FIX RATE Table */
        return FAILURE;
    }
    strcpy(charge_rate, Temp->charge_rate);
    return SUCCESS;
}
/*------------------------------------------------------------------------------------*/

/* Introduced REJ ORIG ADDR Mapping Table. - by Wiraphot on 07-Jan-2009 */
int Cmp_RejOrigAddr (const void *ptr1, const void *ptr2)
{
    return (strcmp(((REJ_ORIG_ADDR_TABLE *)ptr1)->orig_addr, ((REJ_ORIG_ADDR_TABLE *)ptr2)->orig_addr));
}

/* Added below function by Wiraphot on 07-Jan-2009 */
/*
** Name     : Is_RejOrigAddr()
**
** Description  : Check Originate Addr from REJ ORIG ADDR Table
**          If there is REJ ORIG ADDR Record in Memory Table then
**              Do Binary Search on the REJ ORIG ADDR Table for the given Originate Addr (matching whole word)
**          If Matched, then return Success else return Failure.
**
**
** Parameters   : char *orig_addr - INPUT - Pointer to the buffer contains originate address.
**
** Return Value : TRUE - on successfull Match.
**        FALSE - on no Match.
*/
int Is_RejOrigAddr (char *orig_addr)
{
    REJ_ORIG_ADDR_TABLE *Temp = NULL;
    REJ_ORIG_ADDR_TABLE Key;
    int     Idx = 0;
    //char    szTemp[128];

    if ( *orig_addr == '\0' )     /* mobile number value not passed */
        return FALSE;

    Temp = glb_RejOrigAddrHead;
    Idx = IDX_REJ_ORIG_ADDR_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.orig_addr = orig_addr;

    /* Do binary search on the REJ ORIG ADDR Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(REJ_ORIG_ADDR_TABLE), Cmp_RejOrigAddr);

    if ( Temp == (REJ_ORIG_ADDR_TABLE *)NULL) {      /* no match found in REJ ORIG ADDR Table */
        return FALSE;
    }
    return TRUE;
}
/*------------------------------------------------------------------------------------*/
/* Introduced APN Mapping Table. - by Watthikorn on 20-May-2010 */
int Cmp_Apn (const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((APN_TABLE *)ptr1)->recordtype, ((APN_TABLE *)ptr2)->recordtype);
    if ( rv)     /* Not Equal */
        return rv;
    return (strcmp(((APN_TABLE *)ptr1)->apn, ((APN_TABLE *)ptr2)->apn));
}

/* Added below function by Watthikorn on 20-May-2010 */
/*
** Name     : Parse_Apn()
**
** Description  : Check Access Point Name NI from APN Table
**          If there is APN Record in Memory Table then
**              Do Binary Search on the APN Table for the given Access Point Name NI (matching whole word)
**          If Matched, then return Success else return Failure.
**
**
** Parameters   : char *apn - INPUT - Pointer to the buffer contains originate address.
**
** Return Value : TRUE - on successfull Match.
**                FALSE - on no Match.
*/
int Parse_Apn (char *recordtype, char *apn)
{
    APN_TABLE *Temp = NULL;
    APN_TABLE Key;
    int     Idx = 0;

    if ( recordtype == '\0' || apn == '\0' )
        return FAILURE;

    Key.recordtype = recordtype;
    Key.apn = apn;


    Temp = glb_ApnHead;
    Idx = IDX_APN_TABLE;

    /* Do binary search on the APN Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(APN_TABLE), Cmp_Apn);

    if ( Temp == (APN_TABLE *)NULL) {        /* no match found in APN Table */
        return FAILURE;
    }
    return SUCCESS;
}
/*------------------------------------------------------------------------------------*/
/* Intorduce CDG CDR Type. Added Delimiter Table - by Kawee on 02-Jun-2005 */

/*
** Name     : Load_VariableLengthTable()
**
** Description  : Loads Data Fields from Variable Field Length File into Memory Table.
**        Opens the Variable Field Length File.
**        Counts valid records and (Re)Allocates required memory to load those Records.
**        Determine each loading field size.
**        Reads the Records from Variable Field Length file until end of file.
**          Skips Comment Records.
**          Parses and copies fields.
**          Adds to the Memory Table.
**        Closes the Variable Field Lendth File.
**        Sorts the Memory table by Specfic field depend on table type.
**
** Parameters   : int   Idx - INPUT - Index of Variable Field Length Table in Memory Statistics.
**
** Return Value : SUCCESS         - on Successful completion.
**        FILE_OPEN_ERROR - on File open Error.
**        LOAD_TABLE_FULL - on Failure to allocate memory.
**        NO_CODE_LOADED  - on No Valid Code Loaded into memory.
*/
int Load_VariableLengthTable(int Idx)
{

    FILE    *fp;
    char    Input[SIZE_LOADREC+1];
    char    *pstr=NULL;
    char    *pchData;
    char    *apchFld[MAX_LOAD_MAP_FIELD];
    char    **ppchHead=NULL;
    char    cComment;
    char    cDelimiter;
    int     aiSizeFld[MAX_LOAD_MAP_FIELD];
    int     iFldCnt, iFldLen, iRecCnt;
    int     iSizeHead, iSizeHeadRec, iSizeData, iSizeRec;
    int     iMinInputFld, iNofLoadFld;
    int     i, j;
    int     iTmp = 0;
    char    *Temp=NULL;     // Local Pointer to Variable Length Table

    if ( glb_MapdStat[Idx].vl_info.iNofLoadFld <= 0 )
        return NO_CODE_LOADED;

    if ( glb_MapdStat[Idx].vl_info.iNofLoadFld > MAX_LOAD_MAP_FIELD )
        return NO_CODE_LOADED;

    if ( Idx != IDX_BEARER_TABLE &&                      // Bearer Table
         Idx != IDX_COSTCODE_TABLE &&                    // Cost Code Table
         Idx != IDX_COSTGROUP_XREF_TABLE &&              // Costgroup Xref Table
         Idx != IDX_SERVICE_KEY_TABLE &&                 // Service Key Table
         Idx != IDX_PPS_DESC_TABLE &&                    // PPS Desc Table
         Idx != IDX_RATING_ELEMENT_TABLE &&              // Rating Element Table
         Idx != IDX_AIN_COSTCODE_TABLE &&                // AIN Cost Code Table - Added by Kawee on 29-Jan-2007
         Idx != IDX_AIN_OPER_CARRIER_MASTER_TABLE &&     // AIN Operator Carrier Master Table - Added by Kawee on 29-Jan-2007
         Idx != IDX_AIN_RATING_TARIFF_ELEMENT_TABLE &&   // AIN Rating Tariff Element Table - Added by Kawee on 29-Jan-2007
         Idx != IDX_AIN_ROUTE_MASTER_TABLE &&            // AIN Route Master Table - Added by Kawee on 29-Jan-2007
         Idx != IDX_AIN_SUBTYPE_MASTER_TABLE &&          // AIN Subscriber Type Master Table - Added by Kawee on 29-Jan-2007
         Idx != IDX_AIN_E1_MAPPING_TABLE &&              // AIN E1 Mapping Table - Added by Jetsada on 18-Sep-2007
         Idx != IDX_AIN_BASIC_TIME_RATE_TABLE &&         // AIN Basic Time Rate Table - Added by Thanakorn on 04-Mar-2010
         Idx != IDX_WLAN_PACKAGE_TABLE &&                // WLAN PACKAGE Table - Added by Jetsada on 10-Oct-2007
         Idx != IDX_IODC_TABLE &&                        // IODC Table - Added by Kawee on 04-Dec-2007
         Idx != IDX_IMSI_TABLE &&                        // IMSI Table - Added by Kawee on 04-Dec-2007
         Idx != IDX_IMSI_VSO_TABLE &&                    // IMSI VSO Table - Added by Kawee on 15-Aug-2008
         Idx != IDX_FIX_RATE_TABLE &&                    // FIX RATE Table - Added by Kawee on 19-Sep-2008
         Idx != IDX_REJ_ORIG_ADDR_TABLE &&               // REJ ORIG ADDR Table - Added by Wiraphot on 07-Jan-2009
         Idx != IDX_APN_TABLE &&                         // APN Table - Added by Watthikorn on 24-May-2010
         Idx != IDX_3G_MAP_TABLE &&                      // 3G/2G Service Mapping - Added by Thanakorn on Sep-2011
         Idx != IDX_TOLL_FREE_TABLE &&                   // Toll Free Mapping - Added by Thanakorn on Nov-2012
         Idx != IDX_ONE_LOVE_TABLE &&                    // One Love Mapping - Added by Thanakorn on Sep-2013
         Idx != IDX_BOS_IMEI_TABLE &&                    // BOS IMEI Mapping - Added by Thanakorn on 13-Nov-2013
         Idx != IDX_COSTCODE_BNO_TABLE &&                // Costcode Bno - Added by Thanakorn on 23-Apr-2014
         Idx != IDX_USMAP_TABLE &&                       // USMAP - Added by Thanakorn on Sep-2016
         Idx != IDX_GEO_TABLE &&
         Idx != IDX_CELLAREA_TABLE &&
         Idx != IDX_VASGROUP_TABLE ) {
        return NO_CODE_LOADED;
    }

    // Prepare Variable before Read Data
    cComment = glb_MapdStat[Idx].vl_info.cComment;
    cDelimiter = glb_MapdStat[Idx].vl_info.cDelimiter;
    iNofLoadFld = glb_MapdStat[Idx].vl_info.iNofLoadFld;
    iMinInputFld = 0;
    for ( i = 0; i < iNofLoadFld; i++ ) {
        if ( iMinInputFld < glb_MapdStat[Idx].vl_info.aiLoadFldId[i] ) {
            iMinInputFld = glb_MapdStat[Idx].vl_info.aiLoadFldId[i];
        }
    }

    // open input Data file
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL ) {
        return FILE_OPEN_ERROR;
    }

    // Count Valid Number of Records
    memset(aiSizeFld, 0x00, sizeof (aiSizeFld));
    iRecCnt = 0;
    while ( fgets((char *)Input, SIZE_LOADREC, fp) != NULL ) {
        if ( *Input == cComment )     // Comment Line not counted
            continue;

        iFldCnt = 0;
        while ( 1 ) {
            if ( !iFldCnt ) {
                pstr = Get_StrTok(Input, cDelimiter);
            }
            else {
                pstr = Get_StrTok((char *)NULL, cDelimiter);
            }

            if ( !pstr ) { // No more Field
                break;
            }

            iFldCnt++;
            Trim_Str(pstr);
            iFldLen = strlen(pstr);

            // Skip record that not record type "02"
            if ( Idx == IDX_COSTCODE_TABLE ||                    // Cost Code Table
                 Idx == IDX_COSTGROUP_XREF_TABLE ||              // Costgroup Xref Table
                 Idx == IDX_RATING_ELEMENT_TABLE ||              // Rating Element Table
                 // Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007
                 Idx == IDX_AIN_COSTCODE_TABLE ||                // AIN Cost Code Table
                 Idx == IDX_AIN_OPER_CARRIER_MASTER_TABLE ||     // AIN Operator Carrier Master Table
                 Idx == IDX_AIN_RATING_TARIFF_ELEMENT_TABLE ||   // AIN Rating Tariff Element Table
                 Idx == IDX_AIN_ROUTE_MASTER_TABLE ||            // AIN Route Master Table
                 Idx == IDX_AIN_SUBTYPE_MASTER_TABLE ||          // AIN Subscriber Type Master Table
                 Idx == IDX_AIN_E1_MAPPING_TABLE ||              // AIN E1 Mapping Table
                 Idx == IDX_AIN_BASIC_TIME_RATE_TABLE) {         // AIN Basic Time Rate Table
                // Read only Field Record Type is '02'
                if ( iFldCnt == 1 && strcmp(pstr, "02") ) {
                    continue;
                }
            }

            // Find the Max Field Length
            for ( i = 0; i < iNofLoadFld; i++ ) {
                if ( iFldCnt == glb_MapdStat[Idx].vl_info.aiLoadFldId[i] ) {
                    if ( iFldLen > aiSizeFld[i] ) {
                        aiSizeFld[i] = iFldLen;
                    }
                }
            }
        }
        if ( iFldCnt < iMinInputFld ) {
            continue;
        }
        iRecCnt++;
    }
    if ( !iRecCnt ) {  // no valid records found
        return NO_CODE_LOADED;
    }

    // Calculate the memory size required
    iSizeHeadRec = sizeof(char *) * iNofLoadFld;
    iSizeHead = iSizeHeadRec * iRecCnt;
    iSizeRec = 0;

    for ( i = 0; i < iNofLoadFld; i++ ) {
        iSizeRec += aiSizeFld[i] + 1;
    }

    iSizeData = iRecCnt * iSizeRec;
    iTmp = iSizeHead + iSizeData;

    if ( Idx == IDX_BEARER_TABLE )                          // Bearer Table
        Temp = (char *)glb_BearerHead;
    else if ( Idx == IDX_COSTCODE_TABLE )                   // Cost Code Table
        Temp = (char *)glb_CostCodeHead;
    else if ( Idx == IDX_COSTGROUP_XREF_TABLE )             // Costgroup Xref Table
        Temp = (char *)glb_CostgroupXrefHead;
    else if ( Idx == IDX_SERVICE_KEY_TABLE )                // Service Key Table
        Temp = (char *)glb_ServiceKeyHead;
    else if ( Idx == IDX_PPS_DESC_TABLE )                   // PPS Desc Table
        Temp = (char *)glb_PpsDescHead;
    else if ( Idx == IDX_RATING_ELEMENT_TABLE )             // Rating Element Table
        Temp = (char *)glb_RatingElementHead;
    // Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007
    else if ( Idx == IDX_AIN_COSTCODE_TABLE )               // AIN Cost Code Table
        Temp = (char *)glb_AinCostCodeHead;
    else if ( Idx == IDX_AIN_OPER_CARRIER_MASTER_TABLE )    // AIN Operator Carrier Master Table
        Temp = (char *)glb_AinOperCarrierMasterHead;
    else if ( Idx == IDX_AIN_RATING_TARIFF_ELEMENT_TABLE )  // AIN Rating Tariff Element Table
        Temp = (char *)glb_AinRatingTariffElementHead;
    else if ( Idx == IDX_AIN_ROUTE_MASTER_TABLE )           // AIN Route Master Table
        Temp = (char *)glb_AinRouteMasterHead;
    else if ( Idx == IDX_AIN_SUBTYPE_MASTER_TABLE )         // AIN Subscriber Type Master Table
        Temp = (char *)glb_AinSubTypeHead;
    else if ( Idx == IDX_AIN_E1_MAPPING_TABLE )             // AIN E1 Mapping Table
        Temp = (char *)glb_AinE1MappingHead;
    else if ( Idx == IDX_AIN_BASIC_TIME_RATE_TABLE )
        Temp = (char *)glb_AinBasicTimeRateHead;
    else if ( Idx == IDX_WLAN_PACKAGE_TABLE )               // WLAN PACKAGE Table
        Temp = (char *)glb_WlanPackageHead;
    // Introduced IODC Mapping Table for support International Operator Direct Connection No. - by Kawee on 04-Dec-2007
    else if ( Idx == IDX_IODC_TABLE )
        Temp = (char *)glb_IodcHead;
    // Introduced IMSI Mapping Table for support convert NRTRDE IMSI to Mobile Number. - by Kawee on 11-Feb-2008
    else if ( Idx == IDX_IMSI_TABLE )                       // IMSI Table
        Temp = (char *)glb_ImsiHead;
    else if ( Idx == IDX_IMSI_VSO_TABLE )                   // IMSI VSO Table
        Temp = (char *)glb_ImsiVsoHead;
    else if ( Idx == IDX_FIX_RATE_TABLE )                   // FIX RATE Table - by Kawee on 19-Sep-2008
        Temp = (char *)glb_FixRateHead;
    else if ( Idx == IDX_REJ_ORIG_ADDR_TABLE )              // REJ ORIG ADDR Table - by Wiraphot on 07-Jan-2009
        Temp = (char *)glb_RejOrigAddrHead;
    else if ( Idx == IDX_APN_TABLE )                        // APN Table - by Watthikorn on 24-May-2010
        Temp = (char *)glb_ApnHead;
    else if ( Idx == IDX_3G_MAP_TABLE )
        Temp = (char *)glb_3GHead;                          // 3G/2G Service Mapping - by Thanakorn on Sep-2011
    else if ( Idx == IDX_TOLL_FREE_TABLE )
        Temp = (char *)glb_TollFreeHead;                    // Toll Free Mapping - by Thanakorn on Nov-2012
    else if ( Idx == IDX_ONE_LOVE_TABLE )
        Temp = (char *)glb_OneLoveHead;                     // One Love Mapping - by Thanakorn on Sep-2013
    else if ( Idx == IDX_BOS_IMEI_TABLE )
        Temp = (char *)glb_BosImeiHead;                     // BOS IMEI Mapping - by Thanakorn on 13-Nov-2013
    else if ( Idx == IDX_COSTCODE_BNO_TABLE )
        Temp = (char *)glb_CostcodeBNoHead;                 // Costcode Bno Mapping - by Thanakorn on 23-Apr-2014
    else if ( Idx == IDX_USMAP_TABLE )
        Temp = (char *)glb_UsMapHead;                       // USMAP Mapping - by Thanakorn on Sep-2016
    else if ( Idx == IDX_GEO_TABLE )
        Temp = (char *)glb_GeoHead;                        // Geo Mapping - by Thanakorn on Mar-2020
    else if ( Idx == IDX_CELLAREA_TABLE )
        Temp = (char *)glb_CellAreaHead;
    else if ( Idx == IDX_VASGROUP_TABLE )
        Temp = (char *)glb_VasGroupHead;

    // (Re)Allocate memory required for all Records
    if ( !glb_MapdStat[Idx].num_loads )  // First time loading
        Temp = (char *)malloc(iTmp);
    else                                // Not First time
        Temp = (char *)realloc(Temp, iTmp);

    if ( Temp == (char *)NULL)
        return LOAD_TABLE_FULL;

    memset(Temp, 0x00, iTmp);
    pchData = ((char *)Temp) + iSizeHead;
    ppchHead = (char **)Temp;
    for ( i = 0; i < iRecCnt; i++ ) {
        pstr = pchData + (iSizeRec * i);
        for ( j = 0; j < iNofLoadFld; j++ ) {
            if ( j != 0 ) {
                pstr += aiSizeFld[j-1] + 1;
            }
            ppchHead[i * iNofLoadFld + j] = pstr;
        }
    }

    // Save the newly allocated memory Pointer
    if ( Idx == IDX_BEARER_TABLE )                                      // Bearer Table
        glb_BearerHead = (BEARER_TABLE *)Temp;
    else if ( Idx == IDX_COSTCODE_TABLE )                               // Cost Code Table
        glb_CostCodeHead = (COSTCODE_TABLE *)Temp;
    else if ( Idx == IDX_COSTGROUP_XREF_TABLE )                         // Costgroup Xref Table
        glb_CostgroupXrefHead = (COSTGROUP_XREF_TABLE *)Temp;
    else if ( Idx == IDX_SERVICE_KEY_TABLE )                            // Service Key Table
        glb_ServiceKeyHead = (SERVICE_KEY_TABLE *)Temp;
    else if ( Idx == IDX_PPS_DESC_TABLE )                               // PPS Desc Table
        glb_PpsDescHead = (PPS_DESC_TABLE *)Temp;
    else if ( Idx == IDX_RATING_ELEMENT_TABLE )                         // Rating Element Table
        glb_RatingElementHead = (RATING_ELEMENT_TABLE *)Temp;
    // Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007
    else if ( Idx == IDX_AIN_COSTCODE_TABLE )                           // AIN Cost Code Table
        glb_AinCostCodeHead = (AIN_COSTCODE_TABLE *)Temp;
    else if ( Idx == IDX_AIN_OPER_CARRIER_MASTER_TABLE )                // AIN Operator Carrier Master Table
        glb_AinOperCarrierMasterHead = (AIN_OPER_CARRIER_MASTER_TABLE *)Temp;
    else if ( Idx == IDX_AIN_RATING_TARIFF_ELEMENT_TABLE )              // AIN Rating Tariff Element Table
        glb_AinRatingTariffElementHead = (AIN_RATING_TARIFF_ELEMENT_TABLE *)Temp;
    else if ( Idx == IDX_AIN_ROUTE_MASTER_TABLE )                       // AIN Route Master Table
        glb_AinRouteMasterHead = (AIN_ROUTE_MASTER_TABLE *)Temp;
    else if ( Idx == IDX_AIN_SUBTYPE_MASTER_TABLE )                     // AIN Subscriber Type Master Table
        glb_AinSubTypeHead = (AIN_SUB_TYPE_TABLE *)Temp;
    else if ( Idx == IDX_AIN_E1_MAPPING_TABLE )                         // AIN E1 Mapping Table
        glb_AinE1MappingHead = (AIN_E1_MAPPING_TABLE *)Temp;
    else if ( Idx == IDX_AIN_BASIC_TIME_RATE_TABLE )                    // AIN Basic Time Rate Table
        glb_AinBasicTimeRateHead = (AIN_BASIC_TIME_RATE_TABLE *)Temp;
    else if ( Idx == IDX_WLAN_PACKAGE_TABLE )                           // WLAN PACKAGE Table
        glb_WlanPackageHead = (WLAN_PACKAGE_TABLE *)Temp;
    // Introduced IODC Mapping Table for support International Operator Direct Connection No. - by Kawee on 04-Dec-2007
    else if ( Idx == IDX_IODC_TABLE )                                   // IODC Table
        glb_IodcHead = (IODC_TABLE *)Temp;
    // Introduced IMSI Mapping Table for support convert NRTRDE IMSI to Mobile Number. - by Kawee on 11-Feb-2008
    else if ( Idx == IDX_IMSI_TABLE )                                   // IMSI Table
        glb_ImsiHead = (IMSI_TABLE *)Temp;
    else if ( Idx == IDX_IMSI_VSO_TABLE )                               // IMSI VSO Table
        glb_ImsiVsoHead = (IMSI_VSO_TABLE *)Temp;
    else if ( Idx == IDX_FIX_RATE_TABLE )                               // FIX RATE Table - by Kawee on 19-Sep-2008
        glb_FixRateHead = (FIX_RATE_TABLE *)Temp;
    else if ( Idx == IDX_REJ_ORIG_ADDR_TABLE )                          // REJ ORIG ADDR Table - by Wiraphot on 07-Jan-2009
        glb_RejOrigAddrHead = (REJ_ORIG_ADDR_TABLE *)Temp;
    else if ( Idx == IDX_APN_TABLE )                                    // APN Table - by Watthikorn on 24-May-2010
        glb_ApnHead = (APN_TABLE *)Temp;
    else if ( Idx == IDX_3G_MAP_TABLE )                                 // 3G/2G Service Mapping Table - by Thanakorn on Sep-2011
        glb_3GHead = (SERVICE3G_TABLE *)Temp;
    else if ( Idx == IDX_TOLL_FREE_TABLE )                              // Toll Free Mapping Table - by Thanakorn on Nov-2012
        glb_TollFreeHead = (TOLLFREE_TABLE *)Temp;
    else if ( Idx == IDX_ONE_LOVE_TABLE )                               // One Love Mapping Table - by Thanakorn on Sep-2013
        glb_OneLoveHead = (ONE_LOVE_TABLE *)Temp;
    else if ( Idx == IDX_BOS_IMEI_TABLE )                               // BOS IMEI Mapping Table - by Thanakorn on 13-Nov-2013
        glb_BosImeiHead = (BOS_IMEI_TABLE *)Temp;
    else if ( Idx == IDX_COSTCODE_BNO_TABLE )                           // Costcode Bno Mapping Table - by Thanakorn on 23-Apr-2014
        glb_CostcodeBNoHead = (COSTCODE_BNO_TABLE *)Temp;
    else if ( Idx == IDX_USMAP_TABLE )
        glb_UsMapHead = (USMAP_TABLE *)Temp;
    else if ( Idx == IDX_GEO_TABLE )
        glb_GeoHead = (GEO_TABLE *)Temp;
    else if ( Idx == IDX_CELLAREA_TABLE )
        glb_CellAreaHead = (CELLAREA_TABLE *)Temp;
    else if ( Idx == IDX_VASGROUP_TABLE )
        glb_VasGroupHead = (VASGROUP_TABLE *)Temp;

    glb_MapdStat[Idx].tot_recs = 0;     // Total Reting Element
    fseek(fp, 0, SEEK_SET);             // re-wind the file pointer

    iRecCnt = 0;
    while ( 1 ) {
        // Initialize Temporary buffers
        memset(Input, 0x00, sizeof (Input));

        // read one record
        if ( !fgets((char *)Input, SIZE_LOADREC, fp) )  // eof
            break;

        if ( *Input == cComment )   // Comment Line
            continue;       // No need to Parse

        iFldCnt = 0;
        while ( 1 ) {
            if ( !iFldCnt )
                pstr = Get_StrTok(Input, cDelimiter);
            else
                pstr = Get_StrTok((char *)NULL, cDelimiter);

            if ( !pstr )    // No more Field
                break;

            iFldCnt++;
            Trim_Str(pstr);

            // Skip record the not record type "02"
            if ( Idx == IDX_COSTCODE_TABLE ||                   // Cost Code Table
                 Idx == IDX_COSTGROUP_XREF_TABLE ||             // Costgroup Xref Table
                 Idx == IDX_RATING_ELEMENT_TABLE ||             // Rating Element Table
                 // Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007
                 Idx == IDX_AIN_COSTCODE_TABLE ||               // AIN Cost Code Table
                 Idx == IDX_AIN_OPER_CARRIER_MASTER_TABLE ||    // AIN Operator Carrier Master Table
                 Idx == IDX_AIN_RATING_TARIFF_ELEMENT_TABLE ||  // AIN Rating Tariff Element Table
                 Idx == IDX_AIN_ROUTE_MASTER_TABLE ||           // AIN Route Master Table
                 Idx == IDX_AIN_SUBTYPE_MASTER_TABLE ||         // AIN Subscriber Type Master Table
                 Idx == IDX_AIN_E1_MAPPING_TABLE ||             // AIN E1 Mapping Table
                 Idx == IDX_AIN_BASIC_TIME_RATE_TABLE)
            {
                // Read only Field Record Type is '02'
                if ( iFldCnt == 1 && strcmp(pstr, "02") ) {
                    continue;
                }
            }

            // Keep the pointer to data
            for ( i = 0; i < iNofLoadFld; i++ ) {
                if ( iFldCnt == glb_MapdStat[Idx].vl_info.aiLoadFldId[i] ) {
                    apchFld[i] = pstr;
                    //
                    // Added below to Skip G and P prefix for mapping cell_id_a, cell_id_b
                    // - by Kawee on 21-Jun-2005
                    //
                    if ( (Idx == IDX_COSTCODE_TABLE) && (iFldCnt == 3) ) {  // Cost Code Field
                        if ( (pstr[0] == 'G' || pstr[0] == 'P' ) &&         // Start with G or P
                            Is_Number(pstr+1) ) {
                            apchFld[i] = pstr+1;
                        }
                    }
                }
            }
        }
        if ( iFldCnt < iMinInputFld )
            continue;

        for ( i = 0; i < iNofLoadFld; i++ ) {
            strcpy(ppchHead[iRecCnt * iNofLoadFld + i], apchFld[i]);
        }
        iRecCnt++;
        glb_MapdStat[Idx].tot_recs++;
    }   // end of while
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs )      // no record loaded
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE;     // successfully loaded
    glb_MapdStat[Idx].num_loads++;          // count this loading

    // Reset the Local Pointer to the first record
    if ( Idx == IDX_BEARER_TABLE ) {        // Bearer Table
        Temp = (char *)glb_BearerHead;
        qsort((BEARER_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(BEARER_TABLE), Cmp_Bearer);
    }
    else if ( Idx == IDX_COSTCODE_TABLE ) {   // Cost Code Table
        Temp = (char *)glb_CostCodeHead;
        qsort((COSTCODE_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(COSTCODE_TABLE), Cmp_CostCodeTable);

        // Set The Record that Banding_Model_Id and Cost_Code is duplicate have the Max Cost_Band_Id Value
        for ( iTmp = 1; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++ ) {
            if ( !strcmp(((COSTCODE_TABLE *)&ppchHead[iTmp * iNofLoadFld])->banding_model_id,
                    ((COSTCODE_TABLE *)&ppchHead[(iTmp-1) * iNofLoadFld])->banding_model_id) &&
                !strcmp(((COSTCODE_TABLE *)&ppchHead[iTmp * iNofLoadFld])->costcode,
                    ((COSTCODE_TABLE *)&ppchHead[(iTmp-1) * iNofLoadFld])->costcode) ) {

                //
                // Set The Record that Banding_Model_Id and Cost_Code is duplicate have the same
                // Costcode name and costcode description only Banding Model Id = 4 (CDG,USC)
                //  - Kawee on 15-Mar-2007
                //
                if ( !strcmp(((COSTCODE_TABLE *)&ppchHead[iTmp * iNofLoadFld])->banding_model_id, "4") ) {
                    strcpy(((COSTCODE_TABLE *)&ppchHead[iTmp * iNofLoadFld])->costcode_name,
                           ((COSTCODE_TABLE *)&ppchHead[(iTmp-1) * iNofLoadFld])->costcode_name);

                    strcpy(((COSTCODE_TABLE *)&ppchHead[iTmp * iNofLoadFld])->costcode_desc,
                           ((COSTCODE_TABLE *)&ppchHead[(iTmp-1) * iNofLoadFld])->costcode_desc);
                }

                strcpy(((COSTCODE_TABLE *)&ppchHead[iTmp * iNofLoadFld])->costgroup_id,
                       ((COSTCODE_TABLE *)&ppchHead[(iTmp-1) * iNofLoadFld])->costgroup_id);

                strcpy(((COSTCODE_TABLE *)&ppchHead[iTmp * iNofLoadFld])->cost_band_id,
                       ((COSTCODE_TABLE *)&ppchHead[(iTmp-1) * iNofLoadFld])->cost_band_id);
            }
        }
    }
    else if ( Idx == IDX_COSTGROUP_XREF_TABLE ) {   // Costgroup Xref Table
        Temp = (char *)glb_CostgroupXrefHead;
        qsort((COSTGROUP_XREF_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(COSTGROUP_XREF_TABLE), Cmp_CostgroupXref);
    }
    else if ( Idx == IDX_SERVICE_KEY_TABLE ) {        // Service Key Table
        Temp = (char *)glb_ServiceKeyHead;
        qsort((SERVICE_KEY_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(SERVICE_KEY_TABLE), Cmp_ServiceKey);
    }
    else if ( Idx == IDX_PPS_DESC_TABLE ) {           // PPS Desc Table
        Temp = (char *)glb_PpsDescHead;
        qsort((PPS_DESC_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(PPS_DESC_TABLE), Cmp_PpsDesc);
    }
    else if ( Idx == IDX_RATING_ELEMENT_TABLE ) {     // Rating Element Table
        Temp = (char *)glb_RatingElementHead;
        qsort((RATING_ELEMENT_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(RATING_ELEMENT_TABLE),Cmp_RatingElementKey);
    }
    // Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007
    else if ( Idx == IDX_AIN_COSTCODE_TABLE ) {       // AIN Cost Code Table
        Temp = (char *)glb_AinCostCodeHead;
        qsort((AIN_COSTCODE_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_COSTCODE_TABLE), Cmp_AinCostCodeKey2);
    }
    /* Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007 */
    else if ( Idx == IDX_AIN_OPER_CARRIER_MASTER_TABLE ) {    // AIN Operator Carrier Master Table
        Temp = (char *)glb_AinOperCarrierMasterHead;
        qsort((AIN_OPER_CARRIER_MASTER_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_OPER_CARRIER_MASTER_TABLE), Cmp_AinOperCarrierMasterKey);
    }
    // Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007
    else if ( Idx == IDX_AIN_RATING_TARIFF_ELEMENT_TABLE ) {  // AIN Rating Tariff Element Table
        Temp = (char *)glb_AinRatingTariffElementHead;
        qsort((AIN_RATING_TARIFF_ELEMENT_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_RATING_TARIFF_ELEMENT_TABLE), Cmp_AinRatingTariffElementTable);

        // Set The Record that Rating_Tariff_Id, Cost_Band_Id, and Modifier_Class_Id is duplicate have the Maximum Charge_Rate Value
        for ( iTmp = 1; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++ ) {
            if ( !strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)&ppchHead[iTmp * iNofLoadFld])->rating_tariff_id,
                    ((AIN_RATING_TARIFF_ELEMENT_TABLE *)&ppchHead[(iTmp-1) * iNofLoadFld])->rating_tariff_id) &&
                 !strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)&ppchHead[iTmp * iNofLoadFld])->cost_band_id,
                    ((AIN_RATING_TARIFF_ELEMENT_TABLE *)&ppchHead[(iTmp-1) * iNofLoadFld])->cost_band_id) &&
                 !strcmp(((AIN_RATING_TARIFF_ELEMENT_TABLE *)&ppchHead[iTmp * iNofLoadFld])->modifier_class_id,
                    ((AIN_RATING_TARIFF_ELEMENT_TABLE *)&ppchHead[(iTmp-1) * iNofLoadFld])->modifier_class_id) ) {

                strcpy(((AIN_RATING_TARIFF_ELEMENT_TABLE *)&ppchHead[iTmp * iNofLoadFld])->charge_rate,
                   ((AIN_RATING_TARIFF_ELEMENT_TABLE *)&ppchHead[(iTmp-1) * iNofLoadFld])->charge_rate);
            }
        }
    }
    // Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007
    else if ( Idx == IDX_AIN_ROUTE_MASTER_TABLE ) {         // AIN Route Master Table
        Temp = (char *)glb_AinRouteMasterHead;
        qsort((AIN_ROUTE_MASTER_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_ROUTE_MASTER_TABLE), Cmp_AinRouteMaster);
    }
    /* Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007 */
    else if ( Idx == IDX_AIN_SUBTYPE_MASTER_TABLE ) {       // AIN Subscriber Type Master Table
        Temp = (char *)glb_AinSubTypeHead;
        qsort((AIN_SUB_TYPE_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_SUB_TYPE_TABLE), Cmp_AinSubTypeMasterKey);
    }
    else if ( Idx == IDX_AIN_E1_MAPPING_TABLE ) {           // AIN E1 Mapping Table
        Temp = (char *)glb_AinE1MappingHead;
        qsort((AIN_E1_MAPPING_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_E1_MAPPING_TABLE), Cmp_AinE1MappingKey);
    }
    else if ( Idx == IDX_AIN_BASIC_TIME_RATE_TABLE ) {      // AIN Basic Time Rate Table
        Temp = (char *)glb_AinBasicTimeRateHead;
        qsort((AIN_BASIC_TIME_RATE_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(AIN_BASIC_TIME_RATE_TABLE), Cmp_AinBasicTimeRate);
    }
    else if ( Idx == IDX_WLAN_PACKAGE_TABLE ) {             // WLAN PACKAGE Table
        Temp = (char *)glb_WlanPackageHead;
        qsort((WLAN_PACKAGE_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(WLAN_PACKAGE_TABLE), Cmp_WlanPackageKey);
    }
    // Introduced IODC Mapping Table for support International Operator Direct Connection No. - by Kawee on 04-Dec-2007
    else if ( Idx == IDX_IODC_TABLE ) {                       // IODC Table
        Temp = (char *)glb_IodcHead;
        qsort((IODC_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(IODC_TABLE), Cmp_IodcKey);
    }
    // Introduced IMSI Mapping Table for support convert NRTRDE IMSI to Mobile Number. - by Kawee on 11-Feb-2008
    else if ( Idx == IDX_IMSI_TABLE ) {                       // IMSI Table
        Temp = (char *)glb_ImsiHead;
        qsort((IMSI_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(IMSI_TABLE), Cmp_ImsiKey);
    }
    // Introduced IMSI VSO Mapping Table for support VSO Project. - by Kawee on 15-Aug-2008
    else if ( Idx == IDX_IMSI_VSO_TABLE) {                   // IMSI VSO Table
        Temp = (char *)glb_ImsiVsoHead;
        qsort((IMSI_VSO_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(IMSI_VSO_TABLE), Cmp_ImsiVsoKey);
    }
    // Introduced FIX RATE Mapping Table for calculate charge in fix rate. - by Kawee on 19-Sep-2008
    else if ( Idx == IDX_FIX_RATE_TABLE ) {                   // FIX RATE Table
        Temp = (char *)glb_FixRateHead;
        qsort((FIX_RATE_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(FIX_RATE_TABLE), Cmp_FixRateKey);
    }
    // Introduced REJ ORIG ADDR Mapping Table for reject SMC CDR - by Wiraphot on 07-Jan-2009
    else if ( Idx == IDX_REJ_ORIG_ADDR_TABLE ) {              // REJ ORIG ADDR Table
        Temp = (char *)glb_RejOrigAddrHead;
        qsort((REJ_ORIG_ADDR_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(REJ_ORIG_ADDR_TABLE), Cmp_RejOrigAddr);
    }
    // Introduced APN Mapping Table for reject gprs cdr  - by Watthikorn on 24-May-2010
    else if ( Idx == IDX_APN_TABLE ) {                        // REJ ORIG ADDR Table
        Temp = (char *)glb_ApnHead;
        qsort((APN_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(APN_TABLE), Cmp_Apn);
    }
    // 3G/2G Service Mapping Table - by Thanakorn on Sep-2011
    else if ( Idx == IDX_3G_MAP_TABLE ) {
        Temp = (char *)glb_3GHead;
        qsort((SERVICE3G_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(SERVICE3G_TABLE), Cmp_3G);
    }
    // Toll Free Mapping Table - by Thanakorn on Nov-2012
    else if ( Idx == IDX_TOLL_FREE_TABLE ) {
        Temp = (char *)glb_TollFreeHead;
        qsort((TOLLFREE_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(TOLLFREE_TABLE), Cmp_TollFree);
    }
    // One Love Mapping Table - by Thanakorn on Sep-2013
    else if ( Idx == IDX_ONE_LOVE_TABLE ) {
        Temp = (char *)glb_OneLoveHead;
        qsort((ONE_LOVE_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(ONE_LOVE_TABLE), Cmp_OneLoveNum);
    }
    // BOS IMEI Mapping Table - by Thanakorn on 13-Nov-2013
    else if ( Idx == IDX_BOS_IMEI_TABLE ) {
        Temp = (char *)glb_BosImeiHead;
        qsort((BOS_IMEI_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(BOS_IMEI_TABLE), Cmp_Imei);
    }
    // Costcode Bno Mapping Table - by Thanakorn on 23-Apr-2014
    else if ( Idx == IDX_COSTCODE_BNO_TABLE ) {
        Temp = (char *)glb_CostcodeBNoHead;
        qsort((COSTCODE_BNO_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(COSTCODE_BNO_TABLE), Cmp_CostcodeBno);
    }
    // USMAP Table - by Thanakorn on Sep-2016
    else if ( Idx == IDX_USMAP_TABLE ) {
        Temp = (char *)glb_UsMapHead;
        qsort((USMAP_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(USMAP_TABLE), Cmp_UsMapTable);
    }
    else if ( Idx == IDX_GEO_TABLE ) {
        Temp = (char *)glb_GeoHead;
        qsort((GEO_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(GEO_TABLE), Cmp_GeoTable);
    }
    else if ( Idx == IDX_CELLAREA_TABLE ) {
        Temp = (char *)glb_CellAreaHead;
        qsort((CELLAREA_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(CELLAREA_TABLE), Cmp_CellAreaTable);
    }
    else if ( Idx == IDX_VASGROUP_TABLE ) {
        Temp = (char *)glb_VasGroupHead;
        qsort((VASGROUP_TABLE *)Temp, glb_MapdStat[Idx].tot_recs, sizeof(VASGROUP_TABLE), Cmp_VasGroupTable);
    }

#ifdef SHOW_LOAD_VARI
//if ( Idx == IDX_RATING_ELEMENT_TABLE) {} */
//if ( Idx == IDX_COSTCODE_TABLE) {} */                      /* Cost Code Table */
//if ( Idx == IDX_COSTGROUP_XREF_TABLE) {} */                /* Costgroup Xref Table */
//if ( Idx == IDX_SERVICE_KEY_TABLE) {} */                   /* Service Key Table */
//if ( Idx == IDX_PPS_DESC_TABLE) {} */                      /* PPS DESC Table */
//if ( Idx == IDX_RATING_ELEMENT_TABLE) {} */                /* Rating Element Table */
/* Introduced AIN CDR Type - Added below by Kawee on 29-Jan-2007 */
//if ( Idx == IDX_AIN_COSTCODE_TABLE) {} */                  /* AIN Cost Code Table */
//if ( Idx == IDX_AIN_OPER_CARRIER_MASTER_TABLE) {} */       /* AIN Operator Carrier Master Table */
//if ( Idx == IDX_AIN_RATING_TARIFF_ELEMENT_TABLE) {} */     /* AIN Rating Tariff Element Table */
//if ( Idx == IDX_AIN_ROUTE_MASTER_TABLE) {} */              /* AIN Route Master Table */
//if ( Idx == IDX_AIN_SUBTYPE_MASTER_TABLE) {} */            /* AIN Subscriber Type Master Table */
//if ( Idx == IDX_AIN_E1_MAPPING_TABLE) {} */                /* AIN E1 Mapping Table */
//if ( Idx == IDX_AIN_BASIC_TIME_RATE_TABLE) {} */           /* AIN Basic Time Rate Table */
//if ( Idx == IDX_WLAN_PACKAGE_TABLE) {} */                  /* WLAN PACKAGE Table */
//if ( Idx == IDX_IODC_TABLE) {} */                          /* IODC Table */
//if ( Idx == IDX_IMSI_TABLE) {} */                          /* IMSI Table */
//if ( Idx == IDX_IMSI_VSO_TABLE) {} */                      /* IMSI VSO Table */
//if ( Idx == IDX_FIX_RATE_TABLE) {} */                      /* FIX RATE Table */
//if ( Idx == IDX_3G_MAP_TABLE) {} */                        /* 3G/2G Service Mapping Table */
//if ( Idx == IDX_ONE_LOVE_TABLE) {} */                      /* One Love Mapping Table */
//if ( Idx == IDX_COSTCODE_BNO_TABLE) {                      /* Costcode Bno Mapping Table */
//if ( Idx == IDX_USMAP_TABLE) {                             /* USMAP Mapping Table */
//if ( Idx == IDX_GEO_TABLE ) {
//if ( Idx == IDX_CELLAREA_TABLE ) {
//if ( Idx == IDX_VASGROUP_TABLE ) {
if ( Idx == IDX_COSTCODE_TABLE) {
    for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++) {
        for (i = 0; i < iNofLoadFld-1; i++) {
            printf ("%s|",ppchHead[iTmp * iNofLoadFld + i]);
        }
        printf ("%s\n",ppchHead[iTmp * iNofLoadFld + i]);
    }
    Deb_Msg(glb_MsgText);
}
#endif
    return SUCCESS;

}

int Load_Plmn (int Idx)
{
    FILE    *fp;
    char    Input[SIZE_LOADREC+1];
    char    *pstr=NULL;
    int iTmp = 0, i;
    PLMN_CODE_TABLE plmn_tmp;
    PLMN_CODE_TABLE *Temp=NULL, *Temp2=NULL, *Temp3=NULL;        /* Local Pointer to Global Mobile cell_area Table */


    /* open input Data file */
    if ( (fp = fopen(glb_MapdStat[Idx].file_name, MODE_READ)) == NULL )
        return FILE_OPEN_ERROR;

    /* Count Valid Number of Records */
    while (fgets ((char *)Input, SIZE_LOADREC, fp) != NULL) {
        if ( *Input != '~')  /* Comment Line not counted */
            iTmp++;
    }
    /* Check added to avoid Shutdown during runtime - when the file is being copied daily - 18-Jul-2002 chamy */
    if ( !iTmp)  /* no valid records found */
        return NO_CODE_LOADED;

    /* Calculate the memory size required */
    iTmp = sizeof(PLMN_CODE_TABLE) * iTmp + sizeof(PLMN_CODE_TABLE);        /* 1 element extra for safety */

    Temp = glb_PlmnCodeHead;
    Temp2 = glb_PlmnPriceHead;
    Temp3 = glb_PlmnCountryHead;
    /* (Re)Allocate memory required for all Records */
    if ( !glb_MapdStat[Idx].num_loads) {     /* First time loading */
        Temp = (PLMN_CODE_TABLE *) malloc (iTmp);
        Temp2 = (PLMN_CODE_TABLE *) malloc (iTmp);
        Temp3 = (PLMN_CODE_TABLE *) malloc (iTmp);
    }
    else {      /* Not First time */
        Temp = (PLMN_CODE_TABLE *) realloc (Temp, iTmp);
        Temp2 = (PLMN_CODE_TABLE *) realloc (Temp, iTmp);
        Temp3 = (PLMN_CODE_TABLE *) realloc (Temp, iTmp);
    }

    if ( Temp == (PLMN_CODE_TABLE *)NULL)
        return LOAD_TABLE_FULL;
//printf("one table size = %d\n", sizeof(PLMN_CODE_TABLE));
//printf("full table size = %d\n", iTmp);

    /* Save the newly allocated memory Pointer */
    glb_PlmnCodeHead = Temp;
    glb_PlmnPriceHead = Temp2;
    glb_PlmnCountryHead = Temp3;

    memset(Temp, 0x00, iTmp);
    glb_MapdStat[Idx].tot_recs = 0;
    fseek (fp, 0, SEEK_SET);    /* re-wind the file pointer */

    while ( 1 ) {
        /* Initialize Temporary buffers */
        memset(Input, 0x00, sizeof (Input));
        memset(&plmn_tmp, 0x00, sizeof(plmn_tmp));

        /* read one record */
        if ( !fgets ((char *)Input, SIZE_LOADREC, fp)) /* eof */
            break;

        if ( *Input == '~')      /* Comment Line */
            continue;       /* No need to Parse */

        /* Parse the fields (delimiter is #) */
        if ( (pstr = strtok(Input, "|" )) != NULL) {

            strncpy(plmn_tmp.plmn, pstr, 5);   /* Numbering Plan Code */
            plmn_tmp.plmn[5] = 0;
            Trim_Str(plmn_tmp.plmn);

            i = 1;
            while ( (pstr = strtok((char *)NULL, "|" )) ) {
                switch ( i ) {
                    case 1: /* cell are */
                        strncpy(plmn_tmp.cell_area, pstr, 5);
                        Trim_Str(plmn_tmp.cell_area);
                        break;
                    case 2:
                        strncpy(plmn_tmp.carrier_code, pstr, 5);
                        Trim_Str(plmn_tmp.carrier_code);
                        break;
                    case 3:
                        strncpy(plmn_tmp.country_code, pstr, 4);
                        Trim_Str(plmn_tmp.country_code);
                        break;
                    case 4:
                        plmn_tmp.n_chr_moc_local = atof(pstr);
                        break;
                    case 5:
                        plmn_tmp.n_chr_moc_to_th = atof(pstr);
                        break;
                    case 6:
                        plmn_tmp.n_chr_moc_inter = atof(pstr);
                        break;
                    case 7:
                        plmn_tmp.n_chr_mtc = atof(pstr);
                        break;
                    case 8:
                        plmn_tmp.n_chr_smso = atof(pstr);
                        break;
                    case 9:
                        plmn_tmp.n_utc_offset = atof(pstr);
                        break;
                    case 10:
                        plmn_tmp.n_chr_gprs = atof(pstr);
                        break;
                    case 11:
                        plmn_tmp.n_gprs_min = atof(pstr);
                        break;
                    case 12:
                        plmn_tmp.n_gprs_rnd = atof(pstr);
                        break;
                }
                i++;
            }
            /* Add to Mobile cell_area Table */
            strcpy(Temp->plmn, plmn_tmp.plmn);
            strcpy(Temp->cell_area, plmn_tmp.cell_area);
            strcpy(Temp->carrier_code, plmn_tmp.carrier_code);
            strcpy(Temp->country_code, plmn_tmp.country_code);
            Temp->n_chr_moc_local = plmn_tmp.n_chr_moc_local;
            Temp->n_chr_moc_to_th = plmn_tmp.n_chr_moc_to_th;
            Temp->n_chr_moc_inter = plmn_tmp.n_chr_moc_inter;
            Temp->n_chr_mtc = plmn_tmp.n_chr_mtc;
            Temp->n_chr_smso = plmn_tmp.n_chr_smso;
            Temp->n_utc_offset = plmn_tmp.n_utc_offset;
            Temp->n_chr_gprs = plmn_tmp.n_chr_gprs;
            Temp->n_gprs_min = plmn_tmp.n_gprs_min;
            Temp->n_gprs_rnd = plmn_tmp.n_gprs_rnd;
            glb_MapdStat[Idx].tot_recs++;   /* count */
            Temp++;
        }
    }
    fclose(fp);

    if ( !glb_MapdStat[Idx].tot_recs)    /* no record loaded */
        return NO_CODE_LOADED;

    glb_MapdStat[Idx].load_stat = TRUE; /* successfully loaded */
    glb_MapdStat[Idx].num_loads++;      /* count this loading */

    /* Copy all content of glb_PlmnCodeHead to glb_PlmnPriceHead */
    memcpy(glb_PlmnPriceHead, glb_PlmnCodeHead, iTmp);
    /* Copy all content of glb_PlmnCodeHead to glb_PlmnCountryHead */
    memcpy(glb_PlmnCountryHead, glb_PlmnCodeHead, iTmp);

    /* ----------- prepare pricing table base on country code ----------- */
    /* Sort glb_PlmnCountryHead table by country_code field */
    glb_nCountryCodeRec = glb_MapdStat[Idx].tot_recs;   /* assigned current record count first, (before this value is changed) */

    /* ----------- prepare pricing table base on CARRIER code ----------- */
    /* Sort glb_PlmnPriceHead table by carrier field */
    qsort((PLMN_CODE_TABLE *)glb_PlmnPriceHead, glb_MapdStat[Idx].tot_recs, sizeof(PLMN_CODE_TABLE), Cmp_Carrier);
    /* Pre-process average value for the first 3 character of carrier code */
    glb_nCarrierPriceRec = preproc_avg_price_carrier(glb_MapdStat[Idx].tot_recs);
    /* Re-sort glb_PlmnPriceHead table by carrier field */
    qsort((PLMN_CODE_TABLE *)glb_PlmnPriceHead, glb_nCarrierPriceRec, sizeof(PLMN_CODE_TABLE), Cmp_Carrier);
    qsort((PLMN_CODE_TABLE *)glb_PlmnCountryHead, glb_nCountryCodeRec, sizeof(PLMN_CODE_TABLE), Cmp_CountryCode);  /* sort after append averge table value */

    /* ----------- prepare pricing table base on PLMN code ----------- */
    /* Sort glb_PlmnCodeHead table by plmn field */
    qsort((PLMN_CODE_TABLE *)glb_PlmnCodeHead, glb_MapdStat[Idx].tot_recs, sizeof(PLMN_CODE_TABLE), Cmp_Plmn);
    /* Pre-process average value for the first 3 character of plmn code */
    iTmp = preproc_avg_price_plmn(glb_MapdStat[Idx].tot_recs);
    /* Re-sort glb_PlmnCodeHead table by plmn field */
    qsort((PLMN_CODE_TABLE *)glb_PlmnCodeHead, iTmp, sizeof(PLMN_CODE_TABLE), Cmp_Plmn);

    glb_MapdStat[Idx].tot_recs = iTmp;      // re-assign new total record of plmn table

#ifdef _SHOW_LOAD_CARRIER_
Temp2 = glb_PlmnCountryHead;
i = glb_nCountryCodeRec;
for (iTmp = 0; iTmp < i; iTmp++, Temp2++) {
    printf ("[%s][%s][%s][%s] %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f \n",
    Temp2->carrier_code, Temp2->plmn, Temp2->cell_area, Temp2->country_code,
    Temp2->n_chr_moc_local, Temp2->n_chr_moc_to_th, Temp2->n_chr_moc_inter,
    Temp2->n_chr_mtc,  Temp2->n_chr_smso,  Temp2->n_utc_offset,
    Temp2->n_chr_gprs,  Temp2->n_gprs_min, Temp2->n_gprs_rnd);
}
Deb_Msg(glb_MsgText);
printf(" - Total record count = %d\n", glb_nCountryCodeRec);
printf("-------------------------\n");
#endif

#ifdef _SHOW_LOAD_PLMN_
Temp = glb_PlmnCodeHead;
for (iTmp = 0; iTmp < glb_MapdStat[Idx].tot_recs; iTmp++, Temp++) {
    printf ("[%s][%s][%s][%s] %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f \n",
    Temp->plmn, Temp->carrier_code, Temp->cell_area, Temp->country_code,
    Temp->n_chr_moc_local, Temp->n_chr_moc_to_th, Temp->n_chr_moc_inter,
    Temp->n_chr_mtc, Temp->n_chr_smso, Temp->n_utc_offset,
    Temp->n_chr_gprs, Temp->n_gprs_min, Temp->n_gprs_rnd);
}
Deb_Msg(glb_MsgText);
printf("PLMN - Total record count = %d\n", glb_MapdStat[Idx].tot_recs);
printf("-------------------------\n");
#endif

    return SUCCESS;
}


int Cmp_Plmn(const void *ptr1, const void *ptr2)
{
    return (strcmp(((PLMN_CODE_TABLE *)ptr1)->plmn, ((PLMN_CODE_TABLE *)ptr2)->plmn));
}

int Cmp_Carrier(const void *ptr1, const void *ptr2)
{
    return (strcmp(((PLMN_CODE_TABLE *)ptr1)->carrier_code, ((PLMN_CODE_TABLE *)ptr2)->carrier_code));
}

int Cmp_CountryCode(const void *ptr1, const void *ptr2)
{
    return (strcmp(((PLMN_CODE_TABLE *)ptr1)->country_code, ((PLMN_CODE_TABLE *)ptr2)->country_code));
}

int Get_CellArea (const char *plmn_code, char *cell_area, char *country_code)
{
    PLMN_CODE_TABLE *Temp = NULL;

    if ( *plmn_code == '\0' )  return FAILURE;

    Temp = glb_PlmnCodeHead;    /* Use Country Table */

    /* Do binary search on the Country Table */
    Temp = (PLMN_CODE_TABLE *)bsearch (plmn_code, Temp, glb_MapdStat[IDX_PLMN_CODE_TABLE].tot_recs, sizeof(PLMN_CODE_TABLE), Cmp_Plmn);

    if ( Temp == (PLMN_CODE_TABLE *)NULL) {      /* not found */
        strcpy(cell_area, "");
        return FAILURE;
    }
    else {
        strcpy(cell_area, Temp->cell_area);
        strcpy(country_code, Temp->country_code);
    }
    return SUCCESS;
}

int Get_CountryCode(char *country_code, int chr_type, double *price, char *plmn, char *cell_area)
{
    PLMN_CODE_TABLE *Temp = NULL;
    PLMN_CODE_TABLE Key;

    Temp = glb_PlmnCountryHead;
    memset(&Key, 0x00, sizeof(Key));

    strcpy(Key.country_code, country_code);

    Temp = (PLMN_CODE_TABLE*)bsearch(&Key, Temp, glb_nCountryCodeRec, sizeof(PLMN_CODE_TABLE), Cmp_CountryCode);
    if ( Temp == (PLMN_CODE_TABLE*)NULL) {   /* no output returned */
        Temp = glb_PlmnCountryHead;
        strcpy(Key.country_code, "#AVG");
        Temp = (PLMN_CODE_TABLE*)bsearch(&Key, Temp, glb_nCountryCodeRec, sizeof(PLMN_CODE_TABLE), Cmp_CountryCode);
        if ( Temp == (PLMN_CODE_TABLE*)NULL) {   /* no output returned */
            return FAILURE;
        }
    }

    switch (chr_type) {
        case CHR_MOC_LOCAL:
            *price = Temp->n_chr_moc_local;
            break;
        case CHR_MOC_TO_TH:
            *price = Temp->n_chr_moc_to_th;
            break;
        case CHR_MOC_INTER:
            *price = Temp->n_chr_moc_inter;
            break;
        case CHR_MTC:
            *price = Temp->n_chr_mtc;
            break;
        case CHR_SMSO:
            *price = Temp->n_chr_smso;
            break;
        default:
            return FAILURE;
            break;
    }
    strncpy(plmn, Temp->plmn, 3);
    strcpy(cell_area, Temp->cell_area);

    return SUCCESS;
}

int preproc_avg_price_carrier(int nrec)
{
    /* Reference fields for plmn (calculate average)
    plmn;             0
    cell_area;        1
    carrier_code;     2   <- Compare using this field
    country_code;     3
    chr_moc_local;    4   <- use from this field
    chr_moc_to_th;    5
    chr_moc_inter;    6
    chr_mtc;          7
    chr_smso;         8
    utc_offset;       9   <- skip this field
    chr_gprs;         10
    gprs_min;         11
    gprs_rnd;         12  <- use til this field
    */

    int iTmp, i, dupcnt = 0, curr_rec_num;
    int tot_rec = nrec;
    PLMN_CODE_TABLE plmn_tmp, plmn_tmp2;
    PLMN_CODE_TABLE *Temp=NULL, *Temp2 = NULL, *Temp3 = NULL;

    memset(&plmn_tmp, 0x00, sizeof(plmn_tmp));      /* avarage for match first 3 carrier_code */
    memset(&plmn_tmp2, 0x00, sizeof(plmn_tmp2));    /* avarage all table */
    Temp = glb_PlmnPriceHead;
    curr_rec_num = nrec;
    iTmp = sizeof(PLMN_CODE_TABLE) * curr_rec_num + sizeof(PLMN_CODE_TABLE);

    for ( i = 0; i < tot_rec; i++, Temp++) {
            plmn_tmp2.n_chr_moc_local += Temp->n_chr_moc_local;
            plmn_tmp2.n_chr_moc_to_th += Temp->n_chr_moc_to_th;
            plmn_tmp2.n_chr_moc_inter += Temp->n_chr_moc_inter;
            plmn_tmp2.n_chr_mtc += Temp->n_chr_mtc;
            plmn_tmp2.n_chr_smso += Temp->n_chr_smso;
            plmn_tmp2.n_utc_offset += Temp->n_utc_offset;
            plmn_tmp2.n_chr_gprs += Temp->n_chr_gprs;
            plmn_tmp2.n_gprs_min += Temp->n_gprs_min;
            plmn_tmp2.n_gprs_rnd += Temp->n_gprs_rnd;
        if ( strncmp(Temp->carrier_code, plmn_tmp.carrier_code, 3) == 0 ) {
            dupcnt++;
            plmn_tmp.n_chr_moc_local += Temp->n_chr_moc_local;
            plmn_tmp.n_chr_moc_to_th += Temp->n_chr_moc_to_th;
            plmn_tmp.n_chr_moc_inter += Temp->n_chr_moc_inter;
            plmn_tmp.n_chr_mtc += Temp->n_chr_mtc;
            plmn_tmp.n_chr_smso += Temp->n_chr_smso;
            plmn_tmp.n_utc_offset += Temp->n_utc_offset;
            plmn_tmp.n_chr_gprs += Temp->n_chr_gprs;
            plmn_tmp.n_gprs_min += Temp->n_gprs_min;
            plmn_tmp.n_gprs_rnd += Temp->n_gprs_rnd;
        }
        else {
            if ( dupcnt > 1 ) {
                Temp2 = glb_PlmnPriceHead;
//printf("A:Temp2 = %d, glb_PlmnPriceHead = %d\n", Temp2, glb_PlmnPriceHead);
                iTmp += sizeof(PLMN_CODE_TABLE);
                Temp2 = (PLMN_CODE_TABLE *) realloc (Temp2, iTmp);
                glb_PlmnPriceHead = Temp2;      /* re-assign first address of new allocated space back to glb_PlmnPriceHead */
                Temp2 += curr_rec_num;
//printf("B:Temp2 = %d, glb_PlmnPriceHead = %d, iTmp = %d, curr_rec_num = %d\n", Temp2, glb_PlmnPriceHead, iTmp, curr_rec_num);
                curr_rec_num++;
                strncpy(Temp2->plmn, plmn_tmp.plmn, 3);    Temp2->plmn[3] = 0;
                strcpy(Temp2->cell_area, plmn_tmp.cell_area);
                strncpy(Temp2->carrier_code, plmn_tmp.carrier_code, 3); Temp2->carrier_code[3] = 0;
                strcpy(Temp2->country_code, plmn_tmp.country_code);
                Temp2->n_chr_moc_local = plmn_tmp.n_chr_moc_local/dupcnt;
                Temp2->n_chr_moc_to_th = plmn_tmp.n_chr_moc_to_th/dupcnt;
                Temp2->n_chr_moc_inter = plmn_tmp.n_chr_moc_inter/dupcnt;
                Temp2->n_chr_mtc = plmn_tmp.n_chr_mtc/dupcnt;
                Temp2->n_chr_smso = plmn_tmp.n_chr_smso/dupcnt;
                Temp2->n_utc_offset = plmn_tmp.n_utc_offset/dupcnt;
                Temp2->n_chr_gprs = plmn_tmp.n_chr_gprs/dupcnt;
                Temp2->n_gprs_min = plmn_tmp.n_gprs_min/dupcnt;
                Temp2->n_gprs_rnd = plmn_tmp.n_gprs_rnd/dupcnt;
            }
            dupcnt = 1;
            strcpy(plmn_tmp.plmn, Temp->plmn);
            strcpy(plmn_tmp.cell_area, Temp->cell_area);
            strcpy(plmn_tmp.carrier_code, Temp->carrier_code);
            strcpy(plmn_tmp.country_code, Temp->country_code);
            plmn_tmp.n_chr_moc_local = Temp->n_chr_moc_local;
            plmn_tmp.n_chr_moc_to_th = Temp->n_chr_moc_to_th;
            plmn_tmp.n_chr_moc_inter = Temp->n_chr_moc_inter;
            plmn_tmp.n_chr_mtc = Temp->n_chr_mtc;
            plmn_tmp.n_chr_smso = Temp->n_chr_smso;
            plmn_tmp.n_utc_offset = Temp->n_utc_offset;
            plmn_tmp.n_chr_gprs = Temp->n_chr_gprs;
            plmn_tmp.n_gprs_min = Temp->n_gprs_min;
            plmn_tmp.n_gprs_rnd = Temp->n_gprs_rnd;
        }
    }
    if ( dupcnt > 1 ) {
        Temp2 = glb_PlmnPriceHead;
        iTmp += sizeof(PLMN_CODE_TABLE);
        Temp2 = (PLMN_CODE_TABLE *) realloc (Temp2, iTmp);
        glb_PlmnPriceHead = Temp2;      /* re-assign first address of new allocated space back to glb_PlmnPriceHead */
        Temp2 += curr_rec_num;
        curr_rec_num++;
        strncpy(Temp2->plmn, plmn_tmp.plmn, 3);    Temp2->plmn[3] = 0;
        strcpy(Temp2->cell_area,    plmn_tmp.cell_area);
        strncpy(Temp2->carrier_code, plmn_tmp.carrier_code, 3); Temp2->carrier_code[3] = 0;
        strcpy(Temp2->country_code, plmn_tmp.country_code);
        Temp2->n_chr_moc_local = plmn_tmp.n_chr_moc_local/dupcnt;
        Temp2->n_chr_moc_to_th = plmn_tmp.n_chr_moc_to_th/dupcnt;
        Temp2->n_chr_moc_inter = plmn_tmp.n_chr_moc_inter/dupcnt;
        Temp2->n_chr_mtc = plmn_tmp.n_chr_mtc/dupcnt;
        Temp2->n_chr_smso = plmn_tmp.n_chr_smso/dupcnt;
        Temp2->n_utc_offset = plmn_tmp.n_utc_offset/dupcnt;
        Temp2->n_chr_gprs = plmn_tmp.n_chr_gprs/dupcnt;
        Temp2->n_gprs_min = plmn_tmp.n_gprs_min/dupcnt;
        Temp2->n_gprs_rnd = plmn_tmp.n_gprs_rnd/dupcnt;
    }
    Temp2 = glb_PlmnPriceHead;
    iTmp += sizeof(PLMN_CODE_TABLE);
    Temp2 = (PLMN_CODE_TABLE *) realloc (Temp2, iTmp);
    glb_PlmnPriceHead = Temp2;
    Temp2 += curr_rec_num;
    curr_rec_num++;
    strcpy(Temp2->plmn, "#AVG");
    strcpy(Temp2->cell_area,    "00000");
    strcpy(Temp2->carrier_code, "#AVG");
    strcpy(Temp2->country_code, "0000");
    Temp2->n_chr_moc_local = plmn_tmp2.n_chr_moc_local/tot_rec;
    Temp2->n_chr_moc_to_th = plmn_tmp2.n_chr_moc_to_th/tot_rec;
    Temp2->n_chr_moc_inter = plmn_tmp2.n_chr_moc_inter/tot_rec;
    Temp2->n_chr_mtc = plmn_tmp2.n_chr_mtc/tot_rec;
    Temp2->n_chr_smso = plmn_tmp2.n_chr_smso/tot_rec;
    Temp2->n_utc_offset = plmn_tmp2.n_utc_offset/tot_rec;
    Temp2->n_chr_gprs = plmn_tmp2.n_chr_gprs/tot_rec;
    Temp2->n_gprs_min = plmn_tmp2.n_gprs_min/tot_rec;
    Temp2->n_gprs_rnd = plmn_tmp2.n_gprs_rnd/tot_rec;

    /* Append 'Average All Table' value to glb_PlmnCountryHead (just 1 record) */
    Temp3 = glb_PlmnCountryHead;
    iTmp = (sizeof(PLMN_CODE_TABLE) * (glb_nCountryCodeRec+1));
    Temp3 = (PLMN_CODE_TABLE *) realloc (Temp3, iTmp);
    glb_PlmnCountryHead = Temp3;
    glb_nCountryCodeRec += 1;
    strcpy(Temp3->plmn, "#AVG");
    strcpy(Temp3->cell_area,    "00000");
    strcpy(Temp3->carrier_code, "#AVG");
    strcpy(Temp3->country_code, "#AVG");
    Temp3->n_chr_moc_local = plmn_tmp2.n_chr_moc_local/tot_rec;
    Temp3->n_chr_moc_to_th = plmn_tmp2.n_chr_moc_to_th/tot_rec;
    Temp3->n_chr_moc_inter = plmn_tmp2.n_chr_moc_inter/tot_rec;
    Temp3->n_chr_mtc = plmn_tmp2.n_chr_mtc/tot_rec;
    Temp3->n_chr_smso = plmn_tmp2.n_chr_smso/tot_rec;
    Temp3->n_utc_offset = plmn_tmp2.n_utc_offset/tot_rec;
    Temp3->n_chr_gprs = plmn_tmp2.n_chr_gprs/tot_rec;
    Temp3->n_gprs_min = plmn_tmp2.n_gprs_min/tot_rec;
    Temp3->n_gprs_rnd = plmn_tmp2.n_gprs_rnd/tot_rec;

    return curr_rec_num;
}

int preproc_avg_price_plmn(int nrec)
{
    /* Reference fields for plmn (calculate average)
    plmn;             0   <- Compare using this field
    cell_area;        1
    carrier_code;     2
    country_code;     3
    chr_moc_local;    4   <- use from this field
    chr_moc_to_th;    5
    chr_moc_inter;    6
    chr_mtc;          7
    chr_smso;         8
    utc_offset;       9   <- skip this field
    chr_gprs;         10
    gprs_min;         11
    gprs_rnd;         12  <- use til this field
    */

    int iTmp, i, dupcnt = 0, curr_rec_num;
    int tot_rec = nrec;
    PLMN_CODE_TABLE plmn_tmp, plmn_tmp2;
    PLMN_CODE_TABLE *Temp=NULL, *Temp2 = NULL;

    memset(&plmn_tmp, 0x00, sizeof(plmn_tmp));      /* avarage for match first 3 plmn */
    memset(&plmn_tmp2, 0x00, sizeof(plmn_tmp2));    /* avarage all table */
    Temp = glb_PlmnCodeHead;
    curr_rec_num = nrec;
    iTmp = sizeof(PLMN_CODE_TABLE) * curr_rec_num + sizeof(PLMN_CODE_TABLE);

    for ( i = 0; i < tot_rec; i++, Temp++) {
            plmn_tmp2.n_chr_moc_local += Temp->n_chr_moc_local;
            plmn_tmp2.n_chr_moc_to_th += Temp->n_chr_moc_to_th;
            plmn_tmp2.n_chr_moc_inter += Temp->n_chr_moc_inter;
            plmn_tmp2.n_chr_mtc += Temp->n_chr_mtc;
            plmn_tmp2.n_chr_smso += Temp->n_chr_smso;
            plmn_tmp2.n_utc_offset += Temp->n_utc_offset;
            plmn_tmp2.n_chr_gprs += Temp->n_chr_gprs;
            plmn_tmp2.n_gprs_min += Temp->n_gprs_min;
            plmn_tmp2.n_gprs_rnd += Temp->n_gprs_rnd;
        if ( strncmp(Temp->plmn, plmn_tmp.plmn, 3) == 0 ) {
            dupcnt++;
            plmn_tmp.n_chr_moc_local += Temp->n_chr_moc_local;
            plmn_tmp.n_chr_moc_to_th += Temp->n_chr_moc_to_th;
            plmn_tmp.n_chr_moc_inter += Temp->n_chr_moc_inter;
            plmn_tmp.n_chr_mtc += Temp->n_chr_mtc;
            plmn_tmp.n_chr_smso += Temp->n_chr_smso;
            plmn_tmp.n_utc_offset += Temp->n_utc_offset;
            plmn_tmp.n_chr_gprs += Temp->n_chr_gprs;
            plmn_tmp.n_gprs_min += Temp->n_gprs_min;
            plmn_tmp.n_gprs_rnd += Temp->n_gprs_rnd;
        }
        else {
            if ( dupcnt > 1 ) {
                Temp2 = glb_PlmnCodeHead;
//printf("A:Temp2 = %d, glb_PlmnCodeHead = %d\n", Temp2, glb_PlmnCodeHead);
                iTmp += sizeof(PLMN_CODE_TABLE);
                Temp2 = (PLMN_CODE_TABLE *) realloc (Temp2, iTmp);
                glb_PlmnCodeHead = Temp2;   /* re-assign first address of new allocated space back to glb_PlmnCodeHead */
                Temp2 += curr_rec_num;
//printf("B:Temp2 = %d, glb_PlmnCodeHead = %d, iTmp = %d, curr_rec_num = %d\n", Temp2, glb_PlmnCodeHead, iTmp, curr_rec_num);
                curr_rec_num++;
                strncpy(Temp2->plmn, plmn_tmp.plmn, 3);    Temp2->plmn[3] = 0;
                strcpy(Temp2->cell_area,    plmn_tmp.cell_area);
                strncpy(Temp2->carrier_code, plmn_tmp.carrier_code, 3);     Temp2->carrier_code[3] = 0;
                strcpy(Temp2->country_code, plmn_tmp.country_code);
                Temp2->n_chr_moc_local = plmn_tmp.n_chr_moc_local/dupcnt;
                Temp2->n_chr_moc_to_th = plmn_tmp.n_chr_moc_to_th/dupcnt;
                Temp2->n_chr_moc_inter = plmn_tmp.n_chr_moc_inter/dupcnt;
                Temp2->n_chr_mtc = plmn_tmp.n_chr_mtc/dupcnt;
                Temp2->n_chr_smso = plmn_tmp.n_chr_smso/dupcnt;
                Temp2->n_utc_offset = plmn_tmp.n_utc_offset/dupcnt;
                Temp2->n_chr_gprs = plmn_tmp.n_chr_gprs/dupcnt;
                Temp2->n_gprs_min = plmn_tmp.n_gprs_min/dupcnt;
                Temp2->n_gprs_rnd = plmn_tmp.n_gprs_rnd/dupcnt;
            }
            dupcnt = 1;
            strcpy(plmn_tmp.plmn, Temp->plmn);
            strcpy(plmn_tmp.cell_area,    Temp->cell_area);
            strcpy(plmn_tmp.carrier_code, Temp->carrier_code);
            strcpy(plmn_tmp.country_code, Temp->country_code);
            plmn_tmp.n_chr_moc_local = Temp->n_chr_moc_local;
            plmn_tmp.n_chr_moc_to_th = Temp->n_chr_moc_to_th;
            plmn_tmp.n_chr_moc_inter = Temp->n_chr_moc_inter;
            plmn_tmp.n_chr_mtc = Temp->n_chr_mtc;
            plmn_tmp.n_chr_smso = Temp->n_chr_smso;
            plmn_tmp.n_utc_offset = Temp->n_utc_offset;
            plmn_tmp.n_chr_gprs = Temp->n_chr_gprs;
            plmn_tmp.n_gprs_min = Temp->n_gprs_min;
            plmn_tmp.n_gprs_rnd = Temp->n_gprs_rnd;
        }
    }
    if ( dupcnt > 1 ) {
        Temp2 = glb_PlmnCodeHead;
        iTmp += sizeof(PLMN_CODE_TABLE);
        Temp2 = (PLMN_CODE_TABLE *) realloc (Temp2, iTmp);
        glb_PlmnCodeHead = Temp2;   /* re-assign first address of new allocated space back to glb_PlmnCodeHead */
        Temp2 += curr_rec_num;
        curr_rec_num++;
        strncpy(Temp2->plmn, plmn_tmp.plmn, 3);    Temp2->plmn[3] = 0;
        strcpy(Temp2->cell_area,    plmn_tmp.cell_area);
        strncpy(Temp2->carrier_code, plmn_tmp.carrier_code, 3);     Temp2->carrier_code[3] = 0;
        strcpy(Temp2->country_code, plmn_tmp.country_code);
        Temp2->n_chr_moc_local = plmn_tmp.n_chr_moc_local/dupcnt;
        Temp2->n_chr_moc_to_th = plmn_tmp.n_chr_moc_to_th/dupcnt;
        Temp2->n_chr_moc_inter = plmn_tmp.n_chr_moc_inter/dupcnt;
        Temp2->n_chr_mtc = plmn_tmp.n_chr_mtc/dupcnt;
        Temp2->n_chr_smso = plmn_tmp.n_chr_smso/dupcnt;
        Temp2->n_utc_offset = plmn_tmp.n_utc_offset/dupcnt;
        Temp2->n_chr_gprs = plmn_tmp.n_chr_gprs/dupcnt;
        Temp2->n_gprs_min = plmn_tmp.n_gprs_min/dupcnt;
        Temp2->n_gprs_rnd = plmn_tmp.n_gprs_rnd/dupcnt;
    }
    Temp2 = glb_PlmnCodeHead;
    iTmp += sizeof(PLMN_CODE_TABLE);
    Temp2 = (PLMN_CODE_TABLE *) realloc (Temp2, iTmp);
    glb_PlmnCodeHead = Temp2;
    Temp2 += curr_rec_num;
    curr_rec_num++;
    strcpy(Temp2->plmn, "#AVG");
    strcpy(Temp2->cell_area,    "00000");
    strcpy(Temp2->carrier_code, "#AVG");
    strcpy(Temp2->country_code, "0000");
    Temp2->n_chr_moc_local = plmn_tmp2.n_chr_moc_local/tot_rec;
    Temp2->n_chr_moc_to_th = plmn_tmp2.n_chr_moc_to_th/tot_rec;
    Temp2->n_chr_moc_inter = plmn_tmp2.n_chr_moc_inter/tot_rec;
    Temp2->n_chr_mtc = plmn_tmp2.n_chr_mtc/tot_rec;
    Temp2->n_chr_smso = plmn_tmp2.n_chr_smso/tot_rec;
    Temp2->n_utc_offset = plmn_tmp2.n_utc_offset/tot_rec;
    Temp2->n_chr_gprs = plmn_tmp2.n_chr_gprs/tot_rec;
    Temp2->n_gprs_min = plmn_tmp2.n_gprs_min/tot_rec;
    Temp2->n_gprs_rnd = plmn_tmp2.n_gprs_rnd/tot_rec;

    return curr_rec_num;
}


int Get_CellAreaFromCarrier(char *carrier_code, char *cell_area, char *plmn, char *country_code)
{
    PLMN_CODE_TABLE *Temp = NULL;
    PLMN_CODE_TABLE Key;

    Temp = glb_PlmnPriceHead;
    memset(&Key, 0x00, sizeof(Key));

    strcpy(Key.carrier_code, carrier_code);

    Temp = bsearch(&Key, Temp, glb_nCarrierPriceRec, sizeof(PLMN_CODE_TABLE), Cmp_Carrier);
    if ( Temp == (PLMN_CODE_TABLE*)NULL) {   /* no output returned */
        return FAILURE;
    }
    else {
        strcpy(cell_area, Temp->cell_area);
        strcpy(plmn, Temp->plmn);
        strcpy(country_code, Temp->country_code);
    }
    return SUCCESS;
}

int Get_CarrierPriceExact(char *carrier_code, int chr_type, double *price)
{
    PLMN_CODE_TABLE *Temp = NULL;
    PLMN_CODE_TABLE Key;

    Temp = glb_PlmnPriceHead;
    memset(&Key, 0x00, sizeof(Key));

    strcpy(Key.carrier_code, carrier_code);

    Temp = bsearch(&Key, Temp, glb_nCarrierPriceRec, sizeof(PLMN_CODE_TABLE), Cmp_Carrier);
    if ( Temp == (PLMN_CODE_TABLE*)NULL) {   /* no output returned */
        return FAILURE;
    }
    else {
        switch (chr_type) {
            case CHR_MOC_LOCAL:
                *price = Temp->n_chr_moc_local;
                break;
            case CHR_MOC_TO_TH:
                *price = Temp->n_chr_moc_to_th;
                break;
            case CHR_MOC_INTER:
                *price = Temp->n_chr_moc_inter;
                break;
            case CHR_MTC:
                *price = Temp->n_chr_mtc;
                break;
            case CHR_SMSO:
                *price = Temp->n_chr_smso;
                break;
            default:
                return FAILURE;
                break;
        }

    }
    return SUCCESS;
}

int Get_CarrierPrice(char *carrier_code, int chr_type, double *price)
{
    char tmp_carrier_code[6];
    if ( *carrier_code == '\0' ) {
        return FAILURE;
    }
    if ( !Get_CarrierPriceExact(carrier_code, chr_type, price) ) {
        return SUCCESS;
    }
    else {
        memset(tmp_carrier_code, 0x00, sizeof(tmp_carrier_code));
        strncpy(tmp_carrier_code, carrier_code, 3);
        if ( !Get_CarrierPriceExact(tmp_carrier_code, chr_type, price) ) {
            return SUCCESS;
        }
        else {
            return Get_CarrierPriceExact("#AVG", chr_type, price);
        }
    }
}

int Get_PlmnPriceExact(char *plmn, int chr_type, double *price)
{
    PLMN_CODE_TABLE *Temp = NULL;
    PLMN_CODE_TABLE Key;

    Temp = glb_PlmnCodeHead;
    memset(&Key, 0x00, sizeof(Key));

    strcpy(Key.plmn, plmn);

    Temp = bsearch(&Key, Temp, glb_MapdStat[IDX_PLMN_CODE_TABLE].tot_recs, sizeof(PLMN_CODE_TABLE), Cmp_Plmn);
    if ( Temp == (PLMN_CODE_TABLE*)NULL) {   /* no output returned */
        return FAILURE;
    }
    else {
        switch (chr_type) {
            case CHR_MOC_LOCAL:
                *price = Temp->n_chr_moc_local;
                break;
            case CHR_MOC_TO_TH:
                *price = Temp->n_chr_moc_to_th;
                break;
            case CHR_MOC_INTER:
                *price = Temp->n_chr_moc_inter;
                break;
            case CHR_MTC:
                *price = Temp->n_chr_mtc;
                break;
            case CHR_SMSO:
                *price = Temp->n_chr_smso;
                break;
            default:
                return FAILURE;
                break;
        }

    }
    return SUCCESS;
}

int Get_PlmnPrice(char *plmn, int chr_type, double *price)
{
    char tmp_plmn[6];
    if ( *plmn == '\0' ) {
        return FAILURE;
    }
    if ( !Get_PlmnPriceExact(plmn, chr_type, price) ) {
        return SUCCESS;
    }
    else {
        memset(tmp_plmn, 0x00, sizeof(tmp_plmn));
        strncpy(tmp_plmn, plmn, 3);
        if ( !Get_PlmnPriceExact(tmp_plmn, chr_type, price) ) {
            return SUCCESS;
        }
        else {
            return Get_PlmnPriceExact("#AVG", chr_type, price);
        }
    }
}

int Get_CarrierPriceGprs(char *carrier_code, double *price, double *gprs_min, double *gprs_rnd)
{
    char tmp_carrier_code[6];
    if ( *carrier_code == '\0' ) {
        return FAILURE;
    }
    if ( !Get_CarrierPriceGprsExact(carrier_code, price, gprs_min, gprs_rnd) ) {
        return SUCCESS;
    }
    else {
        memset(tmp_carrier_code, 0x00, sizeof(tmp_carrier_code));
        strncpy(tmp_carrier_code, carrier_code, 3);
        if ( !Get_CarrierPriceGprsExact(tmp_carrier_code, price, gprs_min, gprs_rnd) ) {
            return SUCCESS;
        }
        else {
            return Get_CarrierPriceGprsExact("#AVG", price, gprs_min, gprs_rnd);
        }
    }
}


int Get_CarrierPriceGprsExact(char *carrier_code, double *price, double *gprs_min, double *gprs_rnd)
{
    PLMN_CODE_TABLE *Temp = NULL;
    PLMN_CODE_TABLE Key;

    Temp = glb_PlmnPriceHead;
    memset(&Key, 0x00, sizeof(Key));

    strcpy(Key.carrier_code, carrier_code);

    Temp = bsearch(&Key, Temp, glb_nCarrierPriceRec, sizeof(PLMN_CODE_TABLE), Cmp_Carrier);
    if ( Temp == (PLMN_CODE_TABLE*)NULL) {   /* no output returned */
        return FAILURE;
    }
    else {
        *price = Temp->n_chr_gprs;
        *gprs_min = Temp->n_gprs_min;
        *gprs_rnd = Temp->n_gprs_rnd;
    }
    return SUCCESS;
}

int Get_PlmnPriceGprs(char *plmn, double *price, double *gprs_min, double *gprs_rnd)
{
    char tmp_plmn[6];
    if ( *plmn == '\0' ) {
        return FAILURE;
    }
    if ( !Get_PlmnPriceGprsExact(plmn, price, gprs_min, gprs_rnd) ) {
        return SUCCESS;
    }
    else {
        memset(tmp_plmn, 0x00, sizeof(tmp_plmn));
        strncpy(tmp_plmn, plmn, 3);
        if ( !Get_PlmnPriceGprsExact(tmp_plmn, price, gprs_min, gprs_rnd) ) {
            return SUCCESS;
        }
        else {
            return Get_PlmnPriceGprsExact("#AVG", price, gprs_min, gprs_rnd);
        }
    }
}


int Get_PlmnPriceGprsExact(char *plmn, double *price, double *gprs_min, double *gprs_rnd)
{
    PLMN_CODE_TABLE *Temp = NULL;
    PLMN_CODE_TABLE Key;

    Temp = glb_PlmnCodeHead;
    memset(&Key, 0x00, sizeof(Key));

    strcpy(Key.plmn, plmn);

    Temp = bsearch(&Key, Temp, glb_MapdStat[IDX_PLMN_CODE_TABLE].tot_recs, sizeof(PLMN_CODE_TABLE), Cmp_Plmn);
    if ( Temp == (PLMN_CODE_TABLE*)NULL) {   /* no output returned */
        return FAILURE;
    }
    else {
        *price = Temp->n_chr_gprs;
        *gprs_min = Temp->n_gprs_min;
        *gprs_rnd = Temp->n_gprs_rnd;
    }
    return SUCCESS;
}

int Cmp_3G(const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((SERVICE3G_TABLE *)ptr1)->szSpeedtype, ((SERVICE3G_TABLE *)ptr2)->szSpeedtype);
    if ( rv)
        return rv;

    rv = strcmp(((SERVICE3G_TABLE *)ptr1)->szRat, ((SERVICE3G_TABLE *)ptr2)->szRat);
    if ( rv)
        return rv;

    rv = strcmp(((SERVICE3G_TABLE *)ptr1)->szServpackid, ((SERVICE3G_TABLE *)ptr2)->szServpackid);
    if ( rv)
        return rv;

    return (strcmp(((SERVICE3G_TABLE *)ptr1)->szBearer_id, ((SERVICE3G_TABLE *)ptr2)->szBearer_id));
}

int Get_SvcType(char *speed_type, char *rat, char *srv_pack_id, char *bearer, double *rating, char *svc_type)
{
    //static char szAnyFci[] = "*";
    SERVICE3G_TABLE *Temp = NULL;
    SERVICE3G_TABLE Key;
    int     Idx = 0;

    Temp = glb_3GHead;
    Idx = IDX_3G_MAP_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.szSpeedtype = speed_type;
    Key.szRat = rat;
    Key.szServpackid = srv_pack_id;
    Key.szBearer_id = bearer;

    /* Do binary search on the 3G/2G Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(SERVICE3G_TABLE), Cmp_3G);

    if ( Temp == (SERVICE3G_TABLE *)NULL) {      /* no match found in Service Key Table */
        return FAILURE;
    }
    else {
        strcpy(svc_type, Temp->szDescName);
        *rating = atof(Temp->szRating);
//#define SHOW_3G_SERVICE
#ifdef SHOW_3G_SERVICE
printf ("spdtype|rat|pckid|bear:%s|%s|%s|%s -> rating = %0.2f, svc_type = %s\n", speed_type, rat, srv_pack_id, bearer, *rating, svc_type);
#endif
    }
    return SUCCESS;
}

int Cmp_TollFree(const void *ptr1, const void *ptr2)
{
    return (strcmp(((TOLLFREE_TABLE *)ptr1)->szToll_Free, ((TOLLFREE_TABLE *)ptr2)->szToll_Free));
}

int Get_TollFreeExact(char *free_num, char *desc)
{
    TOLLFREE_TABLE *Temp = NULL;
    TOLLFREE_TABLE Key;
    int     Idx = 0;

    Temp = glb_TollFreeHead;
    Idx = IDX_TOLL_FREE_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.szToll_Free = free_num;

    /* Do binary search on the 3G/2G Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(TOLLFREE_TABLE), Cmp_TollFree);

    if ( Temp == (TOLLFREE_TABLE *)NULL) {       /* no match found in Service Key Table */
        return FAILURE;
    }
    else {
        strcpy(free_num, Temp->szToll_Free);
        if ( strcmp(free_num, Temp->szToll_Free) == 0 ) {
            strcpy(desc, Temp->szDescName);
            return SUCCESS;
        }
    }
    return FAILURE;
}

int Is_TollFree(char *b_no, char *desc)
{
    int bno_len = 0;
    char temp_bno[SIZE_COSTCODE+1];

    if ( *b_no == '\0' )  /* b_no value not passed */
        return FAILURE;

    bno_len = strlen(b_no);

    while(bno_len > 2) {
        memset(temp_bno, 0x00, sizeof(temp_bno));
        strncpy(temp_bno, b_no, bno_len);

        if ( !Get_TollFreeExact(temp_bno, desc) ) { /* SUCCESS */
            return SUCCESS;
        }
        bno_len--;
    }

    return FAILURE;
}

int Cmp_OneLoveNum(const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((ONE_LOVE_TABLE *)ptr1)->szAno, ((ONE_LOVE_TABLE *)ptr2)->szAno);
    if ( rv)
        return rv;

    return (strcmp(((ONE_LOVE_TABLE *)ptr1)->szBno, ((ONE_LOVE_TABLE *)ptr2)->szBno));
}

int Is_OneLoveNum(char *a_no, char *b_no)
{
    ONE_LOVE_TABLE *Temp = NULL;
    ONE_LOVE_TABLE Key;
    int Idx = 0;

    Temp = glb_OneLoveHead;
    Idx = IDX_ONE_LOVE_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.szAno = a_no;
    Key.szBno = b_no;

    /* Do binary search on the 3G/2G Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(ONE_LOVE_TABLE), Cmp_OneLoveNum);

    if ( Temp == (ONE_LOVE_TABLE *)NULL) {      /* no match found in Service Key Table */
        return FAILURE;   /* not found one love number */
    }
    else {
        return SUCCESS;   /* match one love number */
    }
}

int Cmp_Imei(const void *ptr1, const void *ptr2)
{
    return (strcmp(((BOS_IMEI_TABLE *)ptr1)->szImei, ((BOS_IMEI_TABLE *)ptr2)->szImei));
}

int Is_BosImei(char *imei)
{
    BOS_IMEI_TABLE *Temp = NULL;
    BOS_IMEI_TABLE Key;
    int     Idx = 0;

    if ( imei == '\0' )        /* imei value not passed */
        return FALSE;

    Key.szImei = imei;

    Temp = glb_BosImeiHead;
    Idx = IDX_BOS_IMEI_TABLE;

    /* Do binary search on the IMEI Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(BOS_IMEI_TABLE), Cmp_Imei);

    if ( Temp == (BOS_IMEI_TABLE *)NULL) {       /* no match found in IMEI Table */
        return FALSE;
    }
    return TRUE;
}

int Cmp_CostcodeBno(const void *ptr1, const void *ptr2)
{
    return (strcmp(((COSTCODE_BNO_TABLE *)ptr1)->szBnoPrefix, ((COSTCODE_BNO_TABLE *)ptr2)->szBnoPrefix));
}

int Get_CostcodeBnoExact(char *b_no, char *costcode)
{
    COSTCODE_BNO_TABLE *Temp = NULL;
    COSTCODE_BNO_TABLE Key;
    int Idx = 0;

    if ( b_no == '\0' )       /* value not passed */
        return FALSE;

    Temp = glb_CostcodeBNoHead;
    Idx = IDX_COSTCODE_BNO_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.szBnoPrefix = b_no;

    /* Do binary search on the IMSI Table */
    Temp = bsearch (&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(COSTCODE_BNO_TABLE), Cmp_CostcodeBno);

    if ( Temp == (COSTCODE_BNO_TABLE *)NULL ) {     /* no match found in IMSI Table */
        return FAILURE;
    }
    strcpy(costcode, Temp->szCostcode);
    return SUCCESS;
}

int Get_CostcodeBno(char *b_no, char *costcode)
{
    int bno_len = 0;
    char temp_bno[SIZE_COSTCODE+1];

    if ( *b_no == '\0' )  /* b_no value not passed */
        return FAILURE;

    bno_len = strlen(b_no);

    while(bno_len > 2) {
        memset(temp_bno, 0x00, sizeof(temp_bno));
        strncpy(temp_bno, b_no, bno_len);

        if ( !Get_CostcodeBnoExact(temp_bno, costcode) ) { /* SUCCESS */
            return SUCCESS;
        }
        bno_len--;
    }

    return FAILURE;
}

int Cmp_UsMapTable(const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcmp(((USMAP_TABLE *)ptr1)->service_id, ((USMAP_TABLE *)ptr2)->service_id);
    if ( rv)     // Not Equal
        return rv;

    rv = strcmp(((USMAP_TABLE *)ptr1)->category_id, ((USMAP_TABLE *)ptr2)->category_id);
    if ( rv)     // Not Equal
        return rv;

    rv = strcmp(((USMAP_TABLE *)ptr1)->charging_cp_id, ((USMAP_TABLE *)ptr2)->charging_cp_id);
    if ( rv)     // Not Equal
        return rv;

    return (strcmp(((USMAP_TABLE *)ptr1)->cct, ((USMAP_TABLE *)ptr2)->cct));

}

int Get_UsMapData(char *svc_id, char *cat_id, char *cp_id, char *cct, char *company_name, char *service_name)
{
    USMAP_TABLE *Temp = NULL;
    USMAP_TABLE Key;
    int Idx = 0;

    Temp = glb_UsMapHead;
    Idx = IDX_USMAP_TABLE;
    memset(&Key, 0x00, sizeof (Key));

    Key.service_id = svc_id;
    Key.category_id = cat_id;
    Key.charging_cp_id = cp_id;
    Key.cct = cct;

    /* Do binary search on the 3G/2G Table */
    Temp = bsearch(&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(USMAP_TABLE), Cmp_UsMapTable);

    if ( Temp == (USMAP_TABLE *)NULL ) {
        strcpy(company_name, "");
        strcpy(service_name, "");
        return FAILURE;     // Not found
    }
    else {
        // Found data
        strncpy(company_name, Temp->company_name, 50);  // Limit output string to 50 char
        strncpy(service_name, Temp->service_name, 50);  // Limit output string to 50 char
        return SUCCESS;
    }

}

int Cmp_GeoTable(const void *ptr1, const void *ptr2)
{
    return (strcmp(((GEO_TABLE *)ptr1)->geo_cgi, ((GEO_TABLE *)ptr2)->geo_cgi));
}

int Get_GeoDataExact(char *cgi, char *cell_id, char *cell_set, char *cell_area)
{
    GEO_TABLE *Temp = NULL;
    GEO_TABLE Key;
    int Idx = 0;

    Temp = glb_GeoHead;
    Idx = IDX_GEO_TABLE;

    memset(&Key, 0x00, sizeof (Key));

    Key.geo_cgi = cgi;

    /* Do binary search on the 3G/2G Table */
    Temp = bsearch(&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(GEO_TABLE), Cmp_GeoTable);

    if ( Temp == (GEO_TABLE *)NULL ) {
        strcpy(cell_id, "");
        strcpy(cell_set, "");
        strcpy(cell_area, "");
        return FAILURE;     // Not found
    }
    else {
        // Found data
        strncpy(cell_id, Temp->geo_cell_id, 20);        // Limit output string to 20 char
        strncpy(cell_set, Temp->geo_cell_set, 10);      // Limit output string to 10 char
        strncpy(cell_area, Temp->geo_cell_area, 10);    // Limit output string to 10 char
        return SUCCESS;
    }

}

int Get_GeoData(char *cgi, char *cell_id, char *cell_set, char *cell_area)
{
    int cgi_len = 0;
    char temp_cgi[20+1];

    if ( *cgi == '\0' )  /* cgi value not passed */
        return FAILURE;

    cgi_len = strlen(cgi);

    while(cgi_len > 5) {
        memset(temp_cgi, 0x00, sizeof(temp_cgi));
        strncpy(temp_cgi, cgi, cgi_len);

        if ( !Get_GeoDataExact(temp_cgi, cell_id, cell_set, cell_area) ) { /* SUCCESS */
            return SUCCESS;
        }
        cgi_len--;
    }

    return FAILURE;
}

int Cmp_CellAreaTable(const void *ptr1, const void *ptr2)
{
    return (strcmp(((CELLAREA_TABLE *)ptr1)->en_province, ((CELLAREA_TABLE *)ptr2)->en_province));
}

int Get_CellAreaProv(char *en_province, char *cell_area)
{
    CELLAREA_TABLE *Temp = NULL;
    CELLAREA_TABLE Key;
    int Idx = 0;

    Temp = glb_CellAreaHead;
    Idx = IDX_CELLAREA_TABLE;

    memset(&Key, 0x00, sizeof (Key));

    Key.en_province = en_province;

    /* Do binary search on the 3G/2G Table */
    Temp = bsearch(&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(CELLAREA_TABLE), Cmp_CellAreaTable);

    if ( Temp == (CELLAREA_TABLE *)NULL ) {
        strcpy(cell_area, "");
        return FAILURE;     // Not found
    }
    else {
        // Found data
        strncpy(cell_area, Temp->geo_cell_area, 10);    // Limit output string to 10 char
        return SUCCESS;
    }

}

int Cmp_VasGroupTable(const void *ptr1, const void *ptr2)
{
    int rv;
    rv = strcasecmp(((VASGROUP_TABLE *)ptr1)->cost_code_type, ((VASGROUP_TABLE *)ptr2)->cost_code_type);
    if ( rv)
        return rv;
    return (strcasecmp(((VASGROUP_TABLE *)ptr1)->grp_name, ((VASGROUP_TABLE *)ptr2)->grp_name));
}

int Get_VasGroupCodeByGrpName(char *grp_name, char *grp_code)
{
    char code_type[15];
    strcpy(code_type, "Costcode_Desc");
    if ( Get_VasGroupCode(code_type, grp_name, grp_code) == FAILED ) {
        strcpy(code_type, "Costcode_Name");
        if ( Get_VasGroupCode(code_type, grp_name, grp_code) == FAILED ) {
            strcpy(code_type, "MKTType");
            if ( Get_VasGroupCode(code_type, grp_name, grp_code) == FAILED ) {
                strcpy(grp_code, "0");
                return FAILURE;
            }
        }
    }
    return SUCCESS;

}

int Get_VasGroupCode(char *cost_code_type, char *grp_name, char *grp_code)
{
    VASGROUP_TABLE *Temp = NULL;
    VASGROUP_TABLE Key;

    int Idx = 0;

    Temp = glb_VasGroupHead;
    Idx = IDX_VASGROUP_TABLE;

    memset(&Key, 0x00, sizeof (Key));

    Key.cost_code_type = cost_code_type;
    Key.grp_name = grp_name;

    /* Do binary search on the 3G/2G Table */
    Temp = bsearch(&Key, Temp, glb_MapdStat[Idx].tot_recs, sizeof(VASGROUP_TABLE), Cmp_VasGroupTable);

    if ( Temp == (VASGROUP_TABLE *)NULL ) {
        return FAILURE;     // Not found
    }
    else {
        // Found data
        strncpy(grp_code, Temp->grp_code, 2);    // Limit output string to 10 char
        return SUCCESS;
    }

}
/*------------------------------------------------------------------------------------*/

unsigned int Conv_Duration (char *Duration)
{
    int hh, mm, ss;

    if ( *Duration == '\0' )
        return 0;

    sscanf(Duration, "%2u%2u%2uZ", &hh, &mm, &ss);

    return (ss + (mm * 60) + (hh * 60 * 60));
}

/* 20 NOV 2001 by Kawee */
/*
** Name     : Conv_DuraFormat (const char*, char*)
**
** Description  : Converts the given SSSSSS format Duration into HHMMSS formate Date.
**                This function assumes the following :
**                1. The Input Duration should always be SSSSSS format.
**
** Parameters   : char *Dura_Sec_Format - INPUT - Pointer to input duration of buffer.
**              : char *Dura_HHMMSS_Format - OUTPUT - Pointer to output duration of buffer.
**
** Return Value : SUCCESS/FAILURE
*/

int Conv_DuraFormat (const char* Dura_Sec_Format, char* Dura_HHMMSS_Format)
{
    int hh, mm, ss;
    int Sec;
    char buff[7];

    if ( Dura_Sec_Format == '\0' )
        return FAILURE;

    sscanf(Dura_Sec_Format, "%6uZ", &Sec);
    hh = Sec / (60 * 60);
    mm = (Sec % (60 * 60)) / 60;
    ss = Sec % 60;

    memset(buff, 0x00, sizeof (buff));
    sprintf(buff, "%02d%02d%02d", hh, mm, ss);
    strncpy(Dura_HHMMSS_Format, buff, 6);

    return SUCCESS;
}

/*
** Name     : Calc_SeizeTime()
**
** Description  : Calculates the time since the Epoch from the give Date and Time.
**
** Parameters   : char *Date - INPUT - Pointer to date of format YYYYMMDD
**        char *Time - INPUT - Pointer to time of format HHMMSS
**
** Return Value : (time_t) time since the Epoch - on Successful completion.
**        (time_t) -1 on Failures.
*/
time_t Calc_SeizeTime (char *Date, char *Time)
{
    struct tm *t;
    time_t timer;

    timer = time (NULL);
    t = localtime (&timer);

    if ( *Date == '\0' || *Time == '\0' )
        return ((time_t)0);

    sscanf(Date, "%4u%2u%2u", &t->tm_year, &t->tm_mon, &t->tm_mday);

    t->tm_year -= YEAR_SINCE; /* calculate year since 1900 */
    t->tm_mon--;    /* month is 0 to 11 */

    sscanf(Time, "%2u%2u%2u", &t->tm_hour, &t->tm_min, &t->tm_sec);

    return mktime(t);
}

/* Added below function by Kawee on 10-Mar-2008 */
/*
** Name     : localtime_YYYYMMDDHHMMSS()
**
** Description  : Convert time_t to localtime string in YYYYMMDDHHMMSS format.
**
** Parameters   : const time_t *timer - INPUT - Pointer to time_t value
**
** Return Value : localtime in YYYYMMDDHHMMSS format
*/
char*   localtime_YYYYMMDDHHMMSS (const time_t *timer)
{
    struct tm tm_time;
    static char szBuf[SIZE_YYYYMMDD+SIZE_HHMMSS+1];

    memset(szBuf, 0x00, sizeof(szBuf));
    memcpy(&tm_time, localtime (timer), sizeof(struct tm));
    sprintf(szBuf, "%04d%02d%02d%02d%02d%02d",
        (tm_time.tm_year+YEAR_SINCE), (tm_time.tm_mon+1), tm_time.tm_mday,
        tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);
    return szBuf;
}

/* Added below function by Kawee on 10-Mar-2008 */
/*
** Name     : gmtime_YYYYMMDDHHMMSS()
**
** Description  : Convert time_t to gmtime string in YYYYMMDDHHMMSS format.
**
** Parameters   : const time_t *timer - INPUT - Pointer to time_t value
**
** Return Value : gmtime in YYYYMMDDHHMMSS format
*/
char*   gmtime_YYYYMMDDHHMMSS (const time_t *timer)
{
    struct tm tm_time;
    static char szBuf[SIZE_YYYYMMDD+SIZE_HHMMSS+1];

    memset(szBuf, 0x00, sizeof(szBuf));
    memcpy(&tm_time, gmtime (timer), sizeof(struct tm));
    sprintf(szBuf, "%04d%02d%02d%02d%02d%02d",
        (tm_time.tm_year+YEAR_SINCE), (tm_time.tm_mon+1), tm_time.tm_mday,
        tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);
    return szBuf;
}

/* Added below function by Thanakorn on Sep-2016 */
/*
** Name     : getGMT_byTimeDiff()
**
** Description  : get local GMT from time diff between local time and home time
**
** Parameters   : time_t home_time, time_t local_time, float home_gmt
**
** Return Value : gmt in (+/-)(H)(M) format, eg. +530
*/
char    *getLocalGMT_byTimeDiff(time_t home_time, time_t local_time, float home_gmt)
{
    static char sz_local_gmt[10];
    double sec_of_hour = (int)home_gmt * 60 * 60;
    double sec_of_min  = (home_gmt - floor(home_gmt)) * 100 * 60;
    double total_sec = sec_of_hour + sec_of_min;

    double time_diff = home_time - local_time;
    double local_gmt = total_sec - time_diff;

    int hh = (int)(local_gmt/3600);
    int mm = (int)(((long)local_gmt%3600)/60);

    if ( hh > 0 ) {
        sprintf(sz_local_gmt, "+%d%02d", hh, mm);
    }
    else {
        sprintf(sz_local_gmt, "%d%02d", hh, ((-1)*mm));
    }
    return sz_local_gmt;
}

/*
** Name     : Calc_Duration()
**
** Description  : Calculates the time since the Epoch from the give Date and Time.
**
** Parameters   : char *StartDate - INPUT - Pointer to start date of format YYYYMMDD
**        char *StartTime - INPUT - Pointer to start time of format HHMMSS
**        char *StopDate - INPUT - Pointer to stop date of format YYYYMMDD
**        char *StopTime - INPUT - Pointer to stop time of format HHMMSS
**
** Return Value : (time_t) time since the Epoch - on Successful completion.
**        (time_t) -1 on Failures.
*/
long Calc_Duration (char *StartDate, char *StartTime, char *StopDate, char *StopTime)
{
    time_t start_datetime, stop_datetime;

    if ( (start_datetime = Calc_SeizeTime(StartDate, StartTime)) == -1)
        return -1;
    if ( (stop_datetime = Calc_SeizeTime(StopDate, StopTime)) == -1)
        return -1;

    return ((long)difftime (stop_datetime, start_datetime));
}

/*
** Remove zero leading character and copy num_char character from the first non zero character encounter to output
**
*/
void Trim_ZeroLeading(char *output, const char *input, int num_char)
{
    int i = 0;
    while ( *(input + i) == '0' )
    {
        i++;
    }
    if ( num_char <= 0 )
    {
        strcpy(output, input+i);
        output[strlen(input) - i] = 0;
    }
    else
    {
        strncpy(output, input+i, num_char);
        output[num_char] = 0;
    }
}

double Conv_UTCOffset (char *Offset)
{
    int hh = 0, mm = 0;
    char sign;

    if ( *Offset == '\0' )
        return 0;

    sscanf(Offset, "%c%2u%2u", &sign, &hh, &mm);

    if ( sign == '-')
        return ((double)(hh + (mm * 0.01)) * (-1));
    else
        return ((double)(hh + (mm * 0.01)));
}

double Calc_IntlCharge (unsigned int Dura, double Rate)
{
    double integ = 0, fract = 0;

    if ( !Dura || !Rate)
        return ((double)0);

    /* calc duration in units and split */
    fract = modf (((double)Dura/6), &integ);
    if ( fract > 0.0)    /* if fractional unit */
        integ++;    /* round to next unit */

    return ((double)rint(integ * (Rate/10)));
}

/* Introduced AIN - Added below by Kawee on 04-Jan-2007 */
double  Calc_AinIntlCharge (unsigned int Dura, double Rate)
{
    double integ = 0, fract = 0;

    if ( !Dura || !Rate)
        return ((double)0);

    /* Minimum Charge is 60 Seconds */
    if ( Dura < 60)
        Dura = 60;

    /* calc duration in units and split */
    fract = modf (((double)Dura/6), &integ);
    if ( fract > 0.0)    /* if fractional unit */
        integ++;    /* round to next unit */

    return ((double)rint(integ * (Rate/10)));
}

double  Calc_AinIntlCharge2 (unsigned int Dura, double Rate)
{
    double integ = 0, fract = 0;

    if ( !Dura || !Rate)
        return ((double)0);

    /* Minimum Charge is 60 Seconds */
    if ( Dura < 60)
        Dura = 60;

    /* calc duration in units and split */
    fract = modf (((double)Dura/6), &integ);
    if ( fract > 0.0)    /* if fractional unit */
        integ++;    /* round to next unit */

    return ((double)integ * (Rate/10));
}

double Calc_NatlCharge (unsigned int Dura, double Rate)
{
    double integ = 0, fract = 0;

    if ( !Dura || !Rate)
        return ((double)0);

    /* calc duration in minutes and split */
    fract = modf (((double)Dura/60), &integ);
    if ( fract > 0.0)    /* if fractional minute */
        integ++;    /* round to next minute */

    /* return ( (double) rint(integ * Rate));  - no rundup - changed by chamy - 07-Sep-2001 */
    return ((double)integ * Rate);
}

double Calc_DpcNatlCharge (unsigned int Dura, double Rate)
{
    double integ = 0, fract = 0;

    if ( !Dura || !Rate)
        return ((double)0);

    /* calc duration in minutes and split */
    if ( Dura < 60)
        integ = 1.0;
    else {
        fract = modf (((double)Dura/60), &integ);
        if ( fract > 0.50)   /* if fractional minute > 30 seconds */
            integ++;    /* round to next minute */
        /* else fractional minute <= 30 seconds then ignore seconds and use only minute for calculate */
    }

    return ((double)integ * Rate);
}

void Trim_Str(char *buff)
{
    short i = strlen(buff);

    while (i-- && *(buff+i) < 33);  /* ascii value 0 - 32 */
    *(buff+i+1) = '\0';
}

void Pad_Str (char *buff, int len)
{
    short i = strlen(buff);

    while (i < len)
        *(buff+i++) = SPACE_CHAR;

    *(buff+len) = '\0'; /* terminate with null */
}

void Scan_DialDigit (char *buff)
{
    short i = 0;

    while ( *(buff+i) != '\0') {
        *(buff+i) = (isdigit (*(buff+i)) ? *(buff+i) : '*');
        i++;
    }
}

int Scan_ForAlpha (const char *buff)
{
    short i = 0;

    while ( *(buff+i) != '\0' ) {
        if ( isalpha (*(buff+i)))
            return FAILURE;
        i++;
    }
    return SUCCESS;
}

int Is_Number(char *buff)
{
    short i = 0;
    while ( buff[i] != '\0' ) {
        if ( buff[i] < '0' || buff[i] > '9' )
            return FALSE;
        i++;
    }
    return TRUE;
}

/* Added below by Kawee on 02-Feb-2007 */
/*
** Name         : Is_LeapYear()
**
** Description  : Check Year is Leap Year or Not
**        Leap Year is year that have 366 day/year (February have 29 Day)
**
** Parameters   : int *iYear - INPUT - Specific year to check leap year.
**
** Return Value : 1 - if input integer is leap year.
**                0 - otherwise.
*/
int     Is_LeapYear(int iYear)
{
        return (iYear % 4 == 0 && (iYear % 100 != 0 || iYear %400 == 0));
}

/* Added below by Kawee on 02-Feb-2007 */
/*
** Name         : IsValid_YYYYMMDDHHMMSS()
**
** Description  : Validate string in YYYYMMDDHHMMSS
**
** Parameters   : const char *date_time - INPUT - Specific string in YYYYMMDDHHMMSS format.
**
** Return Value : 1 - if input string in YYYYMMDDHHMMSS format.
**                0 - otherwise.
*/
int IsValid_YYYYMMDDHHMMSS (char *sDateTime)
{
    char    sBuf[5];
    int iYear, iMonth, iMday, iHour, iMinute, iSecond, mday_limit;
    const int   aiMDay[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    if ( strlen(sDateTime) != SIZE_DATETIME)
        return 0;     /* return FALSE */

    if ( !Is_Number(sDateTime))
        return 0;     /* return FALSE */

    /* Check valid year */
    memset(sBuf, 0x00, sizeof(sBuf));
    strncpy(sBuf, sDateTime, 4);
    iYear = atoi(sBuf);
    if ( iYear < 1900)
        return 0;     /* return FALSE */

    /* Check Valid Month */
    memset(sBuf, 0x00, sizeof(sBuf));
    strncpy(sBuf, sDateTime+4, 2);
    iMonth = atoi(sBuf);
    if ( (iMonth < 1) || (iMonth > 12))
        return 0;     /* return FALSE */

    /* Check Valid Day */
    memset(sBuf, 0x00, sizeof(sBuf));
    strncpy(sBuf, sDateTime+6, 2);
    iMday = atoi(sBuf);
    mday_limit = aiMDay[iMonth-1];
    if ( iMonth == 2 && Is_LeapYear(iYear))
        mday_limit = 29;

    if ( (iMday < 1) || (iMday > mday_limit))
        return 0;     /* return FALSE */

    /* Check Valid Hour */
    memset(sBuf, 0x00, sizeof(sBuf));
    strncpy(sBuf, sDateTime+8, 2);
    iHour = atoi(sBuf);
    if ( (iHour < 0) || (iHour > 23))
        return 0;     /* return FALSE */

    /* Check Valid Minute */
    memset(sBuf, 0x00, sizeof(sBuf));
    strncpy(sBuf, sDateTime+10, 2);
    iMinute = atoi(sBuf);
    if ( (iMinute < 0) || (iMinute > 59))
        return 0;     /* return FALSE */

    /* Check Valid Second */
    memset(sBuf, 0x00, sizeof(sBuf));
    strncpy(sBuf, sDateTime+12, 2);
    iSecond = atoi(sBuf);
    if ( (iSecond < 0) || (iSecond > 59))
        return 0;     /* return FALSE */

    return 1;         /* return TRUE */
}

int IsValid_YYYYMMDD_HHMMSS (char *sDate, char *sTime)
{
    char    sBuf[SIZE_DATETIME+1];

    memset(sBuf, 0x00, sizeof(sBuf));
    strncpy(sBuf, sDate, SIZE_YYYYMMDD);
    strncat (sBuf, sTime, SIZE_HHMMSS);
    return (IsValid_YYYYMMDDHHMMSS(sBuf));
}

/* Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Changed as below by Kawee on 04-Jun-2007 */
// Event Ouput is for FRM v12 only.
int Write_Event_Record()
{
    switch ( glb_EventId ) {
        case VOICE_EVENT_TYPE:      // SSP, GSM, DPCGSM and AIN CDR Type
        case VOICE_EVENT_TYPE_IDD:
            if ( voice_event.direction[0] == '\0' ) {
                strcpy(voice_event.direction, OUTGOING);
            }
            if ( voice_event.utc_offset[0] == '\0' ) {
                strcpy(voice_event.utc_offset, "420");
            }
            strcpy(voice_event.service_type, ST_HOME);
            int tmp_cat_mask = atoi(voice_event.categories);
            if ( tmp_cat_mask & CAT_PREMIUM ) {
                tmp_cat_mask &= ~CAT_VOICE;   // remove CAT_VOICE
                tmp_cat_mask |= CAT_LOCAL;    // add CAT_LOCAL
                sprintf(voice_event.categories, "%08d", tmp_cat_mask);
            }
            fprintf(glb_Eventcdrfp, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|\n"
            , voice_event.event_type, AWN_PARTITION, voice_event.mobile_num, voice_event.bno
            , voice_event.original_bno, voice_event.from_number, voice_event.to_number, voice_event.direction
            , voice_event.imei, voice_event.utc_offset, voice_event.time_key, voice_event.duration
            , voice_event.charge, voice_event.service_type, voice_event.remarks, voice_event.categories
            , voice_event.detect_params, voice_event.features, voice_event.event_src, voice_event.area_code
            , voice_event.cell_area, voice_event.cell_set, voice_event.cell, voice_event.country_code
            , voice_event.fee_charge, voice_event.oper_name);
            break;
        case FIXED_EVENT_TYPE:
            if ( voice_event.direction[0] == '\0' ) {
                strcpy(voice_event.direction, OUTGOING);
            }
            if ( voice_event.utc_offset[0] == '\0' ) {
                strcpy(voice_event.utc_offset, "420");
            }
            strcpy(voice_event.service_type, ST_HOME);
            fprintf(glb_Eventcdrfp, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|\n"
            , voice_event.event_type, AWN_PARTITION, voice_event.mobile_num, voice_event.bno
            , voice_event.original_bno, voice_event.from_number, voice_event.to_number, voice_event.direction
            , voice_event.imei, voice_event.utc_offset, voice_event.time_key, voice_event.duration
            , voice_event.charge, voice_event.service_type, voice_event.remarks, voice_event.categories
            , voice_event.detect_params, voice_event.features, voice_event.event_src, voice_event.area_code
            , voice_event.cell_area, voice_event.cell_set, voice_event.cell, voice_event.country_code
            , voice_event.fee_charge, voice_event.oper_name);
            break;
        case SMS_EVENT_TYPE:        // GSM, SMS, SMC, DPCGSM and MMS CDR Type
            strcpy(sms_event.service_type, ST_HOME);
            if ( sms_event.utc_offset[0] == '\0' ) {
                strcpy(sms_event.utc_offset, "420");
            }
            fprintf(glb_Eventcdrfp, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|\n"
            , sms_event.event_type, AWN_PARTITION, sms_event.mobile_num, sms_event.bno
            , sms_event.original_bno, sms_event.from_number, sms_event.to_number, sms_event.direction
            , sms_event.imei, sms_event.utc_offset, sms_event.time_key, sms_event.duration
            , sms_event.charge, sms_event.service_type, sms_event.remarks, sms_event.categories
            , sms_event.detect_params, sms_event.features, sms_event.event_src, sms_event.area_code
            , sms_event.cell_area, sms_event.cell_set, sms_event.cell, sms_event.country_code
            , sms_event.fee_charge, sms_event.service_id);
            break;
        case VAS_EVENT_TYPE:        // USC, RBT, CDG, Session, AMF, SDG
            strcpy(vas_event.service_type, ST_HOME);
            if ( vas_event.vas_desc[0] == ',' ) {
                vas_event.vas_desc[0] = '\0';
            }
            else {
                if ( vas_event.cpid[0] != '\0' ) {
                    fprintf(glb_SvcIdSubfp, "IV|%s|%s|%s|\n", vas_event.service_id, vas_event.vas_desc, vas_event.cpid);
                    glb_SvcIdCnt++;
                }
            }
            if ( vas_event.utc_offset[0] == '\0' ) {
                strcpy(vas_event.utc_offset, "420");
            }
            if ( vas_event.vas_grp[0] == '\0' ) {
                strcpy(vas_event.vas_grp, "0");
            }
            fprintf(glb_Eventcdrfp, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|\n"
            , vas_event.event_type, AWN_PARTITION, vas_event.mobile_num, vas_event.bno
            , vas_event.original_bno, vas_event.from_number, vas_event.to_number, vas_event.direction
            , vas_event.imei, vas_event.utc_offset, vas_event.time_key, vas_event.duration
            , vas_event.charge, vas_event.service_type, vas_event.remarks, vas_event.categories
            , vas_event.detect_params, vas_event.features, vas_event.event_src, vas_event.app_id
            , vas_event.charging_id, vas_event.imsi, vas_event.cpid, vas_event.service_id
            , vas_event.service_cat, vas_event.short_code, vas_event.vas_name, vas_event.vas_desc, vas_event.vas_grp);
            break;
        case DATA_EVENT_TYPE:       // GPRS, GSMBC, PPSBC(EDGE, 3G) CDR Type
            strcpy(data_event.service_type, ST_HOME);
            if ( data_event.utc_offset[0] == '\0' ) {
                strcpy(data_event.utc_offset, "420");
            }
            fprintf(glb_Eventcdrfp, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|\n"
            , data_event.event_type, AWN_PARTITION, data_event.mobile_num
            , data_event.bno, data_event.original_bno, data_event.from_number, data_event.to_number
            , data_event.direction, data_event.imei, data_event.utc_offset, data_event.time_key
            , data_event.duration, data_event.charge, data_event.service_type, data_event.remarks
            , data_event.categories, data_event.detect_params, data_event.features, data_event.event_src
            , data_event.cell_area, data_event.cell_set, data_event.cell, data_event.vol_total);
            break;
        case IR_EVENT_TYPE:         // IR(NRTRDE, TAP and SCP) CDR Type
            strcpy(ir_event.service_type, ST_ROAM);
            fprintf(glb_Eventcdrfp, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|\n"
            , ir_event.event_type, AWN_PARTITION, ir_event.mobile_num, ir_event.bno
            , ir_event.original_bno, ir_event.from_number, ir_event.to_number, ir_event.direction
            , ir_event.imei, ir_event.utc_offset, ir_event.time_key, ir_event.duration
            , ir_event.charge, ir_event.service_type, ir_event.remarks, ir_event.categories
            , ir_event.detect_params, ir_event.features, ir_event.event_src, ir_event.call_start_time
            , ir_event.charge_type, ir_event.country_code, ir_event.imsi, ir_event.plmn_code
            , ir_event.plmn_name, ir_event.pre_disc, ir_event.pre_dura, ir_event.pre_vol
            , ir_event.risk_bno, ir_event.roam_country, ir_event.roam_region, ir_event.vol_total);
if ( atoi(ir_event.charge) > 0 ) {
writeLog(LOG_INF, "final fit rec> stime(%s) mobno(%s) imsi(%s) dur(%s) chg(%s[satang]) src(%s)"
            , ir_event.call_start_time, ir_event.mobile_num, ir_event.imsi
            , ir_event.duration, ir_event.charge, ir_event.event_src);
}
            break;
        default:        // All output files
            break;
    }

    if ( ++glb_SamCtr >= glb_CdrSample_Size ) {
        Upd_Check_File(CHK_TIME_UPD); /* Update the Check Point File after sample size reached */
        glb_SamCtr = 0; /* Reset the Sample Counter */
    }

    return SUCCESS;

}

int Wrt_Exn_Data()
{

    FILE *EAlmfp = NULL;
    memset(&alm_buf, 0x00, sizeof (alm_buf));
    int isWrtten = 0;

    if ( glb_MtxInd == NRTRDE_TYPE )
        EAlmfp = glb_NrtEAlmfp;
    else if ( glb_PartId == AWN_SVC_PARTITION )
        EAlmfp = glb_PostpaidEAlmfp;
    else if ( glb_PartId == PREPAID_SVC_PARTITION )
        EAlmfp = glb_PrepaidEAlmfp;
    else if ( glb_PartId == AIN_SVC_PARTITION )
        EAlmfp = glb_AinEAlmfp;

    if ( EAlmfp == '\0' ) {
        return SUCCESS;
    }

    //
    // Common format ouput for external alarm file.
    // 1            2             3   4   5         6         7             8            9
    // event_type_id|partition_id|ano|bno|sdate_Ymd|stime_HMS|charge_satang|duration_sec|categories|
    //
    switch ( glb_EventId ) {
        case SMS_EVENT_TYPE:        // GSM, SMS, SMC, DPCGSM and MMS CDR Type
            if ( ! (atoi(sms_event.categories) & CAT_MMS) ) {
                fprintf(EAlmfp, "%s|%s|%s|%s|%s|%s|%s||%s|\n", sms_event.event_type, sms_event.partition_id, sms_event.mobile_num,
                sms_event.to_number, glb_CurCDRDate, glb_CurCDRTime, sms_event.charge, sms_event.categories);
                isWrtten = 1;
            }
            break;
        case VOICE_EVENT_TYPE:      // SSP, GSM, DPCGSM and AIN CDR Type
        case FIXED_EVENT_TYPE:
        case VOICE_EVENT_TYPE_IDD:
        case VAS_EVENT_TYPE:        // USC, RBT, CDG, Session, AMF, SDG
        case DATA_EVENT_TYPE:       // GPRS, GSMBC, PPSBC(EDGE, 3G) CDR Type
        case IR_EVENT_TYPE:         // IR(NRTRDE, TAP and SCP) CDR Type
            break;
        default:
            break;
    }

    if ( glb_MtxInd == NRTRDE_TYPE )
        glb_EAlmNrtCtr += isWrtten;
    else if ( glb_PartId == AWN_SVC_PARTITION )
        glb_EAlmPostpaidCtr += isWrtten;
    else if ( glb_PartId == PREPAID_SVC_PARTITION )
        glb_EAlmPrepaidCtr += isWrtten;
    else
        glb_EAlmAinCtr += isWrtten;

    return SUCCESS;

}

// Migrated CAMEL V.5, Change Voice CDR from SSP to GSM CDR - Added below by Kawee on 04-Jun-2007
char Is_IntlBno (char *szBno)
{
    if ( !strncmp(szBno, IDDACC_CODE, IDDACC_LEN) ||     /* Normal IDD Access Code */
         !strncmp(szBno, EPHACC_CODE, EPHACC_LEN) ||     /* E-Phone Access Code */
         !strncmp(szBno, TOTIDDACC_CODE, TOTIDDACC_LEN) ||   /* TOT Intl' Access Code */
         !strncmp(szBno, TOTVOIPACC_CODE, TOTVOIPACC_LEN) || /* TOT VOIP Intl' Access Code */
         !strncmp(szBno, "002", 3) ||            /* TOT Intl' ????? Code */
         !strncmp(szBno, AIN3RDACC_CODE, AIN3RDACC_LEN) ||   /* AIN 3rd Product Intl - Added by Kawee on 11-Nov-2009 */
         !strncmp(szBno, AIN2NDACC_CODE, AIN2NDACC_LEN) ||   /* AIN 2nd Product Intl - Added by Kawee on 25-Aug-2008 */
         !strncmp(szBno, AINIDDACC_CODE, AINIDDACC_LEN) ||   /* AIN Intl' Access Code */ /* Introduced AIN - Added by Kawee on 04-Jan-2007 */
         !strncmp(szBno, AWNIDDACC_COD3, AIN3RDACC_LEN) ||
         !strncmp(szBno, AWNIDDACC_COD2, AIN2NDACC_LEN) ||
         !strncmp(szBno, AWNIDDACC_COD1, AINIDDACC_LEN) ||   /* AWN IDD Access code 003, 0030, 00300 - Added by Thanakorn on 31-Oct-2013 */
         !strncmp(szBno, "006", 3) ) {    /* AIN Intl' Access Code */ /* Introduced AIN - Added by Kawee on 29-Jan-2007 */
        return TRUE;
    }
    return FALSE;
}

/* Changed as below by Kawee on 18-Apr-2008 */
int Conv_Gsm_Ano()
{
    if ( Conv_Ano(gsm_buf.a_no, com_buf.a_no) ) { /* Failure */
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    return SUCCESS;
}

int Conv_Gsm_Bno()
{
    char buffer[30];            /* Added for fixed B_no that append the routing address - by Kawee on 06-Jun-2003 */
    char szTmp[30];             /* Added for fixed B_no for 1 Sim 2 Number - by Kawee on 18-Apr-2008 */
    //char temp[30];              /* Added for fixed B_no that prefix with special number - by Kawee on 03-Apr-2008 */
    char area_code[SIZE_NDD+1]; /* Added for check area code of TOT premium call - by Kawee on 29-Oct-2003 */
    int  Bno_len = strlen(gsm_buf.b_no);

    memset(area_code, 0x00, sizeof (area_code));

    /* Fixed B_no that append the routing address as below - by Kawee 06-Jun-2003 */
    strcpy(buffer, gsm_buf.b_no);
    if ( Bno_len >=3 && gsm_buf.b_no[Bno_len-3] == 'A' ) {
        gsm_buf.b_no[Bno_len-3] = 0;
        Bno_len = Bno_len - 3;
    }
    /* Fixed B_no that prefix with 200 (1 SIM 2 Number Prefix) as below - by Kawee 18-Apr-2008 */
    if ( Bno_len > 3 && !strncmp(gsm_buf.b_no,"200",3) ) {
        strcpy(szTmp, gsm_buf.b_no+3);     /* Skip 200 and then Copy */
        strcpy(gsm_buf.b_no, szTmp);
        Bno_len = Bno_len - 3;
    }

    /* check b_no */
    if ( !Bno_len ) { /* b_no blank */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        strcpy(gsm_buf.b_no, buffer);
        return FAILURE;
    }

    if ( !strncmp(gsm_buf.b_no, "1800", 4) ||
         (!strncmp(gsm_buf.b_no, "0900", 4) && Bno_len < SIZE_PHONENO-1) ) { /* Invalid B_no - Added by Kawee on 22-Dec-2003 */
        strcpy(gsm_buf.b_no, buffer);
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO| invalid b_no(%s)\n", glb_Eindex, gsm_buf.b_no);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Added Service on Demand (call prefixed with 777708) - by Kawee on 15-Sep-2005 */
    if ( !strncmp(gsm_buf.b_no, "777708", 6) && Bno_len >= SIZE_PHONENO+4 ) {            /* Service on Demand */
        strcpy(com_buf.b_no, gsm_buf.b_no+4);          /* skip 7777 and copy */
    }
    /* Added Service on Demand (call prefixed with 777709) - by Thanakorn on 23-Mar-2011 */
    else if ( !strncmp(gsm_buf.b_no, "777709", 6) && Bno_len >= SIZE_PHONENO+4 ) {       /* Service on Demand */
        strcpy(com_buf.b_no, gsm_buf.b_no+4);          /* skip 7777 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "77770", 5) ) {     /* Service on Demand */
        if ( !Parse_Area(gsm_buf.b_no+4, area_code) ) {   /* Land Line */
            strcpy(com_buf.b_no, gsm_buf.b_no+4);      /* skip 7777 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");                /* Prefix 08 */
            strcat(com_buf.b_no, gsm_buf.b_no+5);      /* skip 77770 and copy */
        }
    }
    /* Introduced 1 Sim 2 Number project. Convert Ano/Bno from 20008xxxxxxx convert to 08xxxxxxx - by Kawee on 03-Apr-2008 */
    else if ( !strncmp(gsm_buf.b_no, "20066", 5) && Bno_len >= SIZE_PHONENO+4 &&
              (gsm_buf.b_no[5] == '6' || gsm_buf.b_no[5] == '8' || gsm_buf.b_no[5] == '9') ) {
        /* if starts with 200666, 200668 or 200669 */
        *com_buf.b_no = '0';            /* convert 20066 to 0 */
        strncat(com_buf.b_no, gsm_buf.b_no+5, SIZE_PHONENO-1);
    }
    else if ( !strncmp(gsm_buf.b_no, "20066", 5) && Bno_len >= SIZE_PHONENO+3) { /* if starts with 20066 */
        strcpy(com_buf.b_no, "08");        /* convert 20066 to 08 */
        strncat(com_buf.b_no, gsm_buf.b_no+5, SIZE_PHONENO-2);
    }
    else if ( !strncmp(gsm_buf.b_no, "2000", 4) && Bno_len >= SIZE_PHONENO+3 &&
              (gsm_buf.b_no[4] == '6' || gsm_buf.b_no[4] == '8' || gsm_buf.b_no[4] == '9') ) {
        /* if starts with 20006, 20008 or 20009 */
        strncpy(com_buf.b_no, gsm_buf.b_no+3, SIZE_PHONENO);   /* Remove 200 */
    }
    else if ( !strncmp(gsm_buf.b_no, "2000", 5) && Bno_len >= SIZE_PHONENO+2) {  /* if starts with 20066 */
        strcpy(com_buf.b_no, "08");        /* convert 2000 to 08 */
        strncat(com_buf.b_no, gsm_buf.b_no+4, SIZE_PHONENO-2);
    }
    else if ( !strncmp(gsm_buf.b_no, "061900900", 9) && Bno_len >= SIZE_PHONENO+2) {
        /* e.g. 061900900121 -> convert to 900121 */
        strcpy(com_buf.b_no, gsm_buf.b_no+6);  /* strip 061900 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "081900900", 9) && Bno_len >= SIZE_PHONENO+2) {    /* VMS access - Added by Kawee on 23-Dec-2003 */
        /* e.g. 081900900121 -> convert to 900121 */
        strcpy(com_buf.b_no, gsm_buf.b_no+6);  /* strip 081900 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "091900900", 9) && Bno_len >= SIZE_PHONENO+2) {    /* VMS access - Added by Thanakorn on 23-Mar-2011 */
        /* e.g. 091900900121 -> convert to 900121 */
        strcpy(com_buf.b_no, gsm_buf.b_no+6);  /* strip 091900 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "01900900", 8) && Bno_len >= SIZE_PHONENO+1) { /* VMS access - Added by Kawee on 23-Dec-2003 */
        /* e.g. 01900900121 -> convert to 900121 */
        strcpy(com_buf.b_no, gsm_buf.b_no+5);  /* strip 01900 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "061900", 6) && Bno_len < SIZE_PHONENO) {
        strcpy(com_buf.b_no, gsm_buf.b_no+3);  /* strip 061 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "081900", 6) && Bno_len < SIZE_PHONENO) {  /* VMS access - Added by Kawee on 22-Jul-2003 */
        strcpy(com_buf.b_no, gsm_buf.b_no+3);  /* strip 081 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "091900", 6) && Bno_len < SIZE_PHONENO) {  /* VMS access - Added by Thanakorn on 23-Mar-2011 */
        strcpy(com_buf.b_no, gsm_buf.b_no+3);  /* strip 091 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "01900", 5) && Bno_len < SIZE_PHONENO-1) { /* VMS access - Added by Kawee on 22-Jul-2003 */
        strcpy(com_buf.b_no, gsm_buf.b_no+2);  /* strip 01 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "06", 2) && Bno_len >= SIZE_PHONENO) {
        /* to Mobile or Land Line with 06 already prefixed (10 digits Number) */
        strcpy(com_buf.b_no, gsm_buf.b_no);    /* just copy */
    }
    /* Added Check for 10 Digits - Kawee on 06-Mar-2006 */
    else if ( !strncmp(gsm_buf.b_no, "08", 2) && Bno_len >= SIZE_PHONENO) {
        /* to Mobile or Land Line with 08 already prefixed (10 digits Number) */
        strcpy(com_buf.b_no, gsm_buf.b_no);    /* just copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "09", 2) && Bno_len >= SIZE_PHONENO) {
        /* to Mobile or Land Line with 09 already prefixed (10 digits Number) */
        strcpy(com_buf.b_no, gsm_buf.b_no);    /* just copy */
    }
    else if ( (*gsm_buf.b_no == '0') && !Parse_Area(gsm_buf.b_no, area_code) &&
        (Bno_len < SIZE_PHONENO-1 ||        /* Mobile to Abbreviated TOT numbers with NDD dialed */
        (!strncmp(gsm_buf.b_no+strlen(area_code), "1900", 4) && Bno_len > SIZE_PHONENO-1)) ) { /* Area Code + 1900xxxx */

        /*
        ** Call to Abbreviated TOT numbers with NDD dialed, B_no can be 021150,02191,053191,0531150
        ** this number would be convert to 1150, 191
        **
        ** Call to TOT Premium Call, B_no can be 0531900xxxxx, 021900xxxxxx
        ** this number would be convert to 1900xxxxxx
        ** - Kawee on 29-Oct-2003
        */

        strcpy(com_buf.b_no, gsm_buf.b_no + strlen(area_code));    /* strip area code and copy */
    }

    /* Fixed New Prefix Number of Mobile Phone Problem - Changed as below by Kawee on 13-Jun-2003 */
    /* Start - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */
    /* Changed as below by Kawee on 27-Jun-2003 */
    else if ( *gsm_buf.b_no == '0' && gsm_buf.b_no[1] >= '1' && gsm_buf.b_no[1] <= '9' &&
         Bno_len >= SIZE_PHONENO-1) {       /* to Mobile or Land Line with 0? already prefixed where ? is not 0 */
        if ( !Parse_Area(gsm_buf.b_no, area_code) ) { /* Land Line */
            strcpy(com_buf.b_no, gsm_buf.b_no);    /* just copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");            /* prefix 08 */
            strcpy(com_buf.b_no+2, gsm_buf.b_no+1);    /* just copy */
        }
    }
    else if ( !strncmp(gsm_buf.b_no, "1177", 4) ) {  /* ??TOT Special Number - Added by Kawee on 13-Jun-2003 */
        strcpy(com_buf.b_no, gsm_buf.b_no);    /* just copy */
    }
    /* End - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */

    else if ( !strncmp(gsm_buf.b_no, "1900", 4) ) {  /* Premium calls */
        strcpy(com_buf.b_no, gsm_buf.b_no);    /* just copy */
    }
    else if ( !strncmp(gsm_buf.b_no, LDDACC1_CODE, LDDACC1_LEN) ) {  /* LDD calls in format : C0xxxxxxxxxx */
        /* Convert C0 to #0 */
        strcpy(com_buf.b_no, gsm_buf.b_no);    /* just copy */
        *com_buf.b_no = '#';
    }
    else if ( !strncmp(gsm_buf.b_no, "B06", 3) && Bno_len >= SIZE_PHONENO+1) {  /* Voice2U */
        /* Bno = B06xxxxxxxx ==> Convert to 06xxxxxxxx */
        /* e.g.  B0618162164 ==> Convert to 0618162164 */
        strcpy(com_buf.b_no, gsm_buf.b_no+1);  /* skip B and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U 10 Digits - by Kawee on 06-Mar-2006 */
    else if ( !strncmp(gsm_buf.b_no, "B08", 3) && Bno_len >= SIZE_PHONENO+1) {  /* Voice2U */
        /* Bno = B08xxxxxxxx ==> Convert to 08xxxxxxxx */
        /* e.g.  B0818162164 ==> Convert to 0818162164 */
        strcpy(com_buf.b_no, gsm_buf.b_no+1);  /* skip B and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U 10 Digits - by Thanakorn on 23-Mar-2011 */
    else if ( !strncmp(gsm_buf.b_no, "B09", 3) && Bno_len >= SIZE_PHONENO+1) {  /* Voice2U */
        /* Bno = B09xxxxxxxx ==> Convert to 09xxxxxxxx */
        /* e.g.  B0918162164 ==> Convert to 0918162164 */
        strcpy(com_buf.b_no, gsm_buf.b_no+1);  /* skip B and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U - by Kawee on 04-Feb-2005 */
    else if ( !strncmp(gsm_buf.b_no, "B0", 2) && Bno_len >= SIZE_PHONENO) { /* Voice2U */
        /* Bno = B0xxxxxxxx ==> Convert to 08xxxxxxxx */
        /* e.g.  B018162164 ==> Convert to 0818162164 */
        strcpy(com_buf.b_no, "08");        /* profix with 08 */
        strcat(com_buf.b_no, gsm_buf.b_no+2);  /* skip B0 and then copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "00006", 5) && Bno_len == SIZE_PHONENO+3) {    /* Voice2U */
        /* Bno = 00006xxxxxxxx ==> Convert to 06xxxxxxxx */
        /* e.g.  0000618162164 ==> Convert to 0618162164 */
        strcpy(com_buf.b_no, gsm_buf.b_no+3);  /* skip 000 and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U (10 Digits) - by Kawee on 06-Mar-2006 */
    else if ( !strncmp(gsm_buf.b_no, "00008", 5) && Bno_len == SIZE_PHONENO+3) {    /* Voice2U */
        /* Bno = 00008xxxxxxxx ==> Convert to 08xxxxxxxx */
        /* e.g.  0000818162164 ==> Convert to 0818162164 */
        strcpy(com_buf.b_no, gsm_buf.b_no+3);  /* skip 000 and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U (10 Digits) - by Thanakorn on 23-Mar-2011 */
    else if ( !strncmp(gsm_buf.b_no, "00009", 5) && Bno_len == SIZE_PHONENO+3) {    /* Voice2U */
        /* Bno = 00009xxxxxxxx ==> Convert to 09xxxxxxxx */
        /* e.g.  0000918162164 ==> Convert to 0918162164 */
        strcpy(com_buf.b_no, gsm_buf.b_no+3);  /* skip 000 and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U - by Kawee on 04-Feb-2005 */
    else if ( !strncmp(gsm_buf.b_no, "0000", 4) && Bno_len == SIZE_PHONENO+2) { /* Voice2U */
        /* Bno = 0000xxxxxxxx ==> Convert to 08xxxxxxxx */
        /* e.g.  000018162164 ==> Convert to 0818162164 */
        strcpy(com_buf.b_no, "08");        /* profix with 08 */
        strcat(com_buf.b_no, gsm_buf.b_no+4);  /* skip 0000 and then copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "BB", 2) || !strncmp(gsm_buf.b_no, "CC", 2) ) {  /* Added by Thanakorn on 17-Jun-2013 */
        strcpy(com_buf.b_no, AIN3RDACC_CODE);     /* prefix 00500 */
        strcat(com_buf.b_no, gsm_buf.b_no+2);        /* strip CC,BB and copy */
    }
    else if ( *gsm_buf.b_no == 'B' || *gsm_buf.b_no == '*') {    /* new GSM VAS access(VAS & VAS+Numbers) */
        /* Need to convert b_no *xxx, Bxxx or 900xxx, added below by Kawee on 25-Apr-2006 */
        strcpy(com_buf.b_no, "900");   /* just copy */
        strcat(com_buf.b_no, gsm_buf.b_no+1);  /* just copy */
    }
    /* Added below condition - by Kawee on 13-Sep-2005 */
    else if ( !strncmp(gsm_buf.b_no, "66B", 3) ||
         !strncmp(gsm_buf.b_no, "66*", 3) ) {    /* new GSM VAS access(VAS & VAS+Numbers) */
        strcpy(com_buf.b_no, "900");
        strcat(com_buf.b_no, gsm_buf.b_no+3);  /* convert 66B, 66* to 900 and then copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "0B", 2) ||
         !strncmp(gsm_buf.b_no, "0*", 2) ) { /* new GSM VAS access(VAS & VAS+Numbers) */
        strcpy(com_buf.b_no, "900");
        strcat(com_buf.b_no, gsm_buf.b_no+2);  /* convert 0B, 0* to 900 and then copy */
    }
    else if ( Is_VasNumber (gsm_buf.b_no) ) {         /* GSM VAS numbers */
        strcpy(com_buf.b_no, gsm_buf.b_no);        /* just copy */

        if ( *com_buf.b_no == '*' || *com_buf.b_no == 'B') {         /* added by chamy on 3-Oct-2001 */
            strcpy(com_buf.b_no, "900");
            strcat(com_buf.b_no, gsm_buf.b_no+1);  /* convert B, * to 900 and then copy */
        }
    }
    else if ( Is_ExpressLink (gsm_buf.b_no) ) {       /* Express Link number + pager No. */
         strcpy(com_buf.b_no, gsm_buf.b_no);       /* just copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "66190098", 8) ) {  /* Voice message access + GSM No. */
         strcpy(com_buf.b_no, gsm_buf.b_no+3);     /* strip 661 */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(gsm_buf.b_no, "001#1166B", 9) ||
             !strncmp(gsm_buf.b_no, "001C1166B", 9) ) { /* Voice message access + GSM No. */
         strcpy(com_buf.b_no, "900");
         strcat(com_buf.b_no, gsm_buf.b_no+9);     /* convert 001#1166B,001C1166B to 900 and then copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "00166B", 6) ||    /* Voice message access + GSM No. */
         !strncmp(gsm_buf.b_no, "#1166B", 6) ||    /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
         !strncmp(gsm_buf.b_no, "C1166B", 6) ) {    /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
         strcpy(com_buf.b_no, "900");
         strcat(com_buf.b_no, gsm_buf.b_no+6);     /* convert 00166B,#1166B,C1166B to 900 and then copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "001#11666190098", 15) ||
             !strncmp(gsm_buf.b_no, "001C11666190098", 15) ) {  /* Voice message access + GSM No. */
         strcpy(com_buf.b_no, gsm_buf.b_no+10);        /* strip 001#116661,001C116661 */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(gsm_buf.b_no, "001#11668190098", 15) ||
             !strncmp(gsm_buf.b_no, "001C11668190098", 15) ) {  /* Voice message access + GSM No. */
         strcpy(com_buf.b_no, gsm_buf.b_no+10);        /* strip 001#116681,001C116681 */
    }
    else if ( !strncmp(gsm_buf.b_no, "001#11669190098", 15) ||
             !strncmp(gsm_buf.b_no, "001C11669190098", 15) ) {  /* Voice message access + GSM No. */
         strcpy(com_buf.b_no, gsm_buf.b_no+10);        /* strip 001#116691,001C116691 */
    }
    else if ( !strncmp(gsm_buf.b_no, "001666190098", 12) ||     /* Voice message access + GSM No. */
             !strncmp(gsm_buf.b_no, "#11666190098", 12) ||      /* AIN Phase 1 */
             !strncmp(gsm_buf.b_no, "C11666190098", 12) ) {     /* AIN Phase 1 */
         strcpy(com_buf.b_no, gsm_buf.b_no+7);     /* strip 0016661,#116681,C116661 */
    }
    else if ( !strncmp(gsm_buf.b_no, "001668190098", 12) || /* Voice message access + GSM No. */
             !strncmp(gsm_buf.b_no, "#11668190098", 12) || /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
             !strncmp(gsm_buf.b_no, "C11668190098", 12) ) { /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
         strcpy(com_buf.b_no, gsm_buf.b_no+7);     /* strip 0016681,#116681,C116681 */
    }
    else if ( !strncmp(gsm_buf.b_no, "001669190098", 12) || /* Voice message access + GSM No. */
             !strncmp(gsm_buf.b_no, "#11669190098", 12) || /* added by Thanakorn on 23-Mar-2011 */
             !strncmp(gsm_buf.b_no, "C11669190098", 12) ) { /* added by Thanakorn on 23-Mar-2011 */
         strcpy(com_buf.b_no, gsm_buf.b_no+7);     /* strip 0016691,#116691,C116691 */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(gsm_buf.b_no, "001#1166190098", 14) ||
             !strncmp(gsm_buf.b_no, "001C1166190098", 14) ) {   /* Voice message access + GSM No. */
         strcpy(com_buf.b_no, gsm_buf.b_no+9);     /* strip 001#11661,001C11661 */
    }
    else if ( !strncmp(gsm_buf.b_no, "00166190098", 11) ||  /* Voice message access + GSM No. */
             !strncmp(gsm_buf.b_no, "#1166190098", 11) ||  /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
             !strncmp(gsm_buf.b_no, "C1166190098", 11) ) {  /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
         strcpy(com_buf.b_no, gsm_buf.b_no+6);     /* strip 001661,#11661,C11661 */
    }
    else if ( (!strncmp(gsm_buf.b_no, "001#116661900", 10) ||
              !strncmp(gsm_buf.b_no, "001C116661900", 10)) &&
         Bno_len < SIZE_PHONENO+7) {    /* Intl' VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+10);     /* strip 001#116661, 001C116661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(gsm_buf.b_no, "001#116681900", 10) ||
              !strncmp(gsm_buf.b_no, "001C116681900", 10)) &&
         Bno_len < SIZE_PHONENO+7) {    /* Intl' VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+10);     /* strip 001#1166881,001C116681 and copy */
    }
    else if ( (!strncmp(gsm_buf.b_no, "001#116691900", 10) ||
              !strncmp(gsm_buf.b_no, "001C116691900", 10)) &&
         Bno_len < SIZE_PHONENO+7) {    /* Intl' VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+10);     /* strip 001#116691,001C116691 and copy */
    }
    else if ( (!strncmp(gsm_buf.b_no, "0016661900", 10) ||
              !strncmp(gsm_buf.b_no, "#116661900", 10) ||  /* Introduced AIN Phase */
              !strncmp(gsm_buf.b_no, "C116661900", 10)) && /* Introduced AIN Phase */
         Bno_len < SIZE_PHONENO+4) {            /* Intl' VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+7);  /* strip 0016661, #116661, C116661 and copy */
    }
    else if ( (!strncmp(gsm_buf.b_no, "0016681900", 10) ||
              !strncmp(gsm_buf.b_no, "#116681900", 10) ||  /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(gsm_buf.b_no, "C116681900", 10)) && /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
         Bno_len < SIZE_PHONENO+4) {            /* Intl' VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+7);  /* strip 00166881,#116681,C116681 and copy */
    }
    else if ( (!strncmp(gsm_buf.b_no, "0016691900", 10) ||
              !strncmp(gsm_buf.b_no, "#116691900", 10) ||
              !strncmp(gsm_buf.b_no, "C116691900", 10)) && /* added by Thanakorn on 23-Mar-2011 */
         Bno_len < SIZE_PHONENO+4) {            /* Intl' VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+7);  /* strip 0016691,#116691,C116691 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(gsm_buf.b_no, "001#11661900", 12) ||
              !strncmp(gsm_buf.b_no, "001C11661900", 12)) &&
         Bno_len < SIZE_PHONENO+6) {    /* Intl' VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+9);  /* strip 001#11661,001C11661 and copy */
    }
    else if ( (!strncmp(gsm_buf.b_no, "001661900", 9) ||
              !strncmp(gsm_buf.b_no, "#11661900", 9) ||    /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(gsm_buf.b_no, "C11661900", 9)) &&   /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
         Bno_len < SIZE_PHONENO+3) {    /* Intl' VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+6);  /* strip 001661,#11661,C11661 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "6681900", 6) && Bno_len < SIZE_PHONENO+1) {   /* VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+4);  /* strip 6681 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "6691900", 6) && Bno_len < SIZE_PHONENO+1) {   /* VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+4);  /* strip 6691 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "661900", 6) && Bno_len < SIZE_PHONENO) {  /* VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+3);  /* strip 661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(gsm_buf.b_no, "001#11900", 9) ||
              !strncmp(gsm_buf.b_no, "001C11900", 9)) &&
         Bno_len < SIZE_PHONENO+3) {                    /* VMS access */
        strcpy(com_buf.b_no, gsm_buf.b_no+6);  /* strip 001#11,001C11 and copy */
    }
    else if ( (!strncmp(gsm_buf.b_no, "001900", 6) ||
              !strncmp(gsm_buf.b_no, "#11900", 6) ||   /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(gsm_buf.b_no, "C11900", 6)) &&  /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
         Bno_len < SIZE_PHONENO) {          /* VMS access - Added by Kawee on 13-Jun-2003 */
        strcpy(com_buf.b_no, gsm_buf.b_no+3);  /* strip 001,#11,C11 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "001#1166061", 11) ||
              !strncmp(gsm_buf.b_no, "001C1166061", 11) ) {
#ifdef  CONV_BNO_C11_TO_005
        strcpy(com_buf.b_no, AINIDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+9);      /* Convert 001#11660,001C1166081 to 005 */
#else
        strcpy(com_buf.b_no, IDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+9);      /* Convert 001#11660,001C1166081 to 001 */
#endif
    }
    /* Start - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(gsm_buf.b_no, "001#1166081", 11) ||
              !strncmp(gsm_buf.b_no, "001C1166081", 11) ) {  /* Call to Japan (5-Jul-2001) */
/* Changed real version to interrim version as below - by Kawee on 20-Feb-2007 */
/* Changed interrim version to real version as above - by Kawee on 07-Feb-2007 */
#ifdef  CONV_BNO_C11_TO_005
        strcpy(com_buf.b_no, AINIDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+9);      /* Convert 001#11660,001C1166081 to 005 */
#else
        strcpy(com_buf.b_no, IDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+9);      /* Convert 001#11660,001C1166081 to 001 */
#endif
    }
    else if ( !strncmp(gsm_buf.b_no, "001#1166091", 11) ||
              !strncmp(gsm_buf.b_no, "001C1166091", 11) ) {  /* Call to Japan (23-Mar-2011) */
#ifdef  CONV_BNO_C11_TO_005
        strcpy(com_buf.b_no, AINIDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+9);      /* Convert 001#11660,001C1166081 to 005 */
#else
        strcpy(com_buf.b_no, IDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+9);      /* Convert 001#11660,001C1166081 to 001 */
#endif
    }
    else if ( !strncmp(gsm_buf.b_no, "#1166061", 8) ||
             !strncmp(gsm_buf.b_no, "C1166061", 8) ) {
#ifdef  CONV_BNO_C11_TO_005
        strcpy(com_buf.b_no, AINIDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+6);      /* Convert #11660,C11660 to 005 */
#else
        strcpy(com_buf.b_no, IDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+6);      /* Convert #11660,C11660 to 001 */
#endif
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(gsm_buf.b_no, "#1166081", 8) ||
             !strncmp(gsm_buf.b_no, "C1166081", 8) ) {  /* Call to Japan (5-Jul-2001) */
/* Changed real version to interrim version as below - by Kawee on 20-Feb-2007 */
/* Changed interrim version to real version as above - by Kawee on 07-Feb-2007 */
#ifdef  CONV_BNO_C11_TO_005
        strcpy(com_buf.b_no, AINIDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+6);      /* Convert #11660,C11660 to 005 */
#else
        strcpy(com_buf.b_no, IDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+6);      /* Convert #11660,C11660 to 001 */
#endif
    }
    else if ( !strncmp(gsm_buf.b_no, "#1166091", 8) ||
             !strncmp(gsm_buf.b_no, "C1166091", 8) ) {  /* Call to Japan (23-Mar-2011) */
#ifdef  CONV_BNO_C11_TO_005
        strcpy(com_buf.b_no, AINIDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+6);      /* Convert #11660,C11660 to 005 */
#else
        strcpy(com_buf.b_no, IDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+6);      /* Convert #11660,C11660 to 001 */
#endif
    }
    else if ( !strncmp(gsm_buf.b_no, "00166061", 8) ) {
        strcpy(com_buf.b_no, IDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+6);      /* Convert 001660 to 001 */
    }
    else if ( !strncmp(gsm_buf.b_no, "00166081", 8) ) {  /* Call to Japan (5-Jul-2001) */
        strcpy(com_buf.b_no, IDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+6);      /* Convert 001660 to 001 */
    }
    else if ( !strncmp(gsm_buf.b_no, "00166091", 8) ) {  /* Call to Japan (23-Mar-2011) */
        strcpy(com_buf.b_no, IDDACC_CODE);
        strcat(com_buf.b_no, gsm_buf.b_no+6);      /* Convert 001660 to 001 */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(gsm_buf.b_no, "001#116621", 10) ||
             !strncmp(gsm_buf.b_no, "001C116621", 10) ) {   /* to Pager etc. */
        strcpy(com_buf.b_no, gsm_buf.b_no+9);  /* strip 001#11662,001C11662 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "0016621", 7) ||   /* to Pager etc. */
         !strncmp(gsm_buf.b_no, "#116621", 7) ||   /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
         !strncmp(gsm_buf.b_no, "C116621", 7) ) {   /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
        strcpy(com_buf.b_no, gsm_buf.b_no+6);  /* strip 001662,#11662,C11662 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(gsm_buf.b_no, "001#1166", 8) ||
             !strncmp(gsm_buf.b_no, "001C1166", 8) ) {  /* To Mobile or Land Line */
        if ( gsm_buf.b_no[8] == '8' && Bno_len >= SIZE_PHONENO+7) {
            *com_buf.b_no = '0';                /* prefix 0 */
            strcpy(com_buf.b_no+1, gsm_buf.b_no+8);    /* strip 001#1166,001C1166 and then copy */
        }
        else if ( !Parse_Area(gsm_buf.b_no+8, area_code) ) {  /* Land Line */
            *com_buf.b_no = '0';
            strcpy(com_buf.b_no+1, gsm_buf.b_no+8);    /* strip 001#1166,001C1166 and then copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");            /* prefix 08 */
            strcpy(com_buf.b_no+2, gsm_buf.b_no+8);    /* strip 001#1166,001C1166 and then copy */
        }
    }
    /* Introduced AIN Phase 1 (#1166) as below - by Kawee on 15-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    /* Introduced TOT VOIP International access - Changed as below by Kawee on 07-Sep-2004 */
    else if ( !strncmp(gsm_buf.b_no, "00166", 5) ||
         !strncmp(gsm_buf.b_no, "00966", 5) ||
         !strncmp(gsm_buf.b_no, "00766", 5) ||
         !strncmp(gsm_buf.b_no, "00866", 5) ||
         !strncmp(gsm_buf.b_no, "00266", 5) ||
         !strncmp(gsm_buf.b_no, "#1166", 5) ||
         !strncmp(gsm_buf.b_no, "C1166", 5) ) {     /* To Mobile or Land Line */

        if ( gsm_buf.b_no[5] == '6' && Bno_len >= SIZE_PHONENO+4) {
            *com_buf.b_no = '0';                /* prefix 0 */
            strcpy(com_buf.b_no+1, gsm_buf.b_no+5);    /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else if ( gsm_buf.b_no[5] == '8' && Bno_len >= SIZE_PHONENO+4) {
            *com_buf.b_no = '0';                /* prefix 0 */
            strcpy(com_buf.b_no+1, gsm_buf.b_no+5);    /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else if ( gsm_buf.b_no[5] == '9' && Bno_len >= SIZE_PHONENO+4) {
            *com_buf.b_no = '0';                /* prefix 0 */
            strcpy(com_buf.b_no+1, gsm_buf.b_no+5);    /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else if ( !Parse_Area(gsm_buf.b_no+5, area_code) ) {  /* Land Line */
            *com_buf.b_no = '0';
            strcpy(com_buf.b_no+1, gsm_buf.b_no+5);    /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");            /* prefix 08 */
            strcpy(com_buf.b_no+2, gsm_buf.b_no+5);    /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
    }
    else if ( !strncmp(gsm_buf.b_no, "6621", 4) && Bno_len <= SIZE_PHONENO) {   /* to Pager etc. */
        strcpy(com_buf.b_no, gsm_buf.b_no+3);  /* strip 662 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "666", 3) && Bno_len >= SIZE_PHONENO+1) {  /* to Mobile */
        /* Remember : TAC numbers can start with 661 */
        *com_buf.b_no = '0';                /* prefix 0 */
        strcpy(com_buf.b_no+1, gsm_buf.b_no+2);    /* strip 66 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "668", 3) && Bno_len >= SIZE_PHONENO+1) {  /* to Mobile */
        /* Remember : TAC numbers can start with 661 */
        *com_buf.b_no = '0';                /* prefix 0 */
        strcpy(com_buf.b_no+1, gsm_buf.b_no+2);    /* strip 66 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "669", 3) && Bno_len >= SIZE_PHONENO+1) {  /* to Mobile */
        /* Remember : TAC numbers can start with 661 */
        *com_buf.b_no = '0';                /* prefix 0 */
        strcpy(com_buf.b_no+1, gsm_buf.b_no+2);    /* strip 66 and copy */
    }
    else if ( !strncmp(gsm_buf.b_no, "66", 2) && Bno_len >= SIZE_PHONENO) {
        /* Call to Mobile or Land Line except Pager etc. */
        /* Remember : TAC numbers can start with 661 */
        if ( !Parse_Area(gsm_buf.b_no, area_code) ) { /* Land Line */
            *com_buf.b_no = '0';
            strcpy(com_buf.b_no+1, gsm_buf.b_no+2);    /* strip 66 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");            /* prefix 08 */
            strcpy(com_buf.b_no+2, gsm_buf.b_no+2);    /* strip 66 and copy */
        }
    }
    else if ( *gsm_buf.b_no == '6' && Bno_len >= SIZE_PHONENO-1) { /* To Mobile start with 6 */
        *com_buf.b_no = '0';
        strcpy(com_buf.b_no+1, gsm_buf.b_no);      /* prefix 0 and copy */
    }
    /* Added below for 10 Digits - by Kawee on 06-Mar-2006 */
    else if ( *gsm_buf.b_no == '8' && Bno_len >= SIZE_PHONENO-1) { /* To Mobile start with 8 */
        *com_buf.b_no = '0';
        strcpy(com_buf.b_no+1, gsm_buf.b_no);      /* prefix 0 and copy */
    }
    else if ( *gsm_buf.b_no == '9' && Bno_len >= SIZE_PHONENO-1) { /* To Mobile start with 9 */
        *com_buf.b_no = '0';
        strcpy(com_buf.b_no+1, gsm_buf.b_no);      /* prefix 0 and copy */
    }
    /* Changed as below by Kawee on 27-Jun-2003 */
    else if ( *gsm_buf.b_no >= '1' && *gsm_buf.b_no <= '9' && Bno_len >= SIZE_PHONENO-2) { /* To Mobile start with 1,9,6,7,... */
        if ( !Parse_Area(gsm_buf.b_no, area_code) ) { /* Land Line */
            *com_buf.b_no = '0';
            strcpy(com_buf.b_no+1, gsm_buf.b_no);      /* prefix 0 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");            /* prefix 08 */
            strcpy(com_buf.b_no+2, gsm_buf.b_no);      /* prefix 0 and copy */
        }
    }
    else if ( Bno_len < 5 && *gsm_buf.b_no == '1') {     /* Should be Abbreviated TOT Numbers (5-Jul-2001) */
        strcpy(com_buf.b_no, gsm_buf.b_no);        /* just copy */
    }
    else if ( (!strncmp(gsm_buf.b_no, "001#1106", 8) ||
              !strncmp(gsm_buf.b_no, "001C1106", 8)) &&
         gsm_buf.b_no[8] >= '1' && gsm_buf.b_no[8] <= '9' &&
         Bno_len >= SIZE_PHONENO+6) {   /* To Mobile */
        strcpy(com_buf.b_no, gsm_buf.b_no+6); /* strip 001#11,001C11 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(gsm_buf.b_no, "001#1108", 8) ||
              !strncmp(gsm_buf.b_no, "001C1108", 8)) &&
         gsm_buf.b_no[8] >= '1' && gsm_buf.b_no[8] <= '9' &&
         Bno_len >= SIZE_PHONENO+6) {   /* To Mobile */
        strcpy(com_buf.b_no, gsm_buf.b_no+6); /* strip 001#11,001C11 and copy */
    }
    else if ( (!strncmp(gsm_buf.b_no, "001#1109", 8) ||
              !strncmp(gsm_buf.b_no, "001C1109", 8)) &&
         gsm_buf.b_no[8] >= '1' && gsm_buf.b_no[8] <= '9' &&
         Bno_len >= SIZE_PHONENO+6) {   /* To Mobile */
        strcpy(com_buf.b_no, gsm_buf.b_no+6); /* strip 001#11,001C11 and copy */
    }
    else if ( (!strncmp(gsm_buf.b_no, "00106", 5) ||
          !strncmp(gsm_buf.b_no, "#1106", 5) ||
          !strncmp(gsm_buf.b_no, "C1106", 5)) &&
         gsm_buf.b_no[5] >= '1' && gsm_buf.b_no[5] <= '9' &&
         Bno_len >= SIZE_PHONENO+3) {   /* To Mobile */
        strcpy(com_buf.b_no, gsm_buf.b_no+3); /* strip 001,#11,C11 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    else if ( (!strncmp(gsm_buf.b_no, "00108", 5) ||
          !strncmp(gsm_buf.b_no, "#1108", 5) ||
          !strncmp(gsm_buf.b_no, "C1108", 5)) &&
         gsm_buf.b_no[5] >= '1' && gsm_buf.b_no[5] <= '9' &&
         Bno_len >= SIZE_PHONENO+3) {   /* To Mobile */
        strcpy(com_buf.b_no, gsm_buf.b_no+3); /* strip 001,#11,C11 and copy */
    }
    else if ( (!strncmp(gsm_buf.b_no, "00109", 5) ||
          !strncmp(gsm_buf.b_no, "#1109", 5) ||
          !strncmp(gsm_buf.b_no, "C1109", 5)) &&
         gsm_buf.b_no[5] >= '1' && gsm_buf.b_no[5] <= '9' &&
         Bno_len >= SIZE_PHONENO+3) {   /* To Mobile */
        strcpy(com_buf.b_no, gsm_buf.b_no+3); /* strip 001,#11,C11 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(gsm_buf.b_no, "001#110", 7) ||
              !strncmp(gsm_buf.b_no, "001C110", 7)) &&
        gsm_buf.b_no[7] >= '1' && gsm_buf.b_no[7] <= '9') {
        if ( !Parse_Area(gsm_buf.b_no+6, area_code) ) {       /* Land Line */
            strcpy(com_buf.b_no, gsm_buf.b_no+6);  /* strip 001#11,001C11 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");        /* prefix 08 */
            strcat(com_buf.b_no, gsm_buf.b_no+7);  /* strip 001#110,001C110 and copy */
        }
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    else if ( (!strncmp(gsm_buf.b_no, "0010", 4) ||
          !strncmp(gsm_buf.b_no, "#110", 4) ||
          !strncmp(gsm_buf.b_no, "C110", 4)) &&
        gsm_buf.b_no[4] >= '1' && gsm_buf.b_no[4] <= '9') {
        if ( !Parse_Area(gsm_buf.b_no+3, area_code) ) {       /* Land Line */
            strcpy(com_buf.b_no, gsm_buf.b_no+3);  /* strip 001,#11,C11 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");        /* prefix 08 */
            strcat(com_buf.b_no, gsm_buf.b_no+4);  /* strip 0010,#110,C110 and copy */
        }
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(gsm_buf.b_no, "001#11", 6) ||
             !strncmp(gsm_buf.b_no, "001C11", 6) ) {
/* Changed real version to interrim version as below - by Kawee on 20-Feb-2007 */
/* Changed interrim version to real version as above - by Kawee on 07-Feb-2007 */
#ifdef  CONV_BNO_C11_TO_005
        strcpy(com_buf.b_no, AINIDDACC_CODE);      /* prefix 005 */
        strcat(com_buf.b_no, gsm_buf.b_no+6);  /* strip 001#11,001C11 and copy */
#else
        strcpy(com_buf.b_no, IDDACC_CODE);         /* prefix 001 */
        strcat(com_buf.b_no, gsm_buf.b_no+6);  /* strip 001#11,001C11 and copy */
#endif
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    else if ( !strncmp(gsm_buf.b_no, "#11", 3) ||
             !strncmp(gsm_buf.b_no, "C11", 3) ) {
/* Changed real version to interrim version as below - by Kawee on 20-Feb-2007 */
/* Changed interrim version to real version as above - by Kawee on 07-Feb-2007 */
#ifdef  CONV_BNO_C11_TO_005
        strcpy(com_buf.b_no, AINIDDACC_CODE);      /* prefix 005 */
        strcat(com_buf.b_no, gsm_buf.b_no+3);  /* strip #11,C11 and copy */
#else
        strcpy(com_buf.b_no, IDDACC_CODE);         /* prefix 001 */
        strcat(com_buf.b_no, gsm_buf.b_no+3);  /* strip #11,C11 and copy */
#endif
    }
    /* End - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */

    else    /* others */
        strcpy(com_buf.b_no, gsm_buf.b_no); /* copy complete */

    strcpy(gsm_buf.b_no, buffer); /* Added for fixed B_no that append the routing address - by Kawee on 06-Jun-2003 */
    return SUCCESS;
}

/*------ Conv_Gprs_Ano() function is added by kawin on 20-Sep-2002 -----*/
/* Changed as below by Kawee on 28-Feb-2006 */
/* Changed as below by Kawee on 18-Apr-2008 */
int Conv_Gprs_Ano()
{
    if ( Conv_Ano(pbuf_gprs[GPR_SRV_MSISDN], com_buf.a_no) ) {   /* Failure */
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    return SUCCESS;
}

/*------ Conv_Gprst_Ano() function is added by Kawee on 20-May-2004 -----*/
/* Changed as below by Kawee on 28-Feb-2006 */
int Conv_Gprst_Ano()
{
    char    buffer[30];     /* Added for fixed B_no that append the routing address - by Kawee on 06-Jun-2003 */
    char    szTmp[30];      /* Added for fixed B_no for 1 Sim 2 Number - by Kawee on 18-Apr-2008 */
    int Ano_len = strlen(gprst_buf.msisdn);

    /* Fixed B_no that prefix with 200 (1 SIM 2 Number Prefix) as below - by Kawee 18-Apr-2008 */
    strcpy(buffer, gprst_buf.msisdn);
    if ( Ano_len > 3 && !strncmp(gprst_buf.msisdn, "200", 3) ) {
        strcpy(szTmp, gprst_buf.msisdn+3);     /* Skip 200 and then Copy */
        strcpy(gprst_buf.msisdn, szTmp);
        Ano_len = Ano_len - 3;
    }

    /* check a_no (msisdn) */
    if ( !Ano_len ) { /* a_no blank */
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO Blank\n", glb_Eindex);
        strcpy(gprst_buf.msisdn, buffer);
        glb_ErrCtr++;
        return FAILURE;
    }
    /* Added below by Kawee on 21-Jul-2008 */
    else if ( !strncmp(gprst_buf.msisdn, "66", 2) && Ano_len >= SIZE_PHONENO+2 && (gprst_buf.msisdn[2]-'0' >= 2 || gprst_buf.msisdn[2]-'0' <= 5) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, buffer);
        strcpy(gprst_buf.msisdn, buffer);
        glb_ErrCtr++;
        return FAILURE;
    }
    else if ( gprst_buf.msisdn[0] == '0' && Ano_len >= (SIZE_PHONENO+1) && ( (gprst_buf.msisdn[1]-'0') >= 2 || (gprst_buf.msisdn[1]-'0') <= 5 ) ) {
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, buffer);
        strcpy(gprst_buf.msisdn, buffer);
        glb_ErrCtr++;
        return FAILURE;
    }

    if ( !strncmp(gprst_buf.msisdn, "6600", 4) &&
         (gprst_buf.msisdn[5] == '6' || gprst_buf.msisdn[5] == '8' || gprst_buf.msisdn[5] == '9') &&  /* added || gprst_buf.msisdn[5]=='9' by Thanakorn on 23-Mar-2011 */
         Ano_len >= SIZE_PHONENO+4 ) {
        /*
        ** Ano Start with 6600x8 then replace 6600x8 with 08
        **                6600x9 then replace 6600x9 with 09
        ** e.g. 66001898923092, 66002818761431, 66004819512797
        **      66001998923092, 66002918761431, 66004919512797
        ** convert to 0898923092, 0818761431, 0819512797
        **            0998923092, 0918761431, 0919512797
        ** - Kawee on 01-Mar-2006
        */
        *com_buf.a_no = '0';    /* Prefix 0 */
        strncpy(com_buf.a_no+1, gprst_buf.msisdn+5, SIZE_PHONENO-1);    /* strip 6600x and copy */
    }
    else if ( !strncmp(gprst_buf.msisdn, "6600", 4) && Ano_len >= SIZE_PHONENO+3) {
        /*
        ** Ano Start with 6600x then replace 6600x with 08
        ** e.g. 6600198923092, 6600218761431, 6600419512797
        ** convert to 0898923092, 0818761431, 0819512797
        ** - Kawee on 25-Jan-2005
        */
        strcpy(com_buf.a_no, "08");                    /* Prefix 08 */
        strncpy(com_buf.a_no+2, gprst_buf.msisdn+5, SIZE_PHONENO-2);    /* strip 6600x and copy */
    }
    else if ( !strncmp(gprst_buf.msisdn, "00166", 5) && Ano_len >= SIZE_PHONENO+4 &&
              (gprst_buf.msisdn[5] == '6' || gprst_buf.msisdn[5] == '8' || gprst_buf.msisdn[5] == '9') ) {
        /* if starts with 001666, 001668 or 001669 */
        *com_buf.a_no = '0';            /* convert 00166 to 0 */
        strncat(com_buf.a_no, gprst_buf.msisdn+5, SIZE_PHONENO-1);
    }
    else if ( !strncmp(gprst_buf.msisdn, "00166", 5) && Ano_len >= SIZE_PHONENO+3 ) {       /* if starts with 00166 */
        strcpy(com_buf.a_no, "08");        /* convert 00166 to 08 */
        strncat(com_buf.a_no, gprst_buf.msisdn+5, SIZE_PHONENO-2);
    }
    /* Introduced 1 Sim 2 Number project. Convert Ano/Bno from 2008xxxxxxx convert to 08xxxxxxx - by Kawee on 03-Apr-2008 */
    else if ( !strncmp(gprst_buf.msisdn, "20066", 5) && Ano_len >= SIZE_PHONENO+4 &&
              (gprst_buf.msisdn[5] == '6' || gprst_buf.msisdn[5] == '8' || gprst_buf.msisdn[5] == '9') ) {
        /* if starts with 200666, 200668 or 200669 */
        *com_buf.a_no = '0';            /* convert 20066 to 0 */
        strncat(com_buf.a_no, gprst_buf.msisdn+5, SIZE_PHONENO-1);
    }
    else if ( !strncmp(gprst_buf.msisdn, "20066", 5) && Ano_len >= SIZE_PHONENO+3 ) {       /* if starts with 20066 */
        strcpy(com_buf.a_no, "08");        /* convert 20066 to 08 */
        strncat(com_buf.a_no, gprst_buf.msisdn+5, SIZE_PHONENO-2);
    }
    else if ( !strncmp(gprst_buf.msisdn, "2000", 4) && Ano_len >= SIZE_PHONENO+3 &&
              (gprst_buf.msisdn[4] == '6' || gprst_buf.msisdn[4] == '8' || gprst_buf.msisdn[4] == '9') ) {
        /* if starts with 20008 */
        strncpy(com_buf.a_no, gprst_buf.msisdn+3, SIZE_PHONENO);   /* Remove 200 */
    }
    else if ( !strncmp(gprst_buf.msisdn, "2000", 5) && Ano_len >= SIZE_PHONENO+2 ) {        /* if starts with 20066 */
        strcpy(com_buf.a_no, "08");        /* convert 2000 to 08 */
        strncat(com_buf.a_no, gprst_buf.msisdn+4, SIZE_PHONENO-2);
    }
    else if ( !strncmp(gprst_buf.msisdn, "66", 2) && Ano_len >= SIZE_PHONENO+1 &&
              (gprst_buf.msisdn[2] == '6' || gprst_buf.msisdn[2] == '8' || gprst_buf.msisdn[2] == '9') ) {
        /* if starts with 666, 668, 669 */
        *com_buf.a_no = '0';            /* convert 66 to 0 */
        strncat(com_buf.a_no, gprst_buf.msisdn+2, SIZE_PHONENO-1);
    }
    /*
    ** Added below to Reject Unknown Convert Logic A_no
    ** if Length is greater than SIZE_PHONENO except Number start with 6600
    ** e.g. 6600198923092, 6600218761431, 6600419512797
    ** - Added by Kawee on 14-Jan-2005
    */
    else if ( Ano_len > SIZE_PHONENO ) {
        /* a_no length too long and not start with 6600, unknown format to convert */
        fprintf(glb_Errfp, "[DET] %s|Field|A_NO| invalid a_no(%s)\n", glb_Eindex, gprst_buf.msisdn);
        strcpy(gprst_buf.msisdn, buffer);
        glb_ErrCtr++;
        return FAILURE;
    }
    else if ( !strncmp(gprst_buf.msisdn, "66", 2) && Ano_len >= SIZE_PHONENO ) {            /* if starts with 66 */
        strcpy(com_buf.a_no, "08");        /* convert 66 to 08 */
        strncat(com_buf.a_no, gprst_buf.msisdn+2, SIZE_PHONENO-2);
    }
    else if ( gprst_buf.msisdn[0] == '0' && Ano_len >= SIZE_PHONENO &&
              (gprst_buf.msisdn[1] == '6' || gprst_buf.msisdn[1] == '8' || gprst_buf.msisdn[3] == '9') ) {
        /* if starts with 06, 08 or 09 */
        strncpy(com_buf.a_no, gprst_buf.msisdn, SIZE_PHONENO); /* Just Copy */
    }
    else if ( gprst_buf.msisdn[0] == '0' && Ano_len >= SIZE_PHONENO-1 ) {                   /* if starts with 0 and 9 Digits */
        strcpy(com_buf.a_no, "08");        /* convert 66 to 08 */
        strncat(com_buf.a_no, gprst_buf.msisdn+1, SIZE_PHONENO-1);
    }
    else if ( (gprst_buf.msisdn[0] == '6' || gprst_buf.msisdn[0] == '8' || gprst_buf.msisdn[0] == '9') && Ano_len >= SIZE_PHONENO-1 ) {
        /* if starts with 6, 8 or 9 */
        *com_buf.a_no = '0';    /* Prefix 0 */
        strncat(com_buf.a_no, gprst_buf.msisdn, SIZE_PHONENO-1);
    }
    else if ( Ano_len == SIZE_PHONENO-2 ) {
        strcpy(com_buf.a_no, "08");                 /* prefix 08 */
        strcat(com_buf.a_no, gprst_buf.msisdn);     /* and copy */
    }
    else {  /* we assume 0 is already prefixed here */
        strncpy(com_buf.a_no, gprst_buf.msisdn, SIZE_PHONENO-1);    /* copy complete */
    }

    com_buf.a_no[SIZE_PHONENO] = '\0';      /* make sure the size is 9 digits */
    strcpy(gprst_buf.msisdn, buffer);
    return SUCCESS;
}

/* Changed as below by Kawee on 18-Apr-2008 */
int Conv_DpcGsm_Ano()
{
    if ( Conv_Ano(dpcgsm_buf.a_no, com_buf.a_no) ) {   /* Failure */
        fprintf(glb_Errfp, "[DET] %s|%s\n", glb_Eindex, glb_MsgText);
        glb_ErrCtr++;
        return FAILURE;
    }
    return SUCCESS;
}

int Conv_DpcGsm_Bno()
{
    char buffer[30];    /* Added for fixed B_no that append the routing address - by Kawee on 06-Jun-2003 */
    char szTmp[30];     /* Added for fixed B_no for 1 Sim 2 Number - by Kawee on 18-Apr-2008 */
    int  Bno_len = strlen(dpcgsm_buf.b_no);
    char area_code[SIZE_NDD+1];     /* Added for check area code of 10 Digit Phone Number format - by Kawee on 27-Mar-2006 */

    /* Fixed B_no that append the routing address as below - by Kawee 06-Jun-2003 */
    strcpy(buffer, dpcgsm_buf.b_no);
    if ( Bno_len >=3 && dpcgsm_buf.b_no[Bno_len-3] == 'A' ) {
        dpcgsm_buf.b_no[Bno_len-3] = 0;
        Bno_len = Bno_len - 3;
    }
    /* Fixed B_no that prefix with 200 (1 SIM 2 Number Prefix) as below - by Kawee 18-Apr-2008 */
    if ( Bno_len > 3 && !strncmp(dpcgsm_buf.b_no,"200",3) ) {
        strcpy(szTmp, dpcgsm_buf.b_no+3);      /* Skip 200 and then Copy */
        strcpy(dpcgsm_buf.b_no, szTmp);
        Bno_len = Bno_len - 3;
    }
    /* check b_no */
    if ( !Bno_len ) { /* b_no blank */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO_Blank\n", glb_Eindex);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* Remove Reject "002xxxxxxxxx" - Changed as below by Kawee on 13-Sep-2005 */
    if ( (!strncmp(dpcgsm_buf.b_no, "0900", 4) && Bno_len < SIZE_PHONENO-1) ) { /* Invalid B_no - Added by Kawee on 22-Dec-2003 */
        /* For DPC 1800 is VAS Number -> My Logo */
        fprintf(glb_Errfp, "[DET] %s|Field|B_NO| invalid b_no(%s)\n", glb_Eindex, dpcgsm_buf.b_no);
        glb_ErrCtr++;
        return FAILURE;
    }

    /* VMB call check - added by Kawee on 30-May-2003 */
    if ( !strncmp(dpcgsm_buf.b_no, "011882", 6) ) {         /* VMB calls */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+2);            /* strip 01 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "11882", 5) ) {     /* VMB calls */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+1);            /* strip 1 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "0611882", 7) ) {   /* VMB calls */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 061 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "0811882", 7) ) {   /* VMB calls */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 081 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "0911882", 7) ) {   /* VMB calls */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 091 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "611882", 7) ) {    /* VMB calls */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+2);            /* strip 61 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "811882", 7) ) {    /* VMB calls */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+2);            /* strip 81 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "911882", 7) ) {    /* VMB calls */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+2);            /* strip 91 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "061900900", 9) && Bno_len >= SIZE_PHONENO+2 ) {
        /* e.g. 081900900121 -> convert to 900121 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+6);            /* strip 061900 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "081900900", 9) && Bno_len >= SIZE_PHONENO+2 ) {    /* VMS access - Added by Kawee on 23-Dec-2003 */
        /* e.g. 081900900121 -> convert to 900121 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+6);            /* strip 081900 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "091900900", 9) && Bno_len >= SIZE_PHONENO+2 ) {    /* VMS access - Added by Thanakorn on 23-Mar-2011 */
        /* e.g. 091900900121 -> convert to 900121 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+6);            /* strip 091900 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "01900900", 8) && Bno_len >= SIZE_PHONENO+1 ) {     /* VMS access - Added by Kawee on 23-Dec-2003 */
        /* e.g. 01900900121 -> convert to 900900121 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+5);            /* strip 01900 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "061900", 6) && Bno_len < SIZE_PHONENO ) {
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 061 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "081900", 6) && Bno_len < SIZE_PHONENO ) {          /* VMS access - Added by Kawee on 22-Jul-2003 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 081 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "091900", 6) && Bno_len < SIZE_PHONENO) {           /* VMS access - Added by Thanakorn on 23-Mar-2011 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 091 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "01900", 5) && Bno_len < SIZE_PHONENO-1 ) {         /* VMS access - Added by Kawee on 22-Jul-2003 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+2);            /* strip 01 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "06", 2) && Bno_len >= SIZE_PHONENO ) {
        /* to Mobile with 06 already prefixed (10 digits Number) */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no);              /* just copy */
    }
    /* Added Check for 10 Digits - Kawee on 06-Mar-2006 */
    else if ( !strncmp(dpcgsm_buf.b_no, "08", 2) && Bno_len >= SIZE_PHONENO ) {
        /* to Mobile with 08 already prefixed (10 digits Number) */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no);              /* just copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "09", 2) && Bno_len >= SIZE_PHONENO ) {
        /* to Mobile with 09 already prefixed (10 digits Number) */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no);              /* just copy */
    }
    /* Start - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */
    else if ( *dpcgsm_buf.b_no == '0' && dpcgsm_buf.b_no[1] >= '1' && dpcgsm_buf.b_no[1] <= '9' &&
              Bno_len == SIZE_PHONENO-1 ) {                 /* Mobile to Mobile with 0? prefixed where ? != 0 */
        if ( !Parse_Area(dpcgsm_buf.b_no, area_code) ) {    /* Land Line */
            strcpy(com_buf.b_no, dpcgsm_buf.b_no);          /* copy complete */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");                     /* prefix complete */
            strcpy(com_buf.b_no+2, dpcgsm_buf.b_no+1);
        }
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "1177", 4) ) {      /* ??TOT Special Number - Added by Kawee on 13-Jun-2003 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no);              /* just copy */
    }
    /* End - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */

    /* Premium calls check added on 28-May-2002 - chamy */
    else if ( !strncmp(dpcgsm_buf.b_no, "1900", 4) ) {      /* Premium calls */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no);              /* just copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, LDDACC1_CODE, LDDACC1_LEN) ) {  /* LDD calls in format : C0xxxxxxxxxx */
        /* Convert C0 to #0 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no);              /* just copy */
        *com_buf.b_no = '#';
    }
    /* Added Check Dpc VAS Number - by Kawee on 12-Mar-2003 */
    else if ( Is_DpcVasNumber(dpcgsm_buf.b_no) ) {         /* DPC VAS numbers */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no);              /* just copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "B06", 3) && Bno_len >= SIZE_PHONENO+1 ) {  /* Voice2U */
        /* Bno = B06xxxxxxxx ==> Convert to 06xxxxxxxx */
        /* e.g.  B0618162164 ==> Convert to 0618162164 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+1);            /* skip B and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U (10 Digits) - by Kawee on 06-Mar-2006 */
    else if ( !strncmp(dpcgsm_buf.b_no, "B08", 3) && Bno_len >= SIZE_PHONENO+1 ) {  /* Voice2U */
        /* Bno = B08xxxxxxxx ==> Convert to 08xxxxxxxx */
        /* e.g.  B0818162164 ==> Convert to 0818162164 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+1);            /* skip B and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "B09", 3) && Bno_len >= SIZE_PHONENO+1 ) {  /* Voice2U */
        /* Bno = B09xxxxxxxx ==> Convert to 09xxxxxxxx */
        /* e.g.  B0918162164 ==> Convert to 0918162164 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+1);            /* skip B and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U - by Kawee on 04-Feb-2005 */
    else if ( !strncmp(dpcgsm_buf.b_no, "B0", 2) && Bno_len >= SIZE_PHONENO ) {         /* Voice2U */
        /* Bno = B0xxxxxxxx ==> Convert to 08xxxxxxxx */
        /* e.g.  B018162164 ==> Convert to 0818162164 */
        strcpy(com_buf.b_no, "08");                 /* profix with 08 */
        strcat(com_buf.b_no, dpcgsm_buf.b_no+2);    /* skip B0 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "00006", 5) && Bno_len == SIZE_PHONENO+3 ) {    /* Voice2U */
        /* Bno = 00006xxxxxxxx ==> Convert to 06xxxxxxxx */
        /* e.g.  0000618162164 ==> Convert to 0618162164 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);    /* skip 000 and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U (10 Digits) - by Kawee on 06-Mar-2006 */
    else if ( !strncmp(dpcgsm_buf.b_no, "00008", 5) && Bno_len == SIZE_PHONENO+3 ) {    /* Voice2U */
        /* Bno = 00008xxxxxxxx ==> Convert to 08xxxxxxxx */
        /* e.g.  0000818162164 ==> Convert to 0818162164 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);    /* skip 000 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "00009", 5) && Bno_len == SIZE_PHONENO+3 ) {    /* Voice2U */
        /* Bno = 00009xxxxxxxx ==> Convert to 09xxxxxxxx */
        /* e.g.  0000918162164 ==> Convert to 0918162164 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);    /* skip 000 and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U - by Kawee on 04-Feb-2005 */
    else if ( !strncmp(dpcgsm_buf.b_no, "0000", 4) && Bno_len == SIZE_PHONENO+2 ) {     /* Voice2U */
        /* Bno = 0000xxxxxxxx ==> Convert to 08xxxxxxxx */
        /* e.g.  000018162164 ==> Convert to 0818162164 */
        strcpy(com_buf.b_no, "08");                 /* profix with 08 */
        strcat(com_buf.b_no, dpcgsm_buf.b_no+4);    /* skip 0000 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "BB", 2) || !strncmp(dpcgsm_buf.b_no, "CC", 2) ) {      /* Added by Thanakorn on 17-Jun-2013 */
        strcpy(com_buf.b_no, AIN3RDACC_CODE);       /* prefix 00500 */
        strcat(com_buf.b_no, dpcgsm_buf.b_no+2);    /* strip CC,BB and copy */
    }
    else if ( *dpcgsm_buf.b_no == 'B' || *dpcgsm_buf.b_no == 'b' || *dpcgsm_buf.b_no == '*' ) { /* new GSM VAS access */
        /*
        ** Some VAS services start with B or b or * for DPC GSM network.
        **  - chamy 11-Mar-2002.
        */
        strcpy(com_buf.b_no, "900");
        strcat(com_buf.b_no, dpcgsm_buf.b_no+1);
    }
    /* Added below by Kawee on 29-Dec-2003 */
    else if ( *dpcgsm_buf.b_no == '0' &&
              (dpcgsm_buf.b_no[1] == 'B' || dpcgsm_buf.b_no[1] == 'b' || dpcgsm_buf.b_no[1] == '*') ) { /* new GSM VAS access */
        /*
        ** Some VAS services start with 0B or 0b or 0* for DPC GSM network.
        **  - Kawee 29-Dec-2003.
        */
        /* Convert b_no *xxx or Bxxx to 900xxx, changed as below by Kawee on 13-Sep-2005 */
        strcpy(com_buf.b_no, "900");
        strcat(com_buf.b_no, dpcgsm_buf.b_no+2);
    }
    /* Start - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(dpcgsm_buf.b_no, "001#116621", 10) ||
              !strncmp(dpcgsm_buf.b_no, "001C116621", 10) ) {       /* to Pager etc. */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+9);                    /* strip 001#11662,001C11662 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "0016621", 7) ||    /* to Pager etc. */
              !strncmp(dpcgsm_buf.b_no, "#116621", 7) ||    /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(dpcgsm_buf.b_no, "C116621", 7) ) {   /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+6);            /* strip 001662,#11662,C11662 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(dpcgsm_buf.b_no, "001#1166B", 9) ||
              !strncmp(dpcgsm_buf.b_no, "001C1166B", 9) ) {  /* Voice message access + GSM No. */
        strcpy(com_buf.b_no, "900");
        strcat(com_buf.b_no, dpcgsm_buf.b_no+9);            /* convert 001#1166B,001C1166B to 900 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "00166B", 6) ||     /* Voice message access + GSM No. */
              !strncmp(dpcgsm_buf.b_no, "#1166B", 6) ||     /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(dpcgsm_buf.b_no, "C1166B", 6) ) {    /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
        strcpy(com_buf.b_no, "900");
        strcat(com_buf.b_no, dpcgsm_buf.b_no+6);            /* convert 00166B,#1166B,C1166B to 900 and then copy */
    }
    else if ( (!strncmp(dpcgsm_buf.b_no, "001#116661900", 13) ||
              !strncmp(dpcgsm_buf.b_no, "001C116661900", 13)) &&
              Bno_len < SIZE_PHONENO+7 ) {                  /* Intl' VMS access */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+10);           /* strip 001#116661,001C116661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(dpcgsm_buf.b_no, "001#116681900", 13) ||
              !strncmp(dpcgsm_buf.b_no, "001C116681900", 13)) &&
              Bno_len < SIZE_PHONENO+7 ) {                  /* Intl' VMS access */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+10);           /* strip 001#1166881,001C116681 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(dpcgsm_buf.b_no, "0016681900", 10) ||
              !strncmp(dpcgsm_buf.b_no, "#116681900", 10) ||
              !strncmp(dpcgsm_buf.b_no, "C116681900", 10)) &&
              Bno_len < SIZE_PHONENO+4 ) {                  /* Intl' VMS access */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+7);            /* strip 00166881,#116681,C116681 and copy */
    }
    else if ( (!strncmp(dpcgsm_buf.b_no, "0016691900", 10) ||
              !strncmp(dpcgsm_buf.b_no, "#116691900", 10) ||
              !strncmp(dpcgsm_buf.b_no, "C116691900", 10)) &&
              Bno_len < SIZE_PHONENO+4 ) {                  /* Intl' VMS access */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+7);            /* strip 0016691,#116691,C116691 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(dpcgsm_buf.b_no, "001#11661900", 12) ||
              !strncmp(dpcgsm_buf.b_no, "001C11661900", 12)) &&
              Bno_len < SIZE_PHONENO+6 ) {                  /* Intl' VMS access */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+9);            /* strip 001#11661,001C11661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(dpcgsm_buf.b_no, "001661900", 9) ||
              !strncmp(dpcgsm_buf.b_no, "#11661900", 9) ||
              !strncmp(dpcgsm_buf.b_no, "C11661900", 9)) &&
              Bno_len < SIZE_PHONENO+3 ) {                  /* Intl' VMS access */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+6);            /* strip 001661,#11661,C11661 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "6661900", 7) && Bno_len < SIZE_PHONENO+1 ) {   /* VMS access */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+4);            /* strip 6661 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "6681900", 7) && Bno_len < SIZE_PHONENO+1 ) {   /* VMS access */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+4);            /* strip 6681 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "661900", 6) && Bno_len < SIZE_PHONENO ) {      /* VMS access */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(dpcgsm_buf.b_no, "001#11900", 9) ||
              !strncmp(dpcgsm_buf.b_no, "001C11900", 9)) &&
              Bno_len < SIZE_PHONENO+3 ) {                  /* VMS access - Added by Kawee on 13-Jun-2003 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+6);            /* strip 001#11,001C11 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(dpcgsm_buf.b_no, "001900", 6) ||
              !strncmp(dpcgsm_buf.b_no, "#11900", 6) ||
              !strncmp(dpcgsm_buf.b_no, "C11900", 6)) &&
              Bno_len < SIZE_PHONENO ) {                    /* VMS access - Added by Kawee on 13-Jun-2003 */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 001,#11,C11 and copy */
    }

    /* Introduced TOT VOIP International access - Changed as below by Kawee on 07-Sep-2004 */
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(dpcgsm_buf.b_no, "001#1166", 8) ||
              !strncmp(dpcgsm_buf.b_no, "001C1166", 8) ) {  /* To Mobile or Land Line except Pager etc. */
        if ( dpcgsm_buf.b_no[8] == '8' && Bno_len >= SIZE_PHONENO+7 ) {
            *com_buf.b_no = '0';                            /* prefix 0 */
            strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+8);      /* strip 001#1166,001C1166 and then copy */
        }
        else if ( dpcgsm_buf.b_no[8] == '9' && Bno_len >= SIZE_PHONENO+7 ) {
            *com_buf.b_no = '0';                            /* prefix 0 */
            strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+8);      /* strip 001#1166,001C1166 and then copy */
        }
        else if ( !Parse_Area(dpcgsm_buf.b_no+8, area_code) ) { /* Land Line */
            *com_buf.b_no = '0';
            strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+8);          /* strip 001#1166,001C1166 and then copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");                         /* prefix 08 */
            strcpy(com_buf.b_no+2, dpcgsm_buf.b_no+8);          /* strip 001#1166,001C1166 and then copy */
        }
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "00166", 5) ||
              !strncmp(dpcgsm_buf.b_no, "00966", 5) ||
              !strncmp(dpcgsm_buf.b_no, "00766", 5) ||
              !strncmp(dpcgsm_buf.b_no, "00866", 5) ||
              !strncmp(dpcgsm_buf.b_no, "00266", 5) ||      /* To Mobile or Land Line except Pager etc. */
              !strncmp(dpcgsm_buf.b_no, "#1166", 5) ||      /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(dpcgsm_buf.b_no, "C1166", 5) ) {     /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */

        if ( dpcgsm_buf.b_no[5] == '6' && Bno_len >= SIZE_PHONENO+4 ) {
            *com_buf.b_no = '0';                            /* prefix 0 */
            strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+5);      /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else if ( dpcgsm_buf.b_no[5] == '8' && Bno_len >= SIZE_PHONENO+4 ) {
            *com_buf.b_no = '0';                            /* prefix 0 */
            strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+5);      /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else if ( dpcgsm_buf.b_no[5] == '9' && Bno_len >= SIZE_PHONENO+4 ) {
            *com_buf.b_no = '0';                            /* prefix 0 */
            strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+5);      /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else if ( !Parse_Area(dpcgsm_buf.b_no+5, area_code) ) { /* Land Line */
            *com_buf.b_no = '0';
            strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+5);          /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");                         /* prefix 08 */
            strcpy(com_buf.b_no+2, dpcgsm_buf.b_no+5);          /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "660", 3) && Bno_len >= SIZE_PHONENO+1 ) {
        /* Found in TAC CDR */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+2);                /* convert 660? to 0? and copy where ? != 0 */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "6621", 4) && Bno_len <= SIZE_PHONENO ) {   /* to Pager etc. */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);                /* strip 662 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "666", 3) && Bno_len >= SIZE_PHONENO+1 ) {  /* To Mobile */
        /* Remember : TAC numbers can start with 6661 */
        *com_buf.b_no = '0';                        /* prefix 0 */
        strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+2);  /* convert 66 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "668", 3) && Bno_len >= SIZE_PHONENO+1 ) {  /* To Mobile */
        /* Remember : TAC numbers can start with 6681 */
        *com_buf.b_no = '0';                        /* prefix 0 */
        strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+2);  /* convert 66 and copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "669", 3) && Bno_len >= SIZE_PHONENO+1 ) {  /* To Mobile */
        /* Remember : TAC numbers can start with 6691 */
        *com_buf.b_no = '0';                        /* prefix 0 */
        strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+2);  /* convert 66 and copy */
    }
    /* Added below by Kawee on 07-Apr-2006 */
    else if ( !strncmp(dpcgsm_buf.b_no, "66B", 3) ||
              !strncmp(dpcgsm_buf.b_no, "66*", 3) ) {   /* VAS access(VAS & VAS+Numbers) */
        strcpy(com_buf.b_no, "900");                    /* skip 66 and then copy */
        strcat(com_buf.b_no, dpcgsm_buf.b_no+3);        /* skip 66 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "0B", 2) ||
              !strncmp(dpcgsm_buf.b_no, "0*", 2) ) {    /* VAS access(VAS & VAS+Numbers) */
        strcpy(com_buf.b_no, "900");                    /* skip 66 and then copy */
        strcat(com_buf.b_no, dpcgsm_buf.b_no+2);        /* skip 0 and then copy */
    }
    else if ( !strncmp(dpcgsm_buf.b_no, "66", 2) && Bno_len >= SIZE_PHONENO ) {
        /* Remember : TAC numbers can start with 661 */
        if ( !Parse_Area(dpcgsm_buf.b_no, area_code) ) {    /* Land Line */
            *com_buf.b_no = '0';
            strcpy(com_buf.b_no+1, dpcgsm_buf.b_no+2);      /* strip 66 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");                     /* prefix 08 */
            strcpy(com_buf.b_no+2, dpcgsm_buf.b_no+2);      /* strip 66 and copy */
        }
    }
    else if ( *dpcgsm_buf.b_no == '6' && Bno_len >= SIZE_PHONENO-1 ) {  /* To Mobile start with 6 */
        *com_buf.b_no = '0';
        strcpy(com_buf.b_no+1, dpcgsm_buf.b_no);            /* prefix 0 and copy */
    }
    /* Added below for 10 Digits - by Kawee on 06-Mar-2006 */
    else if ( *dpcgsm_buf.b_no == '8' && Bno_len >= SIZE_PHONENO-1 ) {  /* To Mobile start with 8 */
        *com_buf.b_no = '0';
        strcpy(com_buf.b_no+1, dpcgsm_buf.b_no);            /* prefix 0 and copy */
    }
    else if ( *dpcgsm_buf.b_no == '9' && Bno_len >= SIZE_PHONENO-1 ) {  /* To Mobile start with 9 */
        *com_buf.b_no = '0';
        strcpy(com_buf.b_no+1, dpcgsm_buf.b_no);            /* prefix 0 and copy */
    }
    /* Added Check for start with 1,9 or 6 - by Kawee on 07-Nov-2002 */
    /* Changed as below by Kawee on 27-Jun-2003 */
    /* else if ( *dpcgsm_buf.b_no != '0' && Bno_len == SIZE_PHONENO-2) {} */
    else if ( *dpcgsm_buf.b_no >= '1' && *dpcgsm_buf.b_no <= '9' && Bno_len >= SIZE_PHONENO-2 ) {
        if ( !Parse_Area(dpcgsm_buf.b_no, area_code) ) {    /* Land Line */
            *com_buf.b_no = '0';
            strcpy(com_buf.b_no+1, dpcgsm_buf.b_no);        /* prefix 0 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");                     /* prefix 08 */
            strcpy(com_buf.b_no+2, dpcgsm_buf.b_no);        /* prefix 0 and copy */
        }
    }
    else if ( (*dpcgsm_buf.b_no == '0') && !Parse_Area(dpcgsm_buf.b_no, area_code) &&
              (Bno_len < SIZE_PHONENO-1 ||                  /* Mobile to Abbreviated TOT numbers with NDD dialed */
              (!strncmp(dpcgsm_buf.b_no+strlen(area_code), "1900", 4) && Bno_len > SIZE_PHONENO-1)) ) { /* Area Code + 1900xxxx */
        /*
        ** Call to Abbreviated TOT numbers with NDD dialed, B_no can be 021150,02191,053191,0531150
        ** this number would be convert to 1150, 191
        **
        ** Call to TOT Premium Call, B_no can be 0531900xxxxx, 021900xxxxxx
        ** this number would be convert to 1900xxxxxx
        ** - Kawee on 29-Oct-2003
        */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no + strlen(area_code));  /* strip area code and copy */
    }
    else if ( Bno_len < 5 && *dpcgsm_buf.b_no == '1' ) {            /* Should be Abbreviated TOT Numbers (5-Jul-2001) */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no);                      /* just copy */
    }
    else if ( (!strncmp(dpcgsm_buf.b_no, "001#1106", 8) ||
              !strncmp(dpcgsm_buf.b_no, "001C1106", 8)) &&
              dpcgsm_buf.b_no[8] >= '1' && dpcgsm_buf.b_no[8] <= '9' &&
              Bno_len >= SIZE_PHONENO+6 ) {         /* To Mobile */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+6);    /* strip 001#11,001C11 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(dpcgsm_buf.b_no, "001#1108", 8) ||
              !strncmp(dpcgsm_buf.b_no, "001C1108", 8)) &&
              dpcgsm_buf.b_no[8] >= '1' && dpcgsm_buf.b_no[8] <= '9' &&
              Bno_len >= SIZE_PHONENO+6 ) {         /* To Mobile */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+6);    /* strip 001#11,001C11 and copy */
    }
    else if ( (!strncmp(dpcgsm_buf.b_no, "001#1109", 8) ||
              !strncmp(dpcgsm_buf.b_no, "001C1109", 8)) &&
              dpcgsm_buf.b_no[8] >= '1' && dpcgsm_buf.b_no[8] <= '9' &&
              Bno_len >= SIZE_PHONENO+6 ) {         /* To Mobile */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+6);    /* strip 001#11,001C11 and copy */
    }
    else if ( (!strncmp(dpcgsm_buf.b_no, "00106", 5) ||
              !strncmp(dpcgsm_buf.b_no, "#1106", 5) ||
              !strncmp(dpcgsm_buf.b_no, "C1106", 5)) &&
              dpcgsm_buf.b_no[5] >= '1' && dpcgsm_buf.b_no[5] <= '9' &&
              Bno_len >= SIZE_PHONENO+3 ) {                 /* To Mobile */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 001,#11,C11 and copy */
    }
    else if ( (!strncmp(dpcgsm_buf.b_no, "00108", 5) ||
              !strncmp(dpcgsm_buf.b_no, "#1108", 5) ||      /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(dpcgsm_buf.b_no, "C1108", 5)) &&     /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
              dpcgsm_buf.b_no[5] >= '1' && dpcgsm_buf.b_no[5] <= '9' &&
              Bno_len >= SIZE_PHONENO+3 ) {                 /* To Mobile */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 001,#11,C11 and copy */
    }
    else if ( (!strncmp(dpcgsm_buf.b_no, "00109", 5) ||
              !strncmp(dpcgsm_buf.b_no, "#1109", 5) ||      /* Introduced AIN Phase 1 - added by Thanakorn on 23-Mar-2011 */
              !strncmp(dpcgsm_buf.b_no, "C1109", 5)) &&     /* Introduced AIN Phase 1 - added by Thanakorn on 23-Mar-2011 */
              dpcgsm_buf.b_no[5] >= '1' && dpcgsm_buf.b_no[5] <= '9' &&
              Bno_len >= SIZE_PHONENO+3 ) {                 /* To Mobile */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 001,#11,C11 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(dpcgsm_buf.b_no, "001#110", 7) ||
              !strncmp(dpcgsm_buf.b_no, "001C110", 7)) &&
              dpcgsm_buf.b_no[7] >= '1' && dpcgsm_buf.b_no[7] <= '9') {
        if ( !Parse_Area(dpcgsm_buf.b_no+6, area_code) ) {  /* Land Line */
            strcpy(com_buf.b_no, dpcgsm_buf.b_no+6);        /* strip 001#11,001C11 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");                 /* prefix 08 */
            strcat(com_buf.b_no, dpcgsm_buf.b_no+7);    /* strip 001#110,001C110 and copy */
        }
    }
    else if ( (!strncmp(dpcgsm_buf.b_no, "0010", 4) ||
              !strncmp(dpcgsm_buf.b_no, "#110", 4) ||           /* Introduced AIN Phase 1 - by Kawee on 15-Nov-2006 */
              !strncmp(dpcgsm_buf.b_no, "C110", 4)) &&          /* Introduced AIN Phase 1 - by Kawee on 06-Dec-2006 */
              dpcgsm_buf.b_no[4] >= '1' && dpcgsm_buf.b_no[4] <= '9' ) {
        if ( !Parse_Area(dpcgsm_buf.b_no+3, area_code) ) {      /* Land Line */
            strcpy(com_buf.b_no, dpcgsm_buf.b_no+3);            /* strip 001,#11,C11 and copy */
        }
        else {  /* Mobile Number */
            strcpy(com_buf.b_no, "08");                         /* prefix 08 */
            strcat(com_buf.b_no, dpcgsm_buf.b_no+4);            /* strip 0010,#110,C110 and copy */
        }
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(dpcgsm_buf.b_no, "001#11", 6) ||
              !strncmp(dpcgsm_buf.b_no, "001C11", 6) ) {
/* Changed real version to interrim version as below - by Kawee on 20-Feb-2007 */
/* Changed interrim version to real version as above - by Kawee on 07-Feb-2007 */
#ifdef  CONV_BNO_C11_TO_005
        strcpy(com_buf.b_no, AINIDDACC_CODE);                   /* prefix 005 */
        strcat(com_buf.b_no, dpcgsm_buf.b_no+6);                /* strip 001#11,001C11 and copy */
#else
        strcpy(com_buf.b_no, IDDACC_CODE);                      /* prefix 001 */
        strcat(com_buf.b_no, dpcgsm_buf.b_no+6);                /* strip 001#11,001C11 and copy */
#endif
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    else if ( !strncmp(dpcgsm_buf.b_no, "#11", 3) ||
              !strncmp(dpcgsm_buf.b_no, "C11", 3) ) {
/* Changed real version to interrim version as below - by Kawee on 20-Feb-2007 */
/* Changed interrim version to real version as above - by Kawee on 07-Feb-2007 */
#ifdef  CONV_BNO_C11_TO_005
        strcpy(com_buf.b_no, AINIDDACC_CODE);                   /* prefix 005 */
        strcat(com_buf.b_no, dpcgsm_buf.b_no+3);                /* strip #11,C11 and copy */
#else
        strcpy(com_buf.b_no, IDDACC_CODE);                      /* prefix 001 */
        strcat(com_buf.b_no, dpcgsm_buf.b_no+3);                /* strip #11,C11 and copy */
#endif
    }
    /* End - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */

    else {  /* others */
        strcpy(com_buf.b_no, dpcgsm_buf.b_no);                  /* copy complete */
    }

    strcpy(dpcgsm_buf.b_no, buffer);                            /* Added for fixed B_no that append the routing address - by Kawee on 06-Jun-2003 */

    return SUCCESS;
}

int Conv_Sms_Bno()
{
    return (Conv_CommonSms_Bno(sms_buf.b_no, com_buf.b_no));
}

int Conv_Smc_Bno()
{
    return (Conv_CommonSms_Bno(smc_buf.b_no, com_buf.b_no));
}

/*------ Conv_Ano() function is added by Kawee on 05-Nov-2004 -----*/
/* Changed as below by Kawee on 28-Feb-2006 */
int Conv_Ano(char *input_ano, char *output_ano)
{
    char cRej;
    char buffer[30];    /* Added for fixed B_no that append the routing address - by Kawee on 06-Jun-2003 */
    char szTmp[30];     /* Added for fixed B_no for 1 Sim 2 Number - by Kawee on 18-Apr-2008 */
    int  Ano_len = strlen(input_ano);

    /* Fixed A_no that prefix with 200 (1 SIM 2 Number Prefix) as below - by Kawee 18-Apr-2008 */
    strcpy(buffer, input_ano);
    if ( Ano_len > 3 && !strncmp(input_ano,"200",3) ) {
        strcpy(szTmp, input_ano+3);     /* Skip 200 and then Copy */
        strcpy(input_ano, szTmp);
        Ano_len = Ano_len - 3;
    }

    /* check a_no (msisdn) */
    cRej = FALSE;
    if ( !Ano_len ) { /* a_no blank */
        cRej = TRUE;
        strcpy(glb_MsgText, "Field|A_NO Blank");
    }

    /* changed below by Thanakorn on 30-Apr-2013 */
    else if ( !strncmp(input_ano, "66", 2) && Ano_len >= SIZE_PHONENO+2 ) {
        if ( input_ano[2]-'0' >= 2 && input_ano[2]-'0' <= 5 ) {
            cRej = TRUE;
            sprintf(glb_MsgText, "Field|A_NO| dummy a_no(%s)", buffer);
        }
    }
    //else if ( !strncmp(input_ano, "02", 2) && Ano_len >= SIZE_PHONENO+1) {
    else if ( *input_ano == '0' && Ano_len >= SIZE_PHONENO+1 ) {
        if ( input_ano[1]-'0' >= 2 && input_ano[1]-'0' <= 5 ) {
            cRej = TRUE;
            sprintf(glb_MsgText, "Field|A_NO| dummy a_no(%s)", buffer);
        }
    }

    if ( cRej == TRUE ) {
        strcpy(input_ano, buffer);
        return FAILURE;
    }

    if ( !strncmp(input_ano, "00166", 5) && Ano_len >= SIZE_PHONENO+4 &&
         input_ano[5]-'0' >= 6 && input_ano[5]-'0' <= 9 ) {
        // Added by N.Thanakorn on 27-Jun-2014
        // if starts with 00166x where x is expected to be 6, 8, 9
        *output_ano = '0';      // convert 00166 to 0
        strncat(output_ano, input_ano+5, SIZE_PHONENO-1);
    }
    // Start - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003
    /* Remove this following block by N.Thanakorn on 27-Jun-2014
    if ( !strncmp(input_ano, "001668", 6) && Ano_len >= SIZE_PHONENO+4) {    // if starts with 001668
        *output_ano = '0';          // convert 00166 to 0
        strncat (output_ano, input_ano+5, SIZE_PHONENO-1);
    }
    else if ( !strncmp(input_ano, "001669", 6) && Ano_len >= SIZE_PHONENO+4) {   // if starts with 001668
        *output_ano = '0';          // convert 00166 to 0
        strncat (output_ano, input_ano+5, SIZE_PHONENO-1);
    } */
    else if ( !strncmp(input_ano, "00166", 5) && Ano_len >= SIZE_PHONENO+3 ) {    // if starts with 00166
        strcpy(output_ano, "08");      // convert 00166 to 08
        strncat(output_ano, input_ano+5, SIZE_PHONENO-2);
    }
    else if ( !strncmp(input_ano, "6600", 4) &&
              (input_ano[5]=='6' || input_ano[5]=='8' || input_ano[5]=='9') &&
              Ano_len >= SIZE_PHONENO+4 ) {
        /*
        ** Ano Start with 6600?X where X can be 6, 8 or 9 then replace 6600? with 0
        ** e.g. 66001898923092, 66002818761431, 66004819512797
        **      66001998923092, 66002918761431, 66009819512797
        ** convert to 0898923092, 0818761431, 0819512797
        **            0998923092, 0918761431, 0919512797
        ** - Kawee on 01-Mar-2006, Thanakorn on 23-Mar-2011 ( added 09 )
        */
        strcpy(output_ano, "0");       /* convert 00166 to 0 */
        strncat(output_ano, input_ano+5, SIZE_PHONENO-1);
    }
    else if ( !strncmp(input_ano, "6600", 4) && Ano_len >= SIZE_PHONENO+3 ) {
        /*
        ** Ano Start with 6600x then replace 6600x with 08
        ** e.g. 6600198923092, 6600218761431, 6600419512797
        ** convert to 0898923092, 0818761431, 0819512797
        ** - Kawee on 25-Jan-2005
        */
        strcpy(output_ano, "08");      /* convert 00166 to 08 */
        strncat(output_ano, input_ano+5, SIZE_PHONENO-2);
    }
    else if ( !strncmp(input_ano, "666", 3) && Ano_len >= SIZE_PHONENO+1 && (input_ano[2]=='6' || input_ano[2]=='8' || input_ano[2]=='9') ) {
        /* if starts with 666, 668, 669 */
        *output_ano = '0';          /* convert 66 to 0 */
        strncat(output_ano, input_ano+2, SIZE_PHONENO-1);
    }
    else if ( !strncmp(input_ano, "66", 2) && Ano_len >= SIZE_PHONENO ) { /* if starts with 66 */
        strcpy(output_ano, "0");      /* convert 66 to 0 */
        strncat(output_ano, input_ano+2, SIZE_PHONENO-1);
    }
    else if ( !strncmp(input_ano, "66", 2) && Ano_len == SIZE_PHONENO ) { /* if starts with 66 */
        strcpy(output_ano, "08");      /* convert 66 to 08 */
        strncat(output_ano, input_ano+2, SIZE_PHONENO-2);
    }
    else if ( input_ano[0] == '0' && Ano_len >= SIZE_PHONENO && (input_ano[1]=='6' || input_ano[1]=='8' || input_ano[1]=='9') ) {
        /* if starts with 06, 08, 09 */
        strncpy(output_ano, input_ano, SIZE_PHONENO);  /* Just Copy */
    }
    else if ( input_ano[0] == '0' && Ano_len >= SIZE_PHONENO-1 ) {  /* if starts with 0 and 9 Digits */
        strcpy(output_ano, "08");      /* remove first 0 then prefix with 08 */
        strncat(output_ano, input_ano+1, SIZE_PHONENO-1);
    }
    else if ( (input_ano[0] == '6' || input_ano[0] == '8' || input_ano[0] == '9') && Ano_len >= SIZE_PHONENO-1) {
        /* if starts with 6, 8, 9 */
        *output_ano = '0';  /* Prefix 0 */
        strncat(output_ano, input_ano, SIZE_PHONENO-1);
    }
    else if ( Ano_len == SIZE_PHONENO-2 ) {
        strcpy(output_ano, "08");       /* prefix 08 */
        strcat(output_ano, input_ano);  /* and copy */
    }
    else if ( Ano_len > SIZE_PHONENO-2 && *input_ano != '0' &&
              Scan_ForAlpha(input_ano) ) {  /* like 98010223FFA0 or 18010223FFA0 */
        strcpy(output_ano, "08");           /* prefix 08 */
        strncat(output_ano, input_ano, SIZE_PHONENO-2);     /* and copy */
    }
    else {  /* we assume 0 is already prefixed here */
        strncpy(output_ano, input_ano, SIZE_PHONENO);  /* copy complete */
    }
    /* End - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */

    output_ano[SIZE_PHONENO] = '\0';    /* make sure the size is 9 digits */
    strcpy(input_ano, buffer);
    return SUCCESS;
}

/*------ Conv_Ain_Ano() function is added by Kawee on 29-Jan-2007 -----*/
int Conv_Ain_Ano(char *input_ano, char *output_ano)
{
    char buffer[30];                    /* Added for fixed B_no that append the routing address - by Kawee on 06-Jun-2003 */
    char szTmp[30];                     /* Added for fixed B_no for 1 Sim 2 Number - by Kawee on 18-Apr-2008 */
    int  Ano_len = strlen(input_ano);
    char area_code[SIZE_NDD+1];         /* Added for check area code of land line call */

    /* Fixed B_no that prefix with 200 (1 SIM 2 Number Prefix) as below - by Kawee 18-Apr-2008 */
    strcpy(buffer, input_ano);
    if ( Ano_len > 3 && !strncmp(input_ano, "200", 3) ) {
        strcpy(szTmp, input_ano+3);     /* Skip 200 and then Copy */
        strcpy(input_ano, szTmp);
        Ano_len = Ano_len - 3;
    }

    /* check a_no (msisdn) */
    if ( !Ano_len ) {   /* a_no blank */
        strcpy(input_ano, buffer);
        strcpy(glb_MsgText, "a_no Blank");
        return FAILURE;
    }
    /* Added below by Kawee on 21-Jul-2008 */
    else if ( !strncmp(input_ano, "66", 2) && Ano_len >= SIZE_PHONENO+2 &&
              (input_ano[2]-'0' >= 2 && input_ano[2]-'0' <= 5 ) ) {
        strcpy(input_ano, buffer);
        sprintf(glb_MsgText, "Invalid A-Number: %s", buffer);
        return FAILURE;
    }
    else if ( input_ano[0] == '0' && Ano_len >= SIZE_PHONENO+1 &&
              (input_ano[2]-'0' >= 2 && input_ano[2]-'0' <= 5) ) {
        strcpy(input_ano, buffer);
        sprintf(glb_MsgText, "Invalid A-Number: %s", buffer);
        return FAILURE;
    }

    if ( !strncmp(input_ano, "66", 2) && Ano_len >= SIZE_PHONENO+1 &&
         (input_ano[2] == '6' || input_ano[2] == '8' || input_ano[2] == '9') ) {
        /* if starts with 666, 668 or 669 */
        *output_ano = '0';          /* convert 66 to 0 */
        strncat(output_ano, input_ano+2, SIZE_PHONENO-1);
    }
    else if ( !strncmp(input_ano, "66", 2) && Ano_len >= SIZE_PHONENO ) {
        /* Orinate Call is Mobile or Land Line */
        if ( !Parse_Area(input_ano, area_code) ) {    /* Land Line */
            *output_ano = '0';
            strcpy(output_ano+1, input_ano+2); /* strip 66 and copy */
        }
        else {  /* Mobile Number */
            strcpy(output_ano, "08");          /* prefix 08 */
            strcpy(output_ano+2, input_ano+2); /* strip 66 and copy */
        }
    }
    else if ( input_ano[0] == '0' && Ano_len >= SIZE_PHONENO &&
              (input_ano[1] == '6' || input_ano[1] == '8' || input_ano[1] == '9') ) {
        /* Originate Call is Mobile or Land Line with 06, 08 or 09 already prefixed (10 digits Number) */
        strcpy(output_ano, input_ano);     /* just copy */
    }
    else if ( *input_ano == '0' && input_ano[1] >= '1' && input_ano[1] <= '9' &&
         Ano_len >= SIZE_PHONENO-1 ) { /* to Mobile or Land Line already prefixed */
        if ( !Parse_Area(input_ano, area_code) ) {    /* Land Line */
            strcpy(output_ano, input_ano); /* just copy */
        }
        else {  /* Mobile Number */
            strcpy(output_ano, "08");          /* prefix 08 */
            strcat(output_ano+2, input_ano+1); /* just copy */
        }
    }
    else    /* no need to convert */
        strncpy(output_ano, input_ano, SIZE_MOBILE_NUM);  /* copy complete */

    strcpy(input_ano, buffer);
    return SUCCESS;
}

int Conv_CommonVoice_Bno(char *org_bno, char *output_bno)
{
    char buffer[30];                /* Added for fixed B_no that append the routing address - by Kawee on 06-Jun-2003 */
    char szTmp[30];                 /* Added for fixed B_no for 1 Sim 2 Number - by Kawee on 18-Apr-2008 */
    char area_code[SIZE_NDD+1];     /* Added for check area code of TOT premium call - by Kawee on 29-Oct-2003 */
    char input_bno[30];
    int  Bno_len;

    memset(area_code, 0x00, sizeof(area_code));
    memset(buffer, 0x00, sizeof(buffer));
    memset(input_bno, 0x00, sizeof(input_bno));

    /* Fixed B_no that append the routing address as below - by Kawee 06-Jun-2003 */
    strcpy(buffer, org_bno);
    strcpy(output_bno, org_bno);

    /*
        Added the following if-else block by N.Thanakorn on 17-Nov-2014
        to support VolLTE (4G Voice)
    */
    if ( strncmp(org_bno, "0090", 4) == 0 ) {
        strcpy(input_bno, org_bno+4);
    }
    else {
        strcpy(input_bno, org_bno);
    }
    Bno_len = strlen(input_bno);

    if ( Bno_len >=3 && input_bno[Bno_len-3] == 'A' ) {
        input_bno[Bno_len-3] = 0;
        Bno_len = Bno_len - 3;
    }
    /* Fixed B_no that prefix with 200 (1 SIM 2 Number Prefix) as below - by Kawee 18-Apr-2008 */
    if ( Bno_len > 3 && !strncmp(input_bno,"200",3) ) {
        strcpy(szTmp, input_bno+3);        /* Skip 200 and then Copy */
        strcpy(input_bno, szTmp);
        Bno_len = Bno_len - 3;
    }

    /* check b_no */
    if ( !Bno_len ) { /* b_no blank */
        strcpy(input_bno, buffer);
        return FAILURE;
    }

    if ( (!strncmp(input_bno, "0900", 4) && Bno_len < SIZE_PHONENO-1) ) {       /* Invalid B_no - Added by Kawee on 22-Dec-2003 */
        return FAILURE;
    }

    if ( !strncmp(input_bno, "777706", 6) && Bno_len >= SIZE_PHONENO+4 ) {      /* Service on Demand */
        strcpy(output_bno, input_bno+4);   /* skip 7777 and copy */
    }
    /* Added Service on Demand (call prefixed with 777708) - by Kawee on 15-Sep-2005 */
    else if ( !strncmp(input_bno, "777708", 6) && Bno_len >= SIZE_PHONENO+4 ) {      /* Service on Demand */
        strcpy(output_bno, input_bno+4);   /* skip 7777 and copy */
    }
    else if ( !strncmp(input_bno, "777709", 6) && Bno_len >= SIZE_PHONENO+4 ) { /* Service on Demand */
        strcpy(output_bno, input_bno+4);   /* skip 7777 and copy */
    }
    else if ( !strncmp(input_bno, "77770", 5) ) {           /* Service on Demand */
        if ( !Parse_Area(input_bno+4, area_code) ) {        /* Land Line */
            strcpy(output_bno, input_bno+4);                /* skip 7777 and copy */
        }
        else {
            strcpy(output_bno, "08");                       /* prefix 08 */
            strcat(output_bno, input_bno+5);                /* skip 77770 and copy */
        }
    }
    /* Added IODC Number as below by Kawee on 07-Dec-2007 */
    else if ( !strncmp(input_bno, "1800", 4) ) {
        strcpy(output_bno, input_bno);     /* Just copy */
    }
    else if ( !strncmp(input_bno, "061900900", 9) && Bno_len >= SIZE_PHONENO+2 ) {
        /* e.g. 061900900121 -> convert to 900121 */
        strcpy(output_bno, input_bno+6);   /* strip 061900 and copy */
    }
    else if ( !strncmp(input_bno, "081900900", 9) && Bno_len >= SIZE_PHONENO+2 ) {   /* VMS access - Added by Kawee on 23-Dec-2003 */
        /* e.g. 081900900121 -> convert to 900121 */
        strcpy(output_bno, input_bno+6);   /* strip 081900 and copy */
    }
    else if ( !strncmp(input_bno, "091900900", 9) && Bno_len >= SIZE_PHONENO+2 ) {   /* VMS access - Added by Thanakorn on 23-Mar-2011 */
        /* e.g. 091900900121 -> convert to 900121 */
        strcpy(output_bno, input_bno+6);   /* strip 091900 and copy */
    }
    else if ( !strncmp(input_bno, "01900900", 8) && Bno_len >= SIZE_PHONENO+1 ) {    /* VMS access - Added by Kawee on 23-Dec-2003 */
        /* e.g. 01900900121 -> convert to 900121 */
        strcpy(output_bno, input_bno+5);   /* strip 01900 and copy */
    }
    else if ( !strncmp(input_bno, "061900", 6) && Bno_len < SIZE_PHONENO ) {
        strcpy(output_bno, input_bno+3);   /* strip 061 and copy */
    }
    else if ( !strncmp(input_bno, "081900", 6) && Bno_len < SIZE_PHONENO ) {     /* VMS access - Added by Kawee on 22-Jul-2003 */
        strcpy(output_bno, input_bno+3);   /* strip 081 and copy */
    }
    else if ( !strncmp(input_bno, "091900", 6) && Bno_len < SIZE_PHONENO ) {     /* VMS access - Added by Thanakorn on 23-Mar-2011 */
        strcpy(output_bno, input_bno+3);   /* strip 091 and copy */
    }
    else if ( !strncmp(input_bno, "01900", 5) && Bno_len < SIZE_PHONENO-1 ) {    /* VMS access - Added by Kawee on 22-Jul-2003 */
        strcpy(output_bno, input_bno+2);   /* strip 01 and copy */
    }
    else if ( !strncmp(input_bno, "06", 2) && Bno_len >= SIZE_PHONENO ) {
        /* to Mobile or Land Line with 06 already prefixed (10 digits Number) */
        strcpy(output_bno, input_bno);     /* just copy */
    }
    /* Added Check for 10 Digits - Kawee on 06-Mar-2006 */
    else if ( !strncmp(input_bno, "08", 2) && Bno_len >= SIZE_PHONENO ) {
        /* to Mobile or Land Line with 08 already prefixed (10 digits Number) */
        strcpy(output_bno, input_bno);     /* just copy */
    }
    else if ( !strncmp(input_bno, "09", 2) && Bno_len >= SIZE_PHONENO ) {
        /* to Mobile or Land Line with 09 already prefixed (10 digits Number) */
        strcpy(output_bno, input_bno);     /* just copy */
    }
    else if ( (*input_bno == '0') && !Parse_Area(input_bno, area_code) &&
              (Bno_len < SIZE_PHONENO-1 ||        /* Mobile to Abbreviated TOT numbers with NDD dialed */
              (!strncmp(input_bno+strlen(area_code), "1900", 4) && Bno_len > SIZE_PHONENO-1)) ) {    /* Area Code + 1900xxxx */

        /*
        ** Call to Abbreviated TOT numbers with NDD dialed, B_no can be 021150,02191,053191,0531150
        ** this number would be convert to 1150, 191
        **
        ** Call to TOT Premium Call, B_no can be 0531900xxxxx, 021900xxxxxx
        ** this number would be convert to 1900xxxxxx
        ** - Kawee on 29-Oct-2003
        */
        strcpy(output_bno, input_bno + strlen(area_code)); /* strip area code and copy */
    }
    /* Fixed New Prefix Number of Mobile Phone Problem - Changed as below by Kawee on 13-Jun-2003 */
    /* Start - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */
    /* Changed as below by Kawee on 27-Jun-2003 */
    else if ( *input_bno == '0' && input_bno[1] >= '1' && input_bno[1] <= '9' &&
              Bno_len >= SIZE_PHONENO-1 ) { /* to Mobile or Land Line already prefixed */

        if ( !Parse_Area(input_bno, area_code) ) {    /* Land Line */
            strcpy(output_bno, input_bno); /* just copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");          /* prefix 08 */
            strcat(output_bno+2, input_bno+1); /* just copy */
        }
    }
    else if ( !strncmp(input_bno, "1177", 4) ) { /* ??TOT Special Number - Added by Kawee on 13-Jun-2003 */
        strcpy(output_bno, input_bno); /* just copy */
    }
    /* End - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */

    else if ( !strncmp(input_bno, "1900", 4) ) { /* Premium calls */
        strcpy(output_bno, input_bno); /* just copy */
    }
    else if ( !strncmp(input_bno, LDDACC1_CODE, LDDACC1_LEN) ) { /* LDD calls in format : C0xxxxxxxxxx */
        /* Convert C0 to #0 */
        strcpy(output_bno, input_bno);
        *output_bno = '#';
    }
    else if ( !strncmp(input_bno, "00006", 5) && Bno_len == SIZE_PHONENO+3 ) {   /* Voice2U */
        /* Bno = 00006xxxxxxxx ==> Convert to 06xxxxxxxx */
        /* e.g.  0000618162164 ==> Convert to 0618162164 */
        strcpy(output_bno, input_bno+3);   /* skip 000 and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U (10 Digits) - by Kawee on 06-Mar-2006 */
    else if ( !strncmp(input_bno, "00008", 5) && Bno_len == SIZE_PHONENO+3 ) {   /* Voice2U */
        /* Bno = 00008xxxxxxxx ==> Convert to 08xxxxxxxx */
        /* e.g.  0000818162164 ==> Convert to 0818162164 */
        strcpy(output_bno, input_bno+3);   /* skip 000 and then copy */
    }
    else if ( !strncmp(input_bno, "00009", 5) && Bno_len == SIZE_PHONENO+3 ) {   /* Voice2U */
        /* Bno = 00009xxxxxxxx ==> Convert to 09xxxxxxxx */
        /* e.g.  0000918162164 ==> Convert to 0918162164 */
        strcpy(output_bno, input_bno+3);   /* skip 000 and then copy */
    }
    /* Added below Condition to Convert B_no Case Voice2U - by Kawee on 04-Feb-2005 */
    else if ( !strncmp(input_bno, "0000", 4) && Bno_len == SIZE_PHONENO+2 ) {    /* Voice2U */
        /* Bno = 0000xxxxxxxx ==> Convert to 08xxxxxxxx */
        /* e.g.  000018162164 ==> Convert to 0818162164 */
        strcpy(output_bno, "08");      /* profix with 08 */
        strcat(output_bno, input_bno+4);   /* skip 0000 and then copy */
    }
    else if ( !strncmp(input_bno, "BB", 2) || !strncmp(input_bno, "CC", 2) ) {  /* Added by Thanakorn on 17-Jun-2013 */
        strcpy(output_bno, AIN3RDACC_CODE);     /* prefix 00500 */
        strcat(output_bno, input_bno+2);        /* strip CC,BB and copy */
    }
    else if ( *input_bno == 'B' || *input_bno == '*' ) {  /* new GSM VAS access(VAS & VAS+Numbers) */
        strcpy(output_bno, input_bno); /* just copy */
    }
    /* Added below condition - by Kawee on 13-Sep-2005 */
        else if ( !strncmp(input_bno, "66B", 3) || !strncmp(input_bno, "66*", 3) ) {    /* new GSM VAS access(VAS & VAS+Numbers) */
            strcpy(output_bno, input_bno+2);  /* skip 66 and then copy */
        }
    else if ( !strncmp(input_bno, "0B", 2) || !strncmp(input_bno, "0*", 2) ) {    /* new GSM VAS access(VAS & VAS+Numbers) */
        /* No need to convert b_no *xxx, Bxxx or 900xxx to Bxxx, removed below by Kawee on 13-Sep-2005 */
        strcpy(output_bno, input_bno+1);   /* skip 0 and then copy */
    }
    else if ( Is_VasNumber(input_bno) ) {  /* VAS numbers */
        /* No need to convert b_no *xxx, Bxxx or 900xxx to Bxxx, removed below by Kawee on 13-Sep-2005 */
        strcpy(output_bno, input_bno);     /* just copy */
    }
    else if ( Is_ExpressLink (input_bno) ) {    /* Express Link number + pager No. */
        strcpy(output_bno, input_bno);     /* just copy */
    }
    else if ( !strncmp(input_bno, "66190098", 8) ) {   /* Voice message access + GSM No. */
        strcpy(output_bno, input_bno+3);       /* strip 661 */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(input_bno, "001#1166B", 9) ||   /* Vas numbers - Added by Kawee on 03-Nov-2006 */
              !strncmp(input_bno, "001C1166B", 9) ) {  /* Vas numbers - Added by Kawee on 06-Dec-2006 */
        /* No need to convert b_no *xxx, Bxxx or 900xxx, removed below by Kawee on 13-Sep-2005 */
        strcpy(output_bno, input_bno+8);       /* strip 001#1166,001C1166 */
    }
    else if ( !strncmp(input_bno, "00166B", 6) ||       /* Vas numbers - Added by Kawee on 13-Jun-2003 */
              !strncmp(input_bno, "#1166B", 6) ||       /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(input_bno, "C1166B", 6) ) {      /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
        /* No need to convert b_no *xxx, Bxxx or 900xxx, removed below by Kawee on 13-Sep-2005 */
        strcpy(output_bno, input_bno+5);       /* strip 00166,#1166,C1166 */
    }
    else if ( !strncmp(input_bno, "001#11666190098", 15) || !strncmp(input_bno, "001C11666190098", 15) ) {     /* Voice message access + GSM No. */
        strcpy(output_bno, input_bno+10);      /* strip 001#116661,001C116661 */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(input_bno, "001#11668190098", 15) || !strncmp(input_bno, "001C11668190098", 15) ) {     /* Voice message access + GSM No. */
        strcpy(output_bno, input_bno+10);      /* strip 001#116681,001C116681 */
    }
    else if ( !strncmp(input_bno, "001#11669190098", 15) || !strncmp(input_bno, "001C11669190098", 15) ) {     /* Voice message access + GSM No. */
        strcpy(output_bno, input_bno+10);      /* strip 001#116691,001C116691 */
    }
    else if ( !strncmp(input_bno, "001666190098", 12) ||    /* Voice message access + GSM No. */
              !strncmp(input_bno, "#11666190098", 12) ||    /* AIN Phase 1 */
              !strncmp(input_bno, "C11666190098", 12) ) {   /* AIN Phase 1 */
        strcpy(output_bno, input_bno+7);       /* strip 0016661,#116661,C116661 */
    }
    else if ( !strncmp(input_bno, "001668190098", 12) ||    /* Voice message access + GSM No. */
              !strncmp(input_bno, "#11668190098", 12) ||    /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(input_bno, "C11668190098", 12) ) {   /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
        strcpy(output_bno, input_bno+7);       /* strip 0016681,#116681,C116681 */
    }
    else if ( !strncmp(input_bno, "001669190098", 12) ||    /* Voice message access + GSM No. */
              !strncmp(input_bno, "#11669190098", 12) ||    /* Introduced AIN Phase 1 - added by Thanakorn on 23-Mar-2011 */
              !strncmp(input_bno, "C11669190098", 12) ) {   /* Introduced AIN Phase 1 - added by Thanakorn on 23-Mar-2011 */
        strcpy(output_bno, input_bno+7);       /* strip 0016691,#116691,C116691 */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(input_bno, "001#1166190098", 14) || !strncmp(input_bno, "001C1166190098", 14) ) {    /* Voice message access + GSM No. */
        strcpy(output_bno, input_bno+9);       /* strip 001#11661,001C11661 */
    }
    else if ( !strncmp(input_bno, "00166190098", 11) ||     /* Voice message access + GSM No. */
              !strncmp(input_bno, "#1166190098", 11) ||     /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(input_bno, "C1166190098", 11) ) {    /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
        strcpy(output_bno, input_bno+6);        /* strip 001661,#11661,C11661 */
    }
    else if ( (!strncmp(input_bno, "001#116661900", 13) || !strncmp(input_bno, "001C116661900", 13)) &&
              Bno_len < SIZE_PHONENO+4 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+10);       /* strip 001#116661,001C116661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001#116681900", 13) || !strncmp(input_bno, "001C116681900", 13)) &&
              Bno_len < SIZE_PHONENO+4 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+10);       /* strip 001#116681,001C116681 and copy */
    }
    else if ( (!strncmp(input_bno, "001#116691900", 13) || !strncmp(input_bno, "001C116691900", 13)) &&
              Bno_len < SIZE_PHONENO+4) {       /* Intl' VMS access */
        strcpy(output_bno, input_bno+10);       /* strip 001#116691,001C116691 and copy */
    }
    else if ( (!strncmp(input_bno, "0016661900", 10) ||
               !strncmp(input_bno, "#116661900", 10) ||     /* AIN Phase 1 */
               !strncmp(input_bno, "C116661900", 10)) &&    /* AIN Phase 1 */
               Bno_len < SIZE_PHONENO+4 ) {     /* Intl' VMS access */
        strcpy(output_bno, input_bno+7);        /* strip 0016661,#116661,C116661 and copy */
    }
    else if ( (!strncmp(input_bno, "0016681900", 10) ||
               !strncmp(input_bno, "#116681900", 10) ||     /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
               !strncmp(input_bno, "C116681900", 10)) &&    /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
               Bno_len < SIZE_PHONENO+4 ) {     /* Intl' VMS access */
        strcpy(output_bno, input_bno+7);        /* strip 0016681,#116681,C116681 and copy */
    }
    else if ( (!strncmp(input_bno, "0016691900", 10) ||
               !strncmp(input_bno, "#116691900", 10) ||
               !strncmp(input_bno, "C116691900", 10)) &&    /* added by Kawee on 23-Mar-2011 */
              Bno_len < SIZE_PHONENO+4 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+7);        /* strip 0016691,#116691,C116691 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001#11661900", 12) ||
               !strncmp(input_bno, "001C11661900", 12)) &&
              Bno_len < SIZE_PHONENO+6 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+9);        /* strip 001#11661,001C11661 and copy */
    }
    else if ( (!strncmp(input_bno, "001661900", 9) ||
               !strncmp(input_bno, "#11661900", 9) ||
               !strncmp(input_bno, "C11661900", 9)) &&
              Bno_len < SIZE_PHONENO+3 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+6);        /* strip 001661,#11661,C11661 and copy */
    }
    else if ( !strncmp(input_bno, "6661900", 7) && Bno_len < SIZE_PHONENO+1 ) { /* VMS access */
        strcpy(output_bno, input_bno+4);        /* strip 6661 and copy */
    }
    else if ( !strncmp(input_bno, "6681900", 7) && Bno_len < SIZE_PHONENO+1 ) { /* VMS access */
        strcpy(output_bno, input_bno+4);        /* strip 6681 and copy */
    }
    else if ( !strncmp(input_bno, "6691900", 7) && Bno_len < SIZE_PHONENO+1 ) { /* VMS access */
        strcpy(output_bno, input_bno+4);        /* strip 6691 and copy */
    }
    else if ( !strncmp(input_bno, "661900", 6) && Bno_len < SIZE_PHONENO ) {    /* VMS access */
        strcpy(output_bno, input_bno+3);        /* strip 661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001#11900", 9) ||
              !strncmp(input_bno, "001C11900", 9)) &&
              Bno_len < SIZE_PHONENO+3 ) {      /* VMS access - Added by Kawee on 13-Jun-2003 */
        strcpy(output_bno, input_bno+6);        /* strip 001#11,001C11 and copy */
    }
    else if ( (!strncmp(input_bno, "001900", 6) ||
              !strncmp(input_bno, "#11900", 6) ||
              !strncmp(input_bno, "C11900", 6)) &&
              Bno_len < SIZE_PHONENO ) {        /* VMS access - Added by Kawee on 13-Jun-2003 */
        strcpy(output_bno, input_bno+3);       /* strip 001,#11,C11 and copy */
    }

    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    else if ( !strncmp(input_bno, "001#1166", 8) ||
              !strncmp(input_bno, "001C1166", 8) ) {     /* To Mobile or Land Line except Pager etc. */
        if ( input_bno[8] == '8' && Bno_len >= SIZE_PHONENO+7) {
            *output_bno = '0';                  /* prefix 0 */
            strcpy(output_bno+1, input_bno+8); /* strip 001#1166,001C1166 and then copy */
        }
        else if ( !Parse_Area(input_bno+8, area_code) ) { /* Land Line */
            *output_bno = '0';
            strcpy(output_bno+1, input_bno+8); /* strip 001#1166,001C1166 and then copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");          /* prefix 08 */
            strcpy(output_bno+2, input_bno+8); /* strip 001#1166,001C1166 and then copy */
        }
    }
    else if ( !strncmp(input_bno, "00166", 5) ||
              !strncmp(input_bno, "00966", 5) ||
              !strncmp(input_bno, "00766", 5) ||
              !strncmp(input_bno, "00866", 5) ||
              !strncmp(input_bno, "00266", 5) ||        /* To Mobile or Land Line except Pager etc. */
              !strncmp(input_bno, "#1166", 5) ||        /* Introduced AIN Phase 1 - added by Kawee on 03-Nov-2006 */
              !strncmp(input_bno, "C1166", 5) ) {       /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */

        if ( input_bno[5] == '6' && Bno_len >= SIZE_PHONENO+4 ) {
            *output_bno = '0';                          /* prefix 0 */
            strcpy(output_bno+1, input_bno+5);          /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else if ( input_bno[5] == '8' && Bno_len >= SIZE_PHONENO+4 ) {
            *output_bno = '0';                          /* prefix 0 */
            strcpy(output_bno+1, input_bno+5);          /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else if ( input_bno[5] == '9' && Bno_len >= SIZE_PHONENO+4 ) {
            *output_bno = '0';                          /* prefix 0 */
            strcpy(output_bno+1, input_bno+5);          /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else if ( !Parse_Area(input_bno+5, area_code) ) {   /* Land Line */
            *output_bno = '0';
            strcpy(output_bno+1, input_bno+5);          /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");           /* prefix 08 */
            strcpy(output_bno+2, input_bno+5);  /* strip 00166,00966,00766,00866,#1166,C1166 and copy */
        }
    }
    else if ( !strncmp(input_bno, "6621", 4) && Bno_len <= SIZE_PHONENO) {      /* 7th char is 1 ie. 6621 - to Pager etc. */
        strcpy(output_bno, input_bno+3);    /* strip 662 and copy */
    }
    else if ( !strncmp(input_bno, "666", 3) && Bno_len >= SIZE_PHONENO+1 ) {    /* To Mobile */
        /* Remember : TAC numbers can start with 666 */
        *output_bno = '0';                  /* prefix 0 */
        strcpy(output_bno+1, input_bno+2);  /* convert 66 and copy */
    }
    else if ( !strncmp(input_bno, "668", 3) && Bno_len >= SIZE_PHONENO+1 ) {    /* To Mobile */
        /* Remember : TAC numbers can start with 668 */
        *output_bno = '0';                  /* prefix 0 */
        strcpy(output_bno+1, input_bno+2);  /* convert 66 and copy */
    }
    else if ( !strncmp(input_bno, "669", 3) && Bno_len >= SIZE_PHONENO+1 ) {    /* To Mobile */
        /* Remember : TAC numbers can start with 669 */
        *output_bno = '0';                  /* prefix 0 */
        strcpy(output_bno+1, input_bno+2);  /* convert 66 and copy */
    }
    else if ( !strncmp(input_bno, "66", 2) && Bno_len >= SIZE_PHONENO ) {
        /* Call to Mobile or Land Line except Pager etc. */
        /* Remember : TAC numbers can start with 661 */
        if ( !Parse_Area(input_bno, area_code) ) {  /* Land Line */
            *output_bno = '0';
            strcpy(output_bno+1, input_bno+2);      /* strip 66 and copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");               /* prefix 08 */
            strcpy(output_bno+2, input_bno+2);      /* strip 66 and copy */
        }
    }
    else if ( *input_bno == '6' && Bno_len >= SIZE_PHONENO-1 ) {    /* To Mobile start with 6 */
        *output_bno = '0';
        strcpy(output_bno+1, input_bno);        /* prefix 0 and copy */
    }
    /* Added below for 10 Digits - by Kawee on 06-Mar-2006 */
    else if ( *input_bno == '8' && Bno_len >= SIZE_PHONENO-1 ) {    /* To Mobile start with 8 */
        *output_bno = '0';
        strcpy(output_bno+1, input_bno);        /* prefix 0 and copy */
    }
    else if ( *input_bno == '9' && Bno_len >= SIZE_PHONENO-1 ) {    /* To Mobile start with 9 */
        *output_bno = '0';
        strcpy(output_bno+1, input_bno);        /* prefix 0 and copy */
    }
    /* Changed as below by Kawee on 27-Jun-2003 */
    else if ( *input_bno >= '1' && *input_bno <= '9' && Bno_len >= SIZE_PHONENO-2 ) {   /* To Mobile or Land Line */
        if ( strncmp(input_bno, "1175", 4) == 0 ) {         // Addeb by N.Thanakorn on 21-May-2014
            strncpy(output_bno, input_bno, 4);
            output_bno[4] = 0;
        }
        else if ( !Parse_Area(input_bno, area_code) ) {     /* Land Line */
            *output_bno = '0';
            strcpy(output_bno+1, input_bno);                /* prefix 0 and copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");                       /* prefix 08 */
            strcpy(output_bno+2, input_bno);                /* prefix 0 and copy */
        }
    }
    else if ( Bno_len < 5 && *input_bno == '1' ) {          /* Should be Abbreviated TOT Numbers (5-Jul-2001) */
        strcpy(output_bno, input_bno);                      /* just copy */
    }
    else if ( (!strncmp(input_bno, "001#1106", 8) ||
              !strncmp(input_bno, "001C1106", 8)) &&
              input_bno[8] >= '1' && input_bno[8] <= '9' &&
              Bno_len >= SIZE_PHONENO+6 ) {     /* To Mobile */
        strcpy(output_bno, input_bno+6);        /* strip 001#11 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    else if ( (!strncmp(input_bno, "001#1108", 8) ||
              !strncmp(input_bno, "001C1108", 8)) &&
              input_bno[8] >= '1' && input_bno[8] <= '9' &&
              Bno_len >= SIZE_PHONENO+6 ) {     /* To Mobile */
        strcpy(output_bno, input_bno+6);        /* strip 001#11 and copy */
    }
    else if ( (!strncmp(input_bno, "001#1109", 8) ||
              !strncmp(input_bno, "001C1109", 8)) &&
              input_bno[8] >= '1' && input_bno[8] <= '9' &&
              Bno_len >= SIZE_PHONENO+6 ) {     /* To Mobile */
        strcpy(output_bno, input_bno+6);        /* strip 001#11 and copy */
    }
    else if ( (!strncmp(input_bno, "00106", 5) ||
              !strncmp(input_bno, "#1106", 5) ||   /* AIN Phase 1 */
              !strncmp(input_bno, "C1106", 5)) &&  /* AIN Phase 1 */
              input_bno[5] >= '1' && input_bno[5] <= '9' &&
              Bno_len >= SIZE_PHONENO+3 ) {         /* To Mobile */
        strcpy(output_bno, input_bno+3);            /* strip 001,#11,C11 and copy */
    }
    else if ( (!strncmp(input_bno, "00108", 5) ||
              !strncmp(input_bno, "#1108", 5) ||   /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(input_bno, "C1108", 5)) &&  /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
              input_bno[5] >= '1' && input_bno[5] <= '9' &&
              Bno_len >= SIZE_PHONENO+3 ) {         /* To Mobile */
        strcpy(output_bno, input_bno+3);            /* strip 001,#11,C11 and copy */
    }
    else if ( (!strncmp(input_bno, "00109", 5) ||
              !strncmp(input_bno, "#1109", 5) ||
              !strncmp(input_bno, "C1109", 5)) &&   /* added by Thanakorn on 23-Mar-2011 */
              input_bno[5] >= '1' && input_bno[5] <= '9' &&
              Bno_len >= SIZE_PHONENO+3 ) {         /* To Mobile */
        strcpy(output_bno, input_bno+3);            /* strip 001,#11,C11 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    else if ( (!strncmp(input_bno, "001#110", 7) ||
              !strncmp(input_bno, "001C110", 7)) &&
              input_bno[7] >= '1' && input_bno[7] <= '9' ) {
        if ( !Parse_Area(input_bno+6, area_code) ) {    /* Land Line */
            strcpy(output_bno, input_bno+6);            /* strip 001#11,001C11 and copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");                   /* prefix 08 */
            strcat(output_bno, input_bno+7);            /* strip 001#110,001C110 and copy */
        }
    }
    else if ( (!strncmp(input_bno, "0010", 4) ||
              !strncmp(input_bno, "#110", 4) ||         /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(input_bno, "C110", 4)) &&        /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
         input_bno[4] >= '1' && input_bno[4] <= '9') {
        if ( !Parse_Area(input_bno+3, area_code) ) {    /* Land Line */
            strcpy(output_bno, input_bno+3);            /* strip 001,#11,C11 and copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");                   /* prefix 08 */
            strcat(output_bno, input_bno+4);            /* strip 0010,#110,C11 and copy */
        }
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    else if ( !strncmp(input_bno, "001#11", 6) ||
              !strncmp(input_bno, "001C11", 6) ) {
/* Changed real version to interrim version as below - by Kawee on 20-Feb-2007 */
#ifdef  CONV_BNO_C11_TO_005
        if ( glb_MtxInd == AWN_TYPE ) {             /* add by Thanakorn on 26-May-2015 */
            strcpy(output_bno, AWNIDDACC_COD1);     /* prefix 003 */
            strcat(output_bno, input_bno+6);        /* strip 001#11,001C11 and copy */
        }
        else {
            strcpy(output_bno, AINIDDACC_CODE);     /* prefix 005 */
            strcat(output_bno, input_bno+6);        /* strip 001#11,001C11 and copy */
        }
#else
        strcpy(output_bno, IDDACC_CODE);        /* prefix 001 */
        strcat(output_bno, input_bno+6);        /* strip 001#11,001C11 and copy */
#endif
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    else if ( !strncmp(input_bno, "#11", 3) ||
              !strncmp(input_bno, "C11", 3) ) {
/* Changed real version to interrim version as below - by Kawee on 20-Feb-2007 */
#ifdef  CONV_BNO_C11_TO_005
        if ( glb_MtxInd == AWN_TYPE ) {             /* add by Thanakorn on 26-May-2015 */
            strcpy(output_bno, AWNIDDACC_COD1);     /* prefix 003 */
            strcat(output_bno, input_bno+3);        /* strip #11,C11 and copy */
        }
        else {
            strcpy(output_bno, AINIDDACC_CODE);     /* prefix 005 */
            strcat(output_bno, input_bno+3);        /* strip #11,C11 and copy */
        }
#else
        strcpy(output_bno, IDDACC_CODE);        /* prefix 001 */
        strcat(output_bno, input_bno+3);        /* strip #11,C11 and copy */
#endif
    }
    /* End - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */
    else if ( *input_bno == 'C' ) {     /* changed by thanakorn on 29-Apr-2013 */
        sprintf(output_bno, "900%s", input_bno+1);
    }
    else if ( !strncmp(input_bno, AIN3RDACC_CODE, AIN3RDACC_LEN) ||         // 00500
              !strncmp(input_bno, AWNIDDACC_COD3, AIN3RDACC_LEN) ) {        // 00300
        if ( !strncmp(input_bno+AIN3RDACC_LEN, "66", 2) ) {
            strcpy(output_bno, "0");
            strcat(output_bno, input_bno+AIN3RDACC_LEN+2);
        }
// printf("input_bno(%d)'%s'\n", strlen(input_bno), input_bno);
    }
    else if ( !strncmp(input_bno, AIN2NDACC_CODE, AIN2NDACC_LEN) ||         // 0050
              !strncmp(input_bno, AWNIDDACC_COD2, AIN2NDACC_LEN) ) {        // 0030
        if ( !strncmp(input_bno+AIN2NDACC_LEN, "66", 2) ) {
            strcpy(output_bno, "0");
            strcat(output_bno, input_bno+AIN2NDACC_LEN+2);
        }
// printf("input_bno(%d)'%s'\n", strlen(input_bno), input_bno);
    }
    else if ( !strncmp(input_bno, IDDACC_CODE, IDDACC_LEN) ||           // 001
              !strncmp(input_bno, EPHACC_CODE, EPHACC_LEN) ||           // 009
              !strncmp(input_bno, TOTIDDACC_CODE, TOTIDDACC_LEN) ||     // 007
              !strncmp(input_bno, TOTVOIPACC_CODE, TOTVOIPACC_LEN) ||   // 008   = TOT VOIP Intl' Calls
              !strncmp(input_bno, TOTMALAYACC_CODE, TOTMALAYACC_LEN) || // 002   = TOT VOIP Malay Intl' Calls
              !strncmp(input_bno, AINIDDACC_CODE, AINIDDACC_LEN) ||     // 005
              !strncmp(input_bno, AWNIDDACC_COD1, AINIDDACC_LEN) ) {    // 003
        if ( !strncmp(input_bno+IDDACC_LEN, "66", 2) ) {
            strcpy(output_bno, "0");
            strcat(output_bno, input_bno+IDDACC_LEN+2);
        }
// printf("input_bno(%d)'%s'\n", strlen(input_bno), input_bno);
    }
    else {  /* others */
        strcpy(output_bno, input_bno); /* copy complete */
// printf("else case in:'%s', out:'%s'\n", input_bno, output_bno);
    }

    strcpy(input_bno, buffer); /* Added for fixed B_no that append the routing address - by Kawee on 06-Jun-2003 */

    return SUCCESS;
}

int Conv_CommonSms_Bno(char *input_bno, char *output_bno)
{
    char buffer[30];                /* Added for fixed B_no that append the routing address - by Kawee on 06-Jun-2003 */
    char szTmp[30];                 /* Added for fixed B_no for 1 Sim 2 Number - by Kawee on 18-Apr-2008 */
    int Bno_len = strlen(input_bno);
    char area_code[SIZE_NDD+1];     /* Added for check area code of 10 Digit Phone Number format - by Kawee on 27-Mar-2006 */

    /* Fixed B_no that prefix with 200 (1 SIM 2 Number Prefix) as below - by Kawee 18-Apr-2008 */
    strcpy(buffer, input_bno);
    if ( Bno_len > 3 && !strncmp(input_bno,"200",3) ) {
        strcpy(szTmp, input_bno+3);         /* Skip 200 and then Copy */
        strcpy(input_bno, szTmp);
        Bno_len = Bno_len - 3;
    }

    /* map b_no */
    if ( !strncmp(input_bno, "061900900", 9) && Bno_len >= SIZE_PHONENO+2 ) {   /* VMS access */
        /* e.g. 061900900121 -> convert to 900121 */
        strcpy(output_bno, input_bno+6);    /* strip 061900 and copy */
    }
    else if ( !strncmp(input_bno, "081900900", 9) && Bno_len >= SIZE_PHONENO+2 ) {   /* VMS access - Added by Kawee on 23-Dec-2003 */
        /* e.g. 081900900121 -> convert to 900121 */
        strcpy(output_bno, input_bno+6);    /* strip 081900 and copy */
    }
    else if ( !strncmp(input_bno, "091900900", 9) && Bno_len >= SIZE_PHONENO+2 ) {  /* VMS access - Added by Thanakorn on 23-Mar-2011 */
        /* e.g. 091900900121 -> convert to 900121 */
        strcpy(output_bno, input_bno+6);    /* strip 091900 and copy */
    }
    else if ( !strncmp(input_bno, "01900900", 8) && Bno_len >= SIZE_PHONENO+1 ) {   /* VMS access - Added by Kawee on 23-Dec-2003 */
        /* e.g. 01900900121 -> convert to 900121 */
        strcpy(output_bno, input_bno+5);    /* strip 01900 and copy */
    }
    else if ( !strncmp(input_bno, "061900", 6) && Bno_len < SIZE_PHONENO ) {    /* VMS access */
        strcpy(output_bno, input_bno+3);    /* strip 061 and copy */
    }
    else if ( !strncmp(input_bno, "081900", 6) && Bno_len < SIZE_PHONENO ) {    /* VMS access - Added by Kawee on 22-Jul-2003 */
        strcpy(output_bno, input_bno+3);    /* strip 081 and copy */
    }
    else if ( !strncmp(input_bno, "091900", 6) && Bno_len < SIZE_PHONENO ) {    /* VMS access - Added by Thanakorn on 23-Mar-2011 */
        strcpy(output_bno, input_bno+3);    /* strip 091 and copy */
    }
    else if ( !strncmp(input_bno, "01900", 5) && Bno_len < SIZE_PHONENO-1 ) {   /* VMS access - Added by Kawee on 22-Jul-2003 */
        strcpy(output_bno, input_bno+2);    /* strip 01 and copy */
    }
    else if ( !strncmp(input_bno, "BB", 2) || !strncmp(input_bno, "CC", 2) ) {  /* Added by Thanakorn on 17-Jun-2013 */
        strcpy(output_bno, AIN3RDACC_CODE);                 /* prefix 00500 */
        strcat(output_bno, input_bno+2);                    /* strip CC,BB and copy */
    }
    else if ( *input_bno == 'B' || *input_bno == '*' ) {    /* new GSM VAS access(VAS & VAS+Numbers) */
        strcpy(output_bno, "900");
        strcat(output_bno, input_bno+1);                    /* convert B,* to 900 and then copy */
    }
    /* Added below condition - by Kawee on 13-Sep-2005 */
    else if ( !strncmp(input_bno, "66B", 3) ||
              !strncmp(input_bno, "66*", 3) ) {             /* new GSM VAS access(VAS & VAS+Numbers) */
        strcpy(output_bno, "900");
        strcat(output_bno, input_bno+3);                    /* skip 66 then convert B or * to 900 and then copy */
    }
    else if ( !strncmp(input_bno, "0B", 2) ||
         !strncmp(input_bno, "0*", 2) ) {                   /* new GSM VAS access(VAS & VAS+Numbers) */
        strcpy(output_bno, "900");
        strcat(output_bno, input_bno+2);                    /* skip 0 then convert B or * to 900 and then copy */
    }
    else if ( !strncmp(input_bno, "66190098", 8) ) {        /* Voice message access + GSM No. */
         strcpy(output_bno, input_bno+3);                   /* strip 661 */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(input_bno, "001#1166B", 9) ||
              !strncmp(input_bno, "001C1166B", 9) ) {   /* Voice message access + GSM No. */
        strcpy(output_bno, "900");
        strcat(output_bno, input_bno+9);            /* convert 001#1166B,001C1166B to 900 and then copy */
    }
    else if ( !strncmp(input_bno, "00166B", 6) ||   /* Voice message access + GSM No. */
              !strncmp(input_bno, "#1166B", 6) ||   /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(input_bno, "C1166B", 6) ) {  /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
        strcpy(output_bno, "900");
        strcat(output_bno, input_bno+6);            /* convert 00166B,#1166B,C1166B to 900 and then copy */
    }
    else if ( (!strncmp(input_bno, "001#116661900", 13) ||
              !strncmp(input_bno, "001C116661900", 13)) &&
              Bno_len < SIZE_PHONENO+7 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+10);       /* strip 001#116661,001C116661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001#116681900", 13) ||
              !strncmp(input_bno, "001C116681900", 13)) &&
              Bno_len < SIZE_PHONENO+7 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+10);       /* strip 001#116681,001C116681 and copy */
    }
    else if ( (!strncmp(input_bno, "001#116691900", 13) ||
              !strncmp(input_bno, "001C116691900", 13)) &&
              Bno_len < SIZE_PHONENO+7 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+10);       /* strip 001#116691,001C116691 and copy */
    }
    else if ( (!strncmp(input_bno, "0016661900", 10) ||
              !strncmp(input_bno, "#116661900", 10) ||
              !strncmp(input_bno, "C116661900", 10)) &&
              Bno_len < SIZE_PHONENO+4 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+7);        /* strip 0016661,#116661,C116661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "0016681900", 10) ||
              !strncmp(input_bno, "#116681900", 10) ||
              !strncmp(input_bno, "C116681900", 10)) &&
              Bno_len < SIZE_PHONENO+4 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+7);        /* strip 0016681,#116681,C116681 and copy */
    }
    else if ( (!strncmp(input_bno, "0016691900", 10) ||
              !strncmp(input_bno, "#116691900", 10) ||
              !strncmp(input_bno, "C116691900", 10)) &&
              Bno_len < SIZE_PHONENO+4 ) {        /* Intl' VMS access */
        strcpy(output_bno, input_bno+7);        /* strip 0016691,#116691,C116691 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001#11661900", 12) ||
              !strncmp(input_bno, "001C11661900", 12)) &&
              Bno_len < SIZE_PHONENO+6 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+9);        /* strip 001#11661,001C11661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001661900", 9) ||
              !strncmp(input_bno, "#11661900", 9) ||
              !strncmp(input_bno, "C11661900", 9)) &&
              Bno_len < SIZE_PHONENO+3 ) {      /* Intl' VMS access */
        strcpy(output_bno, input_bno+6);        /* strip 001661,#11661,C11661 and copy */
    }
    else if ( !strncmp(input_bno, "6661900", 6) && Bno_len < SIZE_PHONENO+1 ) {  /* VMS access */
        strcpy(output_bno, input_bno+4);        /* strip 6661 and copy */
    }
    else if ( !strncmp(input_bno, "6681900", 6) && Bno_len < SIZE_PHONENO+1 ) {  /* VMS access */
        strcpy(output_bno, input_bno+4);        /* strip 6681 and copy */
    }
    else if ( !strncmp(input_bno, "6691900", 6) && Bno_len < SIZE_PHONENO+1 ) {  /* VMS access */
        strcpy(output_bno, input_bno+4);        /* strip 6691 and copy */
    }
    else if ( !strncmp(input_bno, "661900", 6) && Bno_len < SIZE_PHONENO ) { /* VMS access */
        strcpy(output_bno, input_bno+3);        /* strip 661 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001#11900", 9) ||
              !strncmp(input_bno, "001C11900", 9)) &&
              Bno_len < SIZE_PHONENO+3 ) {      /* VMS access - Added by Kawee on 13-Jun-2003 */
        strcpy(output_bno, input_bno+6);        /* strip 001#11,001C11 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001900", 6) ||
              !strncmp(input_bno, "#11900", 6) ||
              !strncmp(input_bno, "C11900", 6)) &&
              Bno_len < SIZE_PHONENO ) {        /* VMS access - Added by Kawee on 13-Jun-2003 */
        strcpy(output_bno, input_bno+3);        /* strip 001,#11,C11 and copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001#1166", 8) ||
              !strncmp(input_bno, "001C1166", 8)) &&
              input_bno[8] >= '1' && input_bno[8] <= '9' ) {    /* Mobile to Mobile */
        if ( input_bno[8] == '8' && Bno_len >= SIZE_PHONENO+7 ) {
            *output_bno = '0';                  /* prefix 0 */
            strcpy(output_bno+1, input_bno+8);  /* strip 001#1166,001C1166 and then copy */
        }
        else if ( !Parse_Area(input_bno+8, area_code) ) {   /* Land Line */
            *output_bno = '0';
            strcpy(output_bno+1, input_bno+8);      /* strip 001#1166,001C1166 and then copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");               /* prefix 08 */
            strcpy(output_bno+2, input_bno+8);      /* strip 001#1166,001C1166 and then copy */
        }
    }
    else if ( (!strncmp(input_bno, "00166", 5) ||
              !strncmp(input_bno, "00966", 5) ||
              !strncmp(input_bno, "00766", 5) ||
              !strncmp(input_bno, "00866", 5) ||
              !strncmp(input_bno, "00266", 5) ||
              !strncmp(input_bno, "#1166", 5) ||                /* Introduced AIN Phase 1 - added by Kawee on 03-Nov-2006 */
              !strncmp(input_bno, "C1166", 5) ) &&              /* Introduced AIN Phase 1 - added by Kawee on 06-Dec-2006 */
              input_bno[5] >= '1' && input_bno[5] <= '9' ) {    /* Mobile to Mobile */

        if ( input_bno[5] == '6' && Bno_len >= SIZE_PHONENO+4 ) {
            *output_bno = '0';                      /* prefix 0 */
            strcpy(output_bno+1, input_bno+5);      /* strip 00166,00966,00766,00866,#1166,C1166 and then copy */
        }
        else if ( input_bno[5] == '8' && Bno_len >= SIZE_PHONENO+4 ) {
            *output_bno = '0';                      /* prefix 0 */
            strcpy(output_bno+1, input_bno+5);      /* strip 00166,00966,00766,00866,#1166,C1166 and then copy */
        }
        else if ( input_bno[5] == '9' && Bno_len >= SIZE_PHONENO+4) {
            *output_bno = '0';                      /* prefix 0 */
            strcpy(output_bno+1, input_bno+5);      /* strip 00166,00966,00766,00866,#1166,C1166 and then copy */
        }
        else if ( !Parse_Area(input_bno+5, area_code) ) {   /* Land Line */
            *output_bno = '0';
            strcpy(output_bno+1, input_bno+5);      /* strip 00166,00966,00766,00866,#1166,C1166 and then copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");               /* prefix 08 */
            strcpy(output_bno+2, input_bno+5);      /* strip 00166,00966,00766,00866,#1166,C1166 and then copy */
        }
    }
    else if ( !strncmp(input_bno, "777706", 6) && Bno_len >= SIZE_PHONENO+4 ) {          /* Service on Demand */
        strcpy(output_bno, input_bno+4);                /* skip 7777 and copy */
    }
    /* Added Service on Demand (call prefixed with 777708) - by Kawee on 15-Sep-2005 */
    else if ( !strncmp(input_bno, "777708", 6) && Bno_len >= SIZE_PHONENO+4 ) {          /* Service on Demand */
        strcpy(output_bno, input_bno+4);                /* skip 7777 and copy */
    }
    else if ( !strncmp(input_bno, "777709", 6) && Bno_len >= SIZE_PHONENO+4 ) {          /* Service on Demand */
        strcpy(output_bno, input_bno+4);                /* skip 7777 and copy */
    }
    else if ( !strncmp(input_bno, "77770", 5) ) {       /* Service on Demand */
        if ( !Parse_Area(input_bno+4, area_code) ) {    /* Land Line */
            strcpy(output_bno, input_bno+4);            /* skip 7777 and copy */
        }
        else {
            strcpy(output_bno, "08");           /* prefix 08 */
            strcat(output_bno, input_bno+5);    /* skip 77770 and copy */
        }
    }
    else if ( !strncmp(input_bno, "666", 3) && Bno_len >= SIZE_PHONENO+1 ) {    /* To Mobile */
        /* Remember : TAC numbers can start with 666 */
        *output_bno = '0';                  /* prefix 0 */
        strcpy(output_bno+1, input_bno+2);  /* convert 66 and copy */
    }
    else if ( !strncmp(input_bno, "668", 3) && Bno_len >= SIZE_PHONENO+1 ) {    /* To Mobile */
        /* Remember : TAC numbers can start with 661 */
        *output_bno = '0';                  /* prefix 0 */
        strcpy(output_bno+1, input_bno+2);  /* convert 66 and copy */
    }
    else if ( !strncmp(input_bno, "669", 3) && Bno_len >= SIZE_PHONENO+1 ) {    /* To Mobile */
        /* Remember : TAC numbers can start with 661 */
        *output_bno = '0';                  /* prefix 0 */
        strcpy(output_bno+1, input_bno+2);  /* convert 66 and copy */
    }
    else if ( !strncmp(input_bno, "66", 2) && Bno_len >= SIZE_PHONENO ) {
        /* Call to Mobile or Land Line except Pager etc. */
        /* Remember : TAC numbers can start with 661 */
        if ( !Parse_Area(input_bno, area_code) ) {  /* Land Line */
            *output_bno = '0';
            strcpy(output_bno+1, input_bno+2);  /* strip 66 and copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");           /* prefix 08 */
            strcpy(output_bno+2, input_bno+2);  /* strip 66 and copy */
        }
    }
    else if ( !strncmp(input_bno, "06", 2) && Bno_len >= SIZE_PHONENO ) {
        /* to Mobile or Land Line with 06 already prefixed (10 digits Number) */
        strcpy(output_bno, input_bno);          /* just copy */
    }
    else if ( !strncmp(input_bno, "08", 2) && Bno_len >= SIZE_PHONENO ) {
        /* to Mobile or Land Line with 08 already prefixed (10 digits Number) */
        strcpy(output_bno, input_bno);          /* just copy */
    }
    else if ( !strncmp(input_bno, "09", 2) && Bno_len >= SIZE_PHONENO ) {
        /* to Mobile or Land Line with 09 already prefixed (10 digits Number) */
        strcpy(output_bno, input_bno);          /* just copy */
    }
    else if ( (*input_bno == '0') && !Parse_Area(input_bno, area_code) &&
              (Bno_len < SIZE_PHONENO-1 ||      /* Mobile to Abbreviated TOT numbers with NDD dialed */
              (!strncmp(input_bno+strlen(area_code), "1900", 4) && Bno_len > SIZE_PHONENO-1)) ) {   /* Area Code + 1900xxxx */
        /*
        ** Call to Abbreviated TOT numbers with NDD dialed, B_no can be 021150,02191,053191,0531150
        ** this number would be convert to 1150, 191
        **
        ** Call to TOT Premium Call, B_no can be 0531900xxxxx, 021900xxxxxx
        ** this number would be convert to 1900xxxxxx
        ** - Kawee on 29-Oct-2003
        */
        strcpy(output_bno, input_bno + strlen(area_code));  /* strip area code and copy */
    }
    /* Fixed New Prefix Number of Mobile Phone Problem - Changed as below by Kawee on 13-Jun-2003 */
    /* Start - Fixed New Prefix Number of Mobile Phone Problem - by Kawee on 13-Jun-2003 */
    /* Changed as below by Kawee on 27-Jun-2003 */
    else if ( *input_bno == '0' && input_bno[1] >= '1' && input_bno[1] <= '9' &&
              Bno_len >= SIZE_PHONENO-1 ) {         /* to Mobile or Land Line already prefixed */
        if ( !Parse_Area(input_bno, area_code) ) {  /* Land Line */
            strcpy(output_bno, input_bno);          /* just copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");               /* prefix 08 */
            strcat(output_bno+2, input_bno+1);      /* just copy */
        }
    }
    else if ( *input_bno == '6' && Bno_len >= SIZE_PHONENO-1 ) {    /* To Mobile start with 6 */
        *output_bno = '0';
        strcpy(output_bno+1, input_bno);        /* prefix 0 and copy */
    }
    /* Added below for 10 Digits - by Kawee on 06-Mar-2006 */
    else if ( *input_bno == '8' && Bno_len >= SIZE_PHONENO-1 ) {    /* To Mobile start with 8 */
        *output_bno = '0';
        strcpy(output_bno+1, input_bno);        /* prefix 0 and copy */
    }
    else if ( *input_bno == '9' && Bno_len >= SIZE_PHONENO-1 ) { /* To Mobile start with 9 */
        *output_bno = '0';
        strcpy(output_bno+1, input_bno);        /* prefix 0 and copy */
    }
    /* Changed as below by Kawee on 27-Jun-2003 */
    else if ( *input_bno >= '1' && *input_bno <= '9' && Bno_len >= SIZE_PHONENO-2 ) {   /* To Mobile or Land Line */
        if ( !Parse_Area(input_bno, area_code) ) {    /* Land Line */
            *output_bno = '0';
            strcpy(output_bno+1, input_bno);    /* prefix 0 and copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");           /* prefix 08 */
            strcpy(output_bno+2, input_bno);    /* prefix 0 and copy */
        }
    }
    else if ( (!strncmp(input_bno, "001#1106", 8) ||
              !strncmp(input_bno, "001C1106", 8)) &&
              input_bno[8] >= '1' && input_bno[8] <= '9' &&
              Bno_len >= SIZE_PHONENO+6 ) {     /* Mobile to Mobile */
        strcpy(output_bno, input_bno+6);        /* strip 001#11,001C11 and then copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001#1108", 8) ||
              !strncmp(input_bno, "001C1108", 8)) &&
              input_bno[8] >= '1' && input_bno[8] <= '9' &&
              Bno_len >= SIZE_PHONENO+6 ) {     /* Mobile to Mobile */
        strcpy(output_bno, input_bno+6);        /* strip 001#11,001C11 and then copy */
    }
    else if ( (!strncmp(input_bno, "001#1109", 8) ||
              !strncmp(input_bno, "001C1109", 8)) &&
              input_bno[8] >= '1' && input_bno[8] <= '9' &&
              Bno_len >= SIZE_PHONENO+6 ) {     /* Mobile to Mobile */
        strcpy(output_bno, input_bno+6);        /* strip 001#11,001C11 and then copy */
    }
    else if ( (!strncmp(input_bno, "00106", 5) ||
              !strncmp(input_bno, "#1106", 5) ||        /* AIN Phase 1 */
              !strncmp(input_bno, "C1106", 5)) &&       /* AIN Phase 1 */
              input_bno[5] >= '1' && input_bno[5] <= '9' &&
              Bno_len >= SIZE_PHONENO+3 ) {     /* Mobile to Mobile */
        strcpy(output_bno, input_bno+3);        /* strip 001,#11,C11 and then copy */
    }
    else if ( (!strncmp(input_bno, "00108", 5) ||
              !strncmp(input_bno, "#1108", 5) ||        /* Introduced AIN Phase 1 - by Kawee on 15-Nov-2006 */
              !strncmp(input_bno, "C1108", 5)) &&       /* Introduced AIN Phase 1 - by Kawee on 06-Dec-2006 */
              input_bno[5] >= '1' && input_bno[5] <= '9' &&
              Bno_len >= SIZE_PHONENO+3 ) {     /* Mobile to Mobile */
        strcpy(output_bno, input_bno+3);        /* strip 001,#11,C11 and then copy */
    }
    else if ( (!strncmp(input_bno, "00109", 5) ||
              !strncmp(input_bno, "#1109", 5) ||        /* Introduced AIN Phase 1 - by Thanakorn on 23-Mar-2011 */
              !strncmp(input_bno, "C1109", 5)) &&       /* Introduced AIN Phase 1 - by Thanakorn on 23-Mar-2011 */
              input_bno[5] >= '1' && input_bno[5] <= '9' &&
              Bno_len >= SIZE_PHONENO+3 ) {     /* Mobile to Mobile */
        strcpy(output_bno, input_bno+3);        /* strip 001,#11,C11 and then copy */
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( (!strncmp(input_bno, "001#110", 7) ||
              !strncmp(input_bno, "001C110", 7)) &&
              input_bno[7] >= '1' && input_bno[7] <= '9' ) {
        if ( !Parse_Area(input_bno+6, area_code) ) {    /* Land Line */
            strcpy(output_bno, input_bno+6);    /* strip 001#11,001C11 and copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");           /* prefix 08 */
            strcat(output_bno, input_bno+7);    /* strip 001#110,001C110 and copy */
        }
    }
    else if ( (!strncmp(input_bno, "0010", 4) ||
              !strncmp(input_bno, "#110", 4) ||         /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              !strncmp(input_bno, "C110", 4)) &&        /* Introduced AIN Phase 1 - added by Kawee on 15-Nov-2006 */
              input_bno[4] >= '1' && input_bno[4] <= '9' ) {
        if ( !Parse_Area(input_bno+3, area_code) ) {    /* Land Line */
            strcpy(output_bno, input_bno+3);    /* strip 001,#11,C11 and copy */
        }
        else {  /* Mobile Number */
            strcpy(output_bno, "08");           /* prefix 08 */
            strcat(output_bno, input_bno+4);    /* strip 0010,#110,C110 and copy */
        }
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 03-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(input_bno, "001#11", 6) ||
              !strncmp(input_bno, "001C11", 6) ) {
/* Changed real version to interrim version as below - by Kawee on 20-Feb-2007 */
/* Changed interrim version to real version as above - by Kawee on 07-Feb-2007 */
#ifdef  CONV_BNO_C11_TO_005
        strcpy(output_bno, AINIDDACC_CODE);     /* prefix 005 */
        strcpy(output_bno+3, input_bno+6);      /* strip 001#11,001C11 and then copy */
#else
        strcpy(output_bno, IDDACC_CODE);        /* prefix 001 */
        strcpy(output_bno+3, input_bno+6);      /* strip 001#11,001C11 and then copy */
#endif
    }
    /* Introduced AIN Phase 1 as below - by Kawee on 15-Nov-2006 */
    /* Added AIN Number 001C11 and C11 as below - by Kawee on 06-Dec-2006 */
    else if ( !strncmp(input_bno, "#11", 3) ||
              !strncmp(input_bno, "C11", 3) ) {
/* Changed real version to interrim version as below - by Kawee on 20-Feb-2007 */
/* Changed interrim version to real version as above - by Kawee on 07-Feb-2007 */
#ifdef  CONV_BNO_C11_TO_005
        strcpy(output_bno, AINIDDACC_CODE);     /* prefix 005 */
        strcpy(output_bno+3, input_bno+3);      /* strip #11,C11 and then copy */
#else
        strcpy(output_bno, IDDACC_CODE);        /* prefix 001 */
        strcpy(output_bno+3, input_bno+3);      /* strip #11,C11 and then copy */
#endif
    }
    else {  /* others - we assume 90xxxx numbers or SMS report to Intl' mobile phones */
        strcpy(output_bno, input_bno);          /* copy complete */
    }

    strcpy(input_bno, buffer);
    return SUCCESS;
}


void Conv_RealBno(const char *in_bno, char *out_bno)
{
    // Please note that: This function should be use only after other
    // convert bno function is called as this function is intended to remove only access code/dialed digit.

    strcpy(out_bno, in_bno);

    if ( !strncmp(in_bno, "00", 2) ) {
        if ( !strncmp(in_bno+3, "00", 2) ) {
            //strcpy(out_bno, in_bno+4);              // input = 00X00nnnnnnnnn.. then output -> 0nnnnnnnnn..
            strcpy(out_bno, in_bno+5);              // input = 00X00nnnnnnnnn.. then output -> nnnnnnnnn..
        }
        else if ( *(in_bno+3) == '0' ) {
            //strcpy(out_bno, in_bno+3);              // input = 00X0nnnnnnnnn.. then output -> 0nnnnnnnnn..
            strcpy(out_bno, in_bno+4);              // input = 00X0nnnnnnnnn.. then output -> nnnnnnnnn.
        }
        else {
            //sprintf(out_bno, "0%s", in_bno+3);      // input = 00Xnnnnnnnnn.. then output -> 0nnnnnnnnnn..
            strcpy(out_bno, in_bno+3);      // input = 00Xnnnnnnnnn.. then output -> nnnnnnnnnn..
        }
    }

}

int Is_ExpressLink (char *buff)
{
    /* Express Link to ...... followed by Pager No. */

    if ( !strncmp(buff, "900151", 6) || !strncmp(buff, "B151", 4) || !strncmp(buff, "*151", 4) ||     /* Phonelink */
        !strncmp(buff, "900161", 6) || !strncmp(buff, "B161", 4) || !strncmp(buff, "*161", 4) ||     /* Hachitson */
        !strncmp(buff, "9001143", 7) || !strncmp(buff, "B1143", 5) || !strncmp(buff, "*1143", 5) ||  /* Paclink */
        !strncmp(buff, "9001501", 7) || !strncmp(buff, "B1501", 5) || !strncmp(buff, "*1501", 5) ||  /* Easycall */
        !strncmp(buff, "9001187", 7) || !strncmp(buff, "B1187", 5) || !strncmp(buff, "*1187", 5))    /* Posttel */
        return TRUE;
    else
        return FALSE;
}

int Is_VasNumber (char *buff)
{
    if ( !strncmp(buff, "T99", 3) ||    /* Voice mail Recording */
        !strncmp(buff, "90013", 5) || !strncmp(buff, "B13", 3) || !strncmp(buff, "*13", 3) || /* Easy 13 */
        !strncmp(buff, "90017", 5) || !strncmp(buff, "B17", 3) || !strncmp(buff, "*17", 3) || /* AIS Local Service Line */
        !strncmp(buff, "90096", 5) || !strncmp(buff, "B96", 3) || !strncmp(buff, "*96", 3) || /* Voice Bill Info */
        !strncmp(buff, "90097", 5) || !strncmp(buff, "B97", 3) || !strncmp(buff, "*97", 3) || /* Voice Info */
        !strncmp(buff, "90098", 5) || !strncmp(buff, "B98", 3) || !strncmp(buff, "*98", 3) || /* Voice msg to GSM Phone */
        !strncmp(buff, "90099", 5) || !strncmp(buff, "B99", 3) || !strncmp(buff, "*99", 3) || /* Voice Mail */
        !strncmp(buff, "900100", 6) || !strncmp(buff, "B100", 4) || !strncmp(buff, "*100", 4) || /* IVR */
        !strncmp(buff, "900110", 6) || !strncmp(buff, "B110", 4) || !strncmp(buff, "*110", 4) || /* Football Answering */
        !strncmp(buff, "900111", 6) || !strncmp(buff, "B111", 4) || !strncmp(buff, "*111", 4) || /* Minute Plus */
        !strncmp(buff, "900119", 6) || !strncmp(buff, "B119", 4) || !strncmp(buff, "*119", 4) || /* Web Setting (OTA) */
        !strncmp(buff, "900123", 6) || !strncmp(buff, "B123", 4) || !strncmp(buff, "*123", 4) || /* Entertainment */
        !strncmp(buff, "900129", 6) || !strncmp(buff, "B129", 4) || !strncmp(buff, "*129", 4) || /* Prepaid Voice Mail */ /* Added by Kawee on 17-Jan-2003 */
        !strncmp(buff, "900180", 6) || !strncmp(buff, "B180", 4) || !strncmp(buff, "*180", 4) || /* Cancel SMS Premiership */
        !strncmp(buff, "900181", 6) || !strncmp(buff, "B181", 4) || !strncmp(buff, "*181", 4) || /* SMS Premiership Update */
        !strncmp(buff, "900182", 6) || !strncmp(buff, "B182", 4) || !strncmp(buff, "*182", 4) || /* SMS Premiership Update */
        !strncmp(buff, "900192", 6) || !strncmp(buff, "B192", 4) || !strncmp(buff, "*192", 4) || /* Horoscope English */
        !strncmp(buff, "900193", 6) || !strncmp(buff, "B193", 4) || !strncmp(buff, "*193", 4) || /* Joke English */
        !strncmp(buff, "900194", 6) || !strncmp(buff, "B194", 4) || !strncmp(buff, "*194", 4) || /* Thailand Travel Guide English */
        !strncmp(buff, "900197", 6) || !strncmp(buff, "B197", 4) || !strncmp(buff, "*197", 4) || /* IR Voice Info */
        !strncmp(buff, "900198", 6) || !strncmp(buff, "B198", 4) || !strncmp(buff, "*198", 4) || /* SMS Promotion News Activat */
        !strncmp(buff, "900199", 6) || !strncmp(buff, "B199", 4) || !strncmp(buff, "*199", 4) || /* Int'l Voice Mail */
        !strncmp(buff, "900600", 6) || !strncmp(buff, "B600", 4) || !strncmp(buff, "*600", 4) || /* SMS ShockManager Game - Register */
        !strncmp(buff, "900855", 6) || !strncmp(buff, "B855", 4) || !strncmp(buff, "*855", 4) || /* Music Together */    /* Added on 10-Apr-2002 by Kawee */
        !strncmp(buff, "900911", 6) || !strncmp(buff, "B911", 4) || !strncmp(buff, "*911", 4) || /* Querry to CQS */
        !strncmp(buff, "900933", 6) || !strncmp(buff, "B933", 4) || !strncmp(buff, "*933", 4) || /* WAP Service (NOKIA) */
        !strncmp(buff, "900934", 6) || !strncmp(buff, "B934", 4) || !strncmp(buff, "*934", 4) || /* WAP Service */
        !strncmp(buff, "900936", 6) || !strncmp(buff, "B936", 4) || !strncmp(buff, "*936", 4) || /* Major WAP Ticketing */
        !strncmp(buff, "900937", 6) || !strncmp(buff, "B937", 4) || !strncmp(buff, "*937", 4) || /* Internet on Demand */
        !strncmp(buff, "900941", 6) || !strncmp(buff, "B941", 4) || !strncmp(buff, "*941", 4) || /* Horoscope Thai */
        !strncmp(buff, "900942", 6) || !strncmp(buff, "B942", 4) || !strncmp(buff, "*942", 4) || /* Lottery Info */
        !strncmp(buff, "900943", 6) || !strncmp(buff, "B943", 4) || !strncmp(buff, "*943", 4) || /* Joke */
        !strncmp(buff, "900944", 6) || !strncmp(buff, "B944", 4) || !strncmp(buff, "*944", 4) || /* Movie Preview */
        !strncmp(buff, "900945", 6) || !strncmp(buff, "B945", 4) || !strncmp(buff, "*945", 4) || /* Thailand Travel Guide */
        !strncmp(buff, "900946", 6) || !strncmp(buff, "B946", 4) || !strncmp(buff, "*946", 4) || /* Restaurant Guide */
        !strncmp(buff, "900947", 6) || !strncmp(buff, "B947", 4) || !strncmp(buff, "*947", 4) || /* Thai Boxing Insider */
        !strncmp(buff, "900948", 6) || !strncmp(buff, "B948", 4) || !strncmp(buff, "*948", 4) || /* Inside Soccer Hotline */
        !strncmp(buff, "900949", 6) || !strncmp(buff, "B949", 4) || !strncmp(buff, "*949", 4) || /* Matching Check */
        !strncmp(buff, "900951", 6) || !strncmp(buff, "B951", 4) || !strncmp(buff, "*951", 4) || /* Fax on Demand */
        !strncmp(buff, "900955", 6) || !strncmp(buff, "B955", 4) || !strncmp(buff, "*955", 4) || /* Music Phone Vote */
        !strncmp(buff, "900956", 6) || !strncmp(buff, "B956", 4) || !strncmp(buff, "*956", 4) || /* Music Phone Vote */
        !strncmp(buff, "900957", 6) || !strncmp(buff, "B957", 4) || !strncmp(buff, "*957", 4) || /* Music Phone Vote */
        !strncmp(buff, "900958", 6) || !strncmp(buff, "B958", 4) || !strncmp(buff, "*958", 4) || /* Music Phone Vote */
        !strncmp(buff, "900959", 6) || !strncmp(buff, "B959", 4) || !strncmp(buff, "*959", 4) || /* Music Phone Chart */
        !strncmp(buff, "9001117", 7) || !strncmp(buff, "B1117", 5) || !strncmp(buff, "*1117", 5) || /* CRM Project */
        !strncmp(buff, "9001919", 7) || !strncmp(buff, "B1919", 5) || !strncmp(buff, "*1919", 5) || /* ITV Vote */
        !strncmp(buff, "9009020", 7) || !strncmp(buff, "B9020", 5) || !strncmp(buff, "*9020", 5) || /* GSM Melodies */
        !strncmp(buff, "9009021", 7) || !strncmp(buff, "B9021", 5) || !strncmp(buff, "*9021", 5) || /* GSM Melodies */
        !strncmp(buff, "9009022", 7) || !strncmp(buff, "B9022", 5) || !strncmp(buff, "*9022", 5) || /* GSM Melodies */
        !strncmp(buff, "90088800", 8) || !strncmp(buff, "B88800", 6) || !strncmp(buff, "*88800", 6) || /* Logo & Ringtone - Mweb */
        !strncmp(buff, "1113", 4)) /* Information service */
        return TRUE;

    else if ( (!strncmp(buff, "900", 3) || *buff == 'B' || *buff == '*') &&    /* added by chamy on 3-Oct-2001 */
           strlen(buff) < SIZE_PHONENO-3 ) /* other (than above) Vas Numbers */
        return TRUE;

    else if ( Is_ExpressLink (buff))         /* Express Link number + pager No. */
        return TRUE;
    else
        return FALSE;
}

void    Set_VasFeature (char *buff)
{
    if ( !strncmp(buff, "T99", 3))      /* (Transfer to) Voice mail Recording */
        strcpy(com_buf.feature_code, "6");

    else if ( !strncmp(buff, "90013", 5) || !strncmp(buff, "B13", 3) || !strncmp(buff, "*13", 3)) /* Easy 13 */
        strcpy(com_buf.feature_code, "68");

    else if ( !strncmp(buff, "90017", 5) || !strncmp(buff, "B17", 3) || !strncmp(buff, "*17", 3)) /* AIS Local Service Line */
        strcpy(com_buf.feature_code, "63");

    else if ( !strncmp(buff, "90096", 5) || !strncmp(buff, "B96", 3) || !strncmp(buff, "*96", 3)) /* Voice Bill Info */
        strcpy(com_buf.feature_code, "11");

    else if ( !strncmp(buff, "90097", 5) || !strncmp(buff, "B97", 3) || !strncmp(buff, "*97", 3)) /* Voice Info */
        strcpy(com_buf.feature_code, "10");

    else if ( !strncmp(buff, "90098", 5) || !strncmp(buff, "B98", 3) || !strncmp(buff, "*98", 3)) /* Voice msg to GSM Phone */
        strcpy(com_buf.feature_code, "5");

    else if ( !strncmp(buff, "90099", 5) || !strncmp(buff, "B99", 3) || !strncmp(buff, "*99", 3))  /* Voice Mail */
        strcpy(com_buf.feature_code, "5");

    else if ( !strncmp(buff, "900100", 6) || !strncmp(buff, "B100", 4) || !strncmp(buff, "*100", 4)) /* IVR */
        strcpy(com_buf.feature_code, "32");

    else if ( !strncmp(buff, "900110", 6) || !strncmp(buff, "B110", 4) || !strncmp(buff, "*110", 4)) /* Football Answering */
        strcpy(com_buf.feature_code, "33");

    else if ( !strncmp(buff, "900111", 6) || !strncmp(buff, "B111", 4) || !strncmp(buff, "*111", 4)) /* Minute Plus */
        strcpy(com_buf.feature_code, "43");

    else if ( !strncmp(buff, "900119", 6) || !strncmp(buff, "B119", 4) || !strncmp(buff, "*119", 4)) /* Web Setting (OTA) */
        strcpy(com_buf.feature_code, "113");

    else if ( !strncmp(buff, "900123", 6) || !strncmp(buff, "B123", 4) || !strncmp(buff, "*123", 4)) /* Entertainment */
        strcpy(com_buf.feature_code, "42");

    else if ( !strncmp(buff, "900129", 6) || !strncmp(buff, "B129", 4) || !strncmp(buff, "*129", 4)) /* Prepaid Voice Mail */
        strcpy(com_buf.feature_code, "5"); /* Added by Kawee on 17-Jan-2003 */

    else if ( !strncmp(buff, "900180", 6) || !strncmp(buff, "B180", 4) || !strncmp(buff, "*180", 4)) /* Cancel SMS Premiership */
        strcpy(com_buf.feature_code, "111");

    else if ( !strncmp(buff, "900181", 6) || !strncmp(buff, "B181", 4) || !strncmp(buff, "*181", 4)) /* SMS Premiership Update */
        strcpy(com_buf.feature_code, "112");

    else if ( !strncmp(buff, "900182", 6) || !strncmp(buff, "B182", 4) || !strncmp(buff, "*182", 4)) /* SMS Premiership Update */
        strcpy(com_buf.feature_code, "112");

    else if ( !strncmp(buff, "900151", 6) || !strncmp(buff, "B151", 4) || !strncmp(buff, "*151", 4)) /* Express Link to Phonelink followed by Pager No. */
        strcpy(com_buf.feature_code, "9");

    else if ( !strncmp(buff, "900161", 6) || !strncmp(buff, "B161", 4) || !strncmp(buff, "*161", 4)) /* Express Link to Hachitson followed by Pager No. */
        strcpy(com_buf.feature_code, "48");

    else if ( !strncmp(buff, "900192", 6) || !strncmp(buff, "B192", 4) || !strncmp(buff, "*192", 4)) /* Horoscope English */
        strcpy(com_buf.feature_code, "85");

    else if ( !strncmp(buff, "900193", 6) || !strncmp(buff, "B193", 4) || !strncmp(buff, "*193", 4)) /* Joke English */
        strcpy(com_buf.feature_code, "86");

    else if ( !strncmp(buff, "900194", 6) || !strncmp(buff, "B194", 4) || !strncmp(buff, "*194", 4)) /* Thailand Travel Guide English */
        strcpy(com_buf.feature_code, "87");

    else if ( !strncmp(buff, "900197", 6) || !strncmp(buff, "B197", 4) || !strncmp(buff, "*197", 4)) /* IR Voice Info */
        strcpy(com_buf.feature_code, "72");

    else if ( !strncmp(buff, "900198", 6) || !strncmp(buff, "B198", 4) || !strncmp(buff, "*198", 4)) /* SMS Promotion News Activat */
        strcpy(com_buf.feature_code, "40");

    else if ( !strncmp(buff, "900199", 6) || !strncmp(buff, "B199", 4) || !strncmp(buff, "*199", 4)) /* Int'l Voice Mail */
        strcpy(com_buf.feature_code, "41");

    else if ( !strncmp(buff, "900600", 6) || !strncmp(buff, "B600", 4) || !strncmp(buff, "*600", 4)) /* SMS ShockManager Game - Register */
        strcpy(com_buf.feature_code, "111");

/* Added Music Together VAS number on 10-Apr-2002 by Kawee */
    else if ( !strncmp(buff, "900855", 6) || !strncmp(buff, "B855", 4) || !strncmp(buff, "*855", 4)) /* Music Together */
        strcpy(com_buf.feature_code, "129");

    else if ( !strncmp(buff, "900911", 6) || !strncmp(buff, "B911", 4) || !strncmp(buff, "*911", 4)) /* Querry to CQS */
        strcpy(com_buf.feature_code, "67");

    else if ( !strncmp(buff, "900933", 6) || !strncmp(buff, "B933", 4) || !strncmp(buff, "*933", 4)) /* WAP Service (NOKIA) */
        strcpy(com_buf.feature_code, "84");

    else if ( !strncmp(buff, "900934", 6) || !strncmp(buff, "B934", 4) || !strncmp(buff, "*934", 4)) /* WAP Service */
        strcpy(com_buf.feature_code, "74");

    else if ( !strncmp(buff, "900936", 6) || !strncmp(buff, "B936", 4) || !strncmp(buff, "*936", 4)) /* Major WAP Ticketing */
        strcpy(com_buf.feature_code, "82");

    else if ( !strncmp(buff, "900937", 6) || !strncmp(buff, "B937", 4) || !strncmp(buff, "*937", 4)) /* Internet on Demand */
        strcpy(com_buf.feature_code, "66");

    else if ( !strncmp(buff, "900941", 6) || !strncmp(buff, "B941", 4) || !strncmp(buff, "*941", 4)) /* Horoscope Thai */
        strcpy(com_buf.feature_code, "24");

    else if ( !strncmp(buff, "900942", 6) || !strncmp(buff, "B942", 4) || !strncmp(buff, "*942", 4)) /* Lottery Info */
        strcpy(com_buf.feature_code, "27");

    else if ( !strncmp(buff, "900943", 6) || !strncmp(buff, "B943", 4) || !strncmp(buff, "*943", 4)) /* Joke */
        strcpy(com_buf.feature_code, "36");

    else if ( !strncmp(buff, "900944", 6) || !strncmp(buff, "B944", 4) || !strncmp(buff, "*944", 4)) /* Movie Preview */
        strcpy(com_buf.feature_code, "47");

    else if ( !strncmp(buff, "900945", 6) || !strncmp(buff, "B945", 4) || !strncmp(buff, "*945", 4)) /* Thailand Travel Guide */
        strcpy(com_buf.feature_code, "49");

    else if ( !strncmp(buff, "900946", 6) || !strncmp(buff, "B946", 4) || !strncmp(buff, "*946", 4)) /* Restaurant Guide */
        strcpy(com_buf.feature_code, "51");

    else if ( !strncmp(buff, "900947", 6) || !strncmp(buff, "B947", 4) || !strncmp(buff, "*947", 4)) /* Thai Boxing Insider */
        strcpy(com_buf.feature_code, "52");

    else if ( !strncmp(buff, "900948", 6) || !strncmp(buff, "B948", 4) || !strncmp(buff, "*948", 4)) /* Inside Soccer Hotline */
        strcpy(com_buf.feature_code, "53");

    else if ( !strncmp(buff, "900949", 6) || !strncmp(buff, "B949", 4) || !strncmp(buff, "*949", 4)) /* Matching Check */
        strcpy(com_buf.feature_code, "78");

    else if ( !strncmp(buff, "900951", 6) || !strncmp(buff, "B951", 4) || !strncmp(buff, "*951", 4)) /* Fax on Demand */
        strcpy(com_buf.feature_code, "12");

    else if ( !strncmp(buff, "900955", 6) || !strncmp(buff, "B955", 4) || !strncmp(buff, "*955", 4)) /* Music Phone Vote */
        strcpy(com_buf.feature_code, "45");

    else if ( !strncmp(buff, "900956", 6) || !strncmp(buff, "B956", 4) || !strncmp(buff, "*956", 4)) /* Music Phone Vote */
        strcpy(com_buf.feature_code, "54");

    else if ( !strncmp(buff, "900957", 6) || !strncmp(buff, "B957", 4) || !strncmp(buff, "*957", 4)) /* Music Phone Vote */
        strcpy(com_buf.feature_code, "55");

    else if ( !strncmp(buff, "900958", 6) || !strncmp(buff, "B958", 4) || !strncmp(buff, "*958", 4)) /* Music Phone Vote */
        strcpy(com_buf.feature_code, "56");

    else if ( !strncmp(buff, "900959", 6) || !strncmp(buff, "B959", 4) || !strncmp(buff, "*959", 4)) /* Music Phone Chart */
        strcpy(com_buf.feature_code, "46");

    else if ( !strncmp(buff, "9001117", 7) || !strncmp(buff, "B1117", 5) || !strncmp(buff, "*1117", 5)) /* CRM Project */
        strcpy(com_buf.feature_code, "50");

    else if ( !strncmp(buff, "9001143", 7) || !strncmp(buff, "B1143", 5) || !strncmp(buff, "*1143", 5)) /* Express Link to Paclink followed by Pager No. */
        strcpy(com_buf.feature_code, "39");

    else if ( !strncmp(buff, "9001187", 7) || !strncmp(buff, "B1187", 5) || !strncmp(buff, "*1187", 5)) /* Express Link to Posttel followed by Pager No. */
        strcpy(com_buf.feature_code, "37");

    else if ( !strncmp(buff, "9001501", 7) || !strncmp(buff, "B1501", 5) || !strncmp(buff, "*1501", 5)) /* Express Link to Easycall followed by Pager No. */
        strcpy(com_buf.feature_code, "38");

    else if ( !strncmp(buff, "9001919", 7) || !strncmp(buff, "B1919", 5) || !strncmp(buff, "*1919", 5)) /* ITV Vote */
        strcpy(com_buf.feature_code, "75");

    else if ( !strncmp(buff, "9009020", 7) || !strncmp(buff, "B9020", 5) || !strncmp(buff, "*9020", 5)) /* GSM Melodies */
        strcpy(com_buf.feature_code, "89");

    else if ( !strncmp(buff, "9009021", 7) || !strncmp(buff, "B9021", 5) || !strncmp(buff, "*9021", 5)) /* GSM Melodies */
        strcpy(com_buf.feature_code, "89");

    else if ( !strncmp(buff, "9009022", 7) || !strncmp(buff, "B9022", 5) || !strncmp(buff, "*9022", 5)) /* GSM Melodies */
        strcpy(com_buf.feature_code, "89");

    else if ( !strncmp(buff, "90088800", 8) || !strncmp(buff, "B88800", 6) || !strncmp(buff, "*88800", 6)) /* Logo & Ringtone - Mweb */
        strcpy(com_buf.feature_code, "117");

    else if ( !strncmp(buff, "1113", 4))    /* Information service */
        strcpy(com_buf.feature_code, "123");

    else if ( !strncmp(buff, "19001", 5))   /* Audio Text - Premium calls */
        strcpy(com_buf.feature_code, "88");

    else if ( !strncmp(buff, "19003", 5))   /* Audio Text - Premium calls */
        strcpy(com_buf.feature_code, "91");

    else if ( !strncmp(buff, "19004", 5))   /* Audio Text - Premium calls */
        strcpy(com_buf.feature_code, "130");

    else if ( !strncmp(buff, "19005", 5))   /* Audio Text - Premium calls */
        strcpy(com_buf.feature_code, "92");

    else if ( !strncmp(buff, "19008", 5))   /* Audio Text - Premium calls */
        strcpy(com_buf.feature_code, "128");

    else if ( !strncmp(buff, "19009", 5))   /* Audio Text - Premium calls */
        strcpy(com_buf.feature_code, "90");

    else if ( !strncmp(buff, LDDACC1_CODE, LDDACC1_LEN) ||  /* LDD Calls C0xxxxxxxx */
         !strncmp(buff, LDDACC2_CODE, LDDACC2_LEN))    /* LDD Calls #0xxxxxxxx */
        strcpy(com_buf.feature_code, "124");
}

int Is_DpcVasNumber (char *buff)
{
    if ( !strncmp(buff, "1800", 4) || !strncmp(buff, "1802", 4) ||     /* My Logo */
        !strncmp(buff, "1801", 4) ||   /* My Ring Tone */
        !strncmp(buff, "1113", 4) ||   /* Information service */
        !strncmp(buff, "1888", 4))     /* Call Centre */
        return TRUE;

    else if ( Is_DpcVoiceMail (buff))
        return TRUE;

    else if ( !strncmp(buff, "90088900", 8) || !strncmp(buff, "B88900", 6) || !strncmp(buff, "*88900", 6)) /* ?? */
        return TRUE;

    else
        return FALSE;
}

int Is_DpcVoiceMail (char *buff)
{
    /* Voice mail Numbers */
    if ( !strncmp(buff, "1881", 4) || !strncmp(buff, "1882", 4) ||
        !strncmp(buff, "1883", 4) || !strncmp(buff, "1884", 4) ||
        !strncmp(buff, "013101881", 9) || !strncmp(buff, "013101882", 9) ||
        !strncmp(buff, "013101883", 9) || !strncmp(buff, "013101884", 9) ||
        !strncmp(buff, "0813101883", 9) || !strncmp(buff, "0813101884", 9) || /* 10 Digits - Added by Kawee on 03-Mar-2006 */
        !strncmp(buff, "0913101883", 9) || !strncmp(buff, "0913101884", 9))   /* 10 Digits - Added by Thanakorn on 23-Mar-2011 */
        return TRUE;
    else
        return FALSE;
}

/*
** Name     : bcudrCorrectVolumn()
**
** Description  : Find the Correct Volumn Value for GPRS Volumn Base on VSCP Bcudr CdrType.
**
** Parameters   : None
**
** Return Value : Correct Volumn Value.
*/

long    bcudrCorrectVol (const char *pchVolumn, const char *pchRqr)
{
    int     iRqrLen;
    int     i, iCnt;
    char const  *pchCorrectVol;

    /*
    ** Check RQR Field have information for correct volumn value or not
    ** RQR format is xxxxx-xxxxx-xxxxx-xxxxx
    **            or xxxxx-xxxxx-xxxxx-xxxxx-yyyyy
    ** where xxxxx is any string
    **       yyyyy is the value for correct the volumn field.
    ** if the 5th sub field in RQR field have value then
    ** correct the volumn value as below:
    **       Vol = Vol - yyyyy;
    ** In case of not found yyyyy field then
    **       Vol = Vol;
    **
    ** - Kawee, 20-May-2005
    */
    iRqrLen = strlen(pchRqr);
    iCnt = 0;
    pchCorrectVol = NULL;
    for (i = 0; i < iRqrLen; i++) {
        if ( pchRqr[i] == '-') {
            iCnt++;
            if ( iCnt == 4) {    /* Found 4th '-' delimeter */
                pchCorrectVol = pchRqr + i + 1;
                break;
            }
        }
    }
    if ( pchCorrectVol) {    /* Found the value for correct the invalid volumn */
        return (atol(pchVolumn) - atol(pchCorrectVol));
    }
    return (atol(pchVolumn));
}

/*
** Name         : Get_StrTok()
**
** Description  : Find next token in a string
**
** Parameters   : char *strToken         - INPUT - String containing token(s)
**                const char delimit - INPUT - Delimit character.
**
** Return Value : pointer to the next token string.
*/
char    *Get_StrTok(char *strToken, const char delimit)
{
    static char     *pNextToken;
    char            *rv;

    if ( !delimit)               /* null */
        return 0;

    if ( strToken) {             /* Case New String */
        if ( !strlen(strToken))
            return 0;

        pNextToken = strToken;
    }

    if ( pNextToken == 0)
        return 0;

    rv = pNextToken;

    while ((*pNextToken != delimit) && (*pNextToken))
        pNextToken++;

    if ( *pNextToken == delimit) {   /* match delimiter */
        *pNextToken = 0;    /* replace delimit null */
        pNextToken++;
    }
    else    /* no more next token */
        pNextToken = 0;

    return rv;
}

void StrToUpper(char *src, int s_size, char *dest)
{
    int i=0;
    for (i=0; i<s_size; i++)
    {
        *(dest+i) = toupper(*(src+i));
    }
}

char *RemoveChar(char *data, int size, char c)
{

    int i, j;
    j = 0;
    for ( i = 0; i < size; i++ ) {
        if ( data[i] != c ) {
            data[j] = data[i];
            j++;
        }
    }
    data[j] = '\0';

    return data;
}

int Split_Pps_Cdr(char *wrtn_rec)
{
#ifdef _PRNT_FUNC_CALL_
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Split_Pps_Cdr");
    _p_ = 0;
#endif
    int id = -1;
    char file[SIZE_FNAME];

    if ( glb_Enable_Splt == 'N' )
        return SUCCESS;


    if ( glb_MtxInd == AWN_TYPE && glb_SpltType_Flg[PPSAWN_AWN] == 'Y' ) {
        id = PPSAWN_AWN;
    }
    else if ( glb_MtxInd == AWNSMS_TYPE && glb_SpltType_Flg[PPSAWN_SMS] == 'Y' ) {
        id = PPSAWN_SMS;
    }
    else if ( glb_MtxInd == AWNGPR_TYPE && glb_SpltType_Flg[PPSAWN_GPRS] == 'Y' ) {
        id = PPSAWN_GPRS;
    }
    else {
        return SUCCESS;
    }

    memset(file, 0x00, sizeof(file));
    if ( glb_PpsSpltfp[id] == NULL ) {
        sprintf(file, "%s/%s", glb_SpltCdr_Dir[id], glb_Cdr_File);
        if ( (glb_PpsSpltfp[id] = fopen(file, MODE_APPEND)) == NULL ) {
            writeLog(LOG_SYS, "cannot Open pps awn splitted file %s (%s)", file, strerror(errno));
            return FAILURE;
        }
    }
    if ( glb_PpsSpltfp[id] != NULL ) {
        fputs(wrtn_rec, glb_PpsSpltfp[id]);
    }

    return SUCCESS;
}

void Close_Split_Pps()
{
#ifdef _PRNT_FUNC_CALL_     // using verification done
    static short _p_ = 1;
    if ( _p_ )
        writeLog(LOG_INF, "FnCall=> Close_Split_Pps");
    _p_ = 0;
#endif
    int i;
    char file[SIZE_FNAME+1];
    FILE *fp = NULL;

    if ( glb_Enable_Splt == 'N' )
        return;

    for ( i=0; i<NOF_PPSAWN_PATH; i++ ) {
        if ( glb_PpsSpltfp[i] != NULL ) {
            /* flush and close opened file */
            fclose(glb_PpsSpltfp[i]);
            glb_PpsSpltfp[i] = NULL;

            /* create syn file for that closed file */
            memset(file, 0x00, sizeof(file));
            sprintf(file, "%s/%s.syn", glb_SpltCdr_Syn[i], glb_Cdr_File);
            fp = fopen(file, MODE_WRITE);
            fclose(fp);
            fp = NULL;
        }
    }

}

char *reverseStr(char *str)
{
    static char revStr[50+1];
    memset(revStr, 0x00, sizeof(revStr));

    int len = strlen(str);
    int i = 0;
    //char c = 0;
    while ( len >= 0 ) {
        if ( i >= 50 ) {
            break;
        }
        revStr[i++] = *(str+len-1);
        len--;
    }
    return revStr;
}

char *decTo64(char *s_decimal)
{
   static char b64Str[5+1];
   memset(b64Str, 0x00, sizeof(b64Str));

   int dec = atoi(s_decimal);
   int pos = 0;
   while ( dec >= 0 ) {
        if ( pos >= 5 ) {
            break;
        }
        b64Str[pos++] = glb_sBASE64[ (dec%BASE64) ];
        dec = (dec/BASE64);
        if ( dec == 0 ) {
            break;
        }
   }
   return reverseStr(b64Str);
}

// copy src from last with num of characters to dest
void strrcpy(char *dest, char *src, int num)
{
    if ( src == '\0' ) {
        strcpy(dest, "");
        return;
    }

    int len = strlen(src);
    if ( len <= num ) {
        strcpy(dest, src);
    }
    else {
        strncpy(dest, src+len-num, num);
        *(dest+num) = 0;
    }
}

// int Cdg_To_Dcb_Event           -> DCB
// int DpcGprs_To_Data_Event      -> GPRS
// int Gprs_To_Data_Event_18      -> GPRS
// int Rbt_To_Rbt_Event           -> RBT
// int Sdg_To_Event               -> SDG
// int Sms_To_Sms_Event           -> SMS
// int Smc_To_Sms_Event           -> SMS
// int Gsm_To_Sms_Event           -> SMS
// int DpcGsm_To_Sms_Event        -> SMS
// int Usc_To_Usc_Event           -> USC
// int Gprst_To_Data_Event_Bcudr  -> VSCP
// int Ccudr_To_Session_Event     -> VSCP
// int Mms_To_Mms_Event_Tcudr     -> VSCP
// int Cdg_To_Cdg_Event_Ctudr     -> VSCP
// int CommonVoice_To_Voice_Event -> VOICE
/*- End - */

